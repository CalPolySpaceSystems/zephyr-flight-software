
zephyr.elf:     file format elf32-littlearm


Disassembly of section text:

00080000 <_vector_table>:
   80000:	20071388 	.word	0x20071388
   80004:	000812e9 	.word	0x000812e9
   80008:	00081341 	.word	0x00081341
   8000c:	00081165 	.word	0x00081165
   80010:	00081165 	.word	0x00081165
   80014:	00081165 	.word	0x00081165
   80018:	00081165 	.word	0x00081165
   8001c:	00081165 	.word	0x00081165
   80020:	00081165 	.word	0x00081165
   80024:	00081165 	.word	0x00081165
   80028:	00081165 	.word	0x00081165
   8002c:	00080db1 	.word	0x00080db1
   80030:	00081165 	.word	0x00081165
   80034:	00081165 	.word	0x00081165
   80038:	00080d6d 	.word	0x00080d6d
   8003c:	00080c79 	.word	0x00080c79

00080040 <_irq_vector_table>:
   80040:	000812c5 000812c5 000812c5 000812c5     ................
   80050:	000812c5 000812c5 000812c5 000812c5     ................
   80060:	000812c5 000812c5 000812c5 000812c5     ................
   80070:	000812c5 000812c5 000812c5 000812c5     ................
   80080:	000812c5 000812c5 000812c5 000812c5     ................
   80090:	000812c5 000812c5 000812c5 000812c5     ................
   800a0:	000812c5 000812c5 000812c5 000812c5     ................
   800b0:	000812c5 000812c5 000812c5 000812c5     ................
   800c0:	000812c5 000812c5 000812c5 000812c5     ................
   800d0:	000812c5 000812c5 000812c5 000812c5     ................
   800e0:	000812c5 000812c5 000812c5 000812c5     ................
   800f0:	000812c5                                ....

000800f4 <_sw_isr_table>:
   800f4:	00000000 000810b5 00000000 000810b5     ................
   80104:	00000000 000810b5 00000000 000810b5     ................
   80114:	00000000 000810b5 00000000 000810b5     ................
   80124:	00000000 000810b5 00000000 000810b5     ................
   80134:	00000000 000810b5 00000000 000810b5     ................
   80144:	00000000 000810b5 20071d10 0008167d     ........... }...
   80154:	20071d04 0008167d 20071cf8 0008167d     ... }...... }...
   80164:	20071cec 0008167d 00000000 000810b5     ... }...........
   80174:	00000000 000810b5 00000000 000810b5     ................
   80184:	00000000 000810b5 00000000 000810b5     ................
   80194:	00000000 000810b5 00000000 000810b5     ................
   801a4:	00000000 000810b5 00000000 000810b5     ................
   801b4:	00000000 000810b5 00000000 000810b5     ................
   801c4:	00000000 000810b5 00000000 000810b5     ................
   801d4:	00000000 000810b5 00000000 000810b5     ................
   801e4:	00000000 000810b5 00000000 000810b5     ................
   801f4:	00000000 000810b5 00000000 000810b5     ................
   80204:	00000000 000810b5 00000000 000810b5     ................
   80214:	00000000 000810b5 00000000 000810b5     ................
   80224:	00000000 000810b5 00000000 000810b5     ................
   80234:	00000000 000810b5 00000000 000810b5     ................
   80244:	00000000 000810b5 00000000 000810b5     ................
   80254:	00000000 000810b5                       ........

0008025c <uart_out>:
{
	blink(PORT1, 1000, LED1, 1);
}

void uart_out(void)
{
   8025c:	b570      	push	{r4, r5, r6, lr}

K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_ALLOC_APPEND, k_queue_alloc_append, int, struct k_queue *, queue, void *, data);

K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_ALLOC_PREPEND, k_queue_alloc_prepend, int, struct k_queue *, queue, void *, data);

K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout);
   8025e:	4e08      	ldr	r6, [pc, #32]	; (80280 <uart_out+0x24>)
	while (1) {
		struct printk_data_t *rx_data = k_fifo_get(&printk_fifo, K_FOREVER);
		printk("Toggle USR%d LED: Counter = %d\n", rx_data->led, rx_data->cnt);
   80260:	4d08      	ldr	r5, [pc, #32]	; (80284 <uart_out+0x28>)
   80262:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   80266:	4630      	mov	r0, r6
   80268:	f001 fd7a 	bl	81d60 <_impl_k_queue_get>
   8026c:	4604      	mov	r4, r0
   8026e:	6882      	ldr	r2, [r0, #8]
   80270:	6841      	ldr	r1, [r0, #4]
   80272:	4628      	mov	r0, r5
   80274:	f000 fcb6 	bl	80be4 <printk>
		k_free(rx_data);
   80278:	4620      	mov	r0, r4
   8027a:	f001 fcea 	bl	81c52 <k_free>
   8027e:	e7f0      	b.n	80262 <uart_out+0x6>
   80280:	20071dbc 	.word	0x20071dbc
   80284:	000829cb 	.word	0x000829cb

00080288 <blink>:
{
   80288:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8028c:	b085      	sub	sp, #20
   8028e:	460f      	mov	r7, r1
   80290:	4616      	mov	r6, r2
   80292:	4699      	mov	r9, r3
	gpio_dev = device_get_binding(port);
   80294:	f001 fb2c 	bl	818f0 <device_get_binding>
	__ASSERT_NO_MSG(gpio_dev != NULL);
   80298:	4605      	mov	r5, r0
   8029a:	b948      	cbnz	r0, 802b0 <blink+0x28>
   8029c:	232c      	movs	r3, #44	; 0x2c
   8029e:	4a20      	ldr	r2, [pc, #128]	; (80320 <blink+0x98>)
   802a0:	4920      	ldr	r1, [pc, #128]	; (80324 <blink+0x9c>)
   802a2:	4821      	ldr	r0, [pc, #132]	; (80328 <blink+0xa0>)
   802a4:	f000 fc9e 	bl	80be4 <printk>
   802a8:	4820      	ldr	r0, [pc, #128]	; (8032c <blink+0xa4>)
   802aa:	f000 fc9b 	bl	80be4 <printk>
   802ae:	e7fe      	b.n	802ae <blink+0x26>
				    u32_t pin, int flags)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	return api->config(port, access_op, pin, flags);
   802b0:	6843      	ldr	r3, [r0, #4]
   802b2:	4632      	mov	r2, r6
   802b4:	681c      	ldr	r4, [r3, #0]
   802b6:	2100      	movs	r1, #0
   802b8:	2301      	movs	r3, #1
   802ba:	47a0      	blx	r4
	int cnt = 0;
   802bc:	2400      	movs	r4, #0
				   u32_t pin, u32_t value)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	return api->write(port, access_op, pin, value);
   802be:	46a2      	mov	sl, r4
		k_fifo_put(&printk_fifo, mem_ptr);
   802c0:	f8df 8070 	ldr.w	r8, [pc, #112]	; 80334 <blink+0xac>
   802c4:	686a      	ldr	r2, [r5, #4]
		gpio_pin_write(gpio_dev, led, cnt % 2);
   802c6:	2c00      	cmp	r4, #0
   802c8:	f004 0301 	and.w	r3, r4, #1
   802cc:	f8d2 b004 	ldr.w	fp, [r2, #4]
   802d0:	bfb8      	it	lt
   802d2:	425b      	neglt	r3, r3
   802d4:	4632      	mov	r2, r6
   802d6:	2100      	movs	r1, #0
   802d8:	4628      	mov	r0, r5
   802da:	47d8      	blx	fp
		char *mem_ptr = k_malloc(size);
   802dc:	200c      	movs	r0, #12
		struct printk_data_t tx_data = { .led = id, .cnt = cnt };
   802de:	f8cd a004 	str.w	sl, [sp, #4]
   802e2:	f8cd 9008 	str.w	r9, [sp, #8]
   802e6:	9403      	str	r4, [sp, #12]
		char *mem_ptr = k_malloc(size);
   802e8:	f001 fcb8 	bl	81c5c <k_malloc>
		__ASSERT_NO_MSG(mem_ptr != 0);
   802ec:	4683      	mov	fp, r0
   802ee:	b948      	cbnz	r0, 80304 <blink+0x7c>
   802f0:	2337      	movs	r3, #55	; 0x37
   802f2:	4a0b      	ldr	r2, [pc, #44]	; (80320 <blink+0x98>)
   802f4:	490e      	ldr	r1, [pc, #56]	; (80330 <blink+0xa8>)
   802f6:	480c      	ldr	r0, [pc, #48]	; (80328 <blink+0xa0>)
   802f8:	f000 fc74 	bl	80be4 <printk>
   802fc:	480b      	ldr	r0, [pc, #44]	; (8032c <blink+0xa4>)
   802fe:	f000 fc71 	bl	80be4 <printk>
   80302:	e7fe      	b.n	80302 <blink+0x7a>
		memcpy(mem_ptr, &tx_data, size);
   80304:	220c      	movs	r2, #12
   80306:	a901      	add	r1, sp, #4
   80308:	f001 f82e 	bl	81368 <memcpy>
		k_fifo_put(&printk_fifo, mem_ptr);
   8030c:	4659      	mov	r1, fp
   8030e:	4640      	mov	r0, r8
   80310:	f001 fd21 	bl	81d56 <k_queue_append>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SLEEP, k_sleep, s32_t, duration);
   80314:	4638      	mov	r0, r7
   80316:	f002 f829 	bl	8236c <_impl_k_sleep>
		cnt++;
   8031a:	3401      	adds	r4, #1
	while (1) {
   8031c:	e7d2      	b.n	802c4 <blink+0x3c>
   8031e:	bf00      	nop
   80320:	0008296c 	.word	0x0008296c
   80324:	0008297d 	.word	0x0008297d
   80328:	00082995 	.word	0x00082995
   8032c:	000829b3 	.word	0x000829b3
   80330:	000829b4 	.word	0x000829b4
   80334:	20071dbc 	.word	0x20071dbc

00080338 <blink1>:
{
   80338:	b508      	push	{r3, lr}
	blink(PORT0, 100, LED0, 0);
   8033a:	221b      	movs	r2, #27
   8033c:	2300      	movs	r3, #0
   8033e:	2164      	movs	r1, #100	; 0x64
   80340:	4801      	ldr	r0, [pc, #4]	; (80348 <blink1+0x10>)
   80342:	f7ff ffa1 	bl	80288 <blink>
   80346:	bf00      	nop
   80348:	000829c1 	.word	0x000829c1

0008034c <blink2>:
{
   8034c:	b508      	push	{r3, lr}
	blink(PORT1, 1000, LED1, 1);
   8034e:	2208      	movs	r2, #8
   80350:	2301      	movs	r3, #1
   80352:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   80356:	4801      	ldr	r0, [pc, #4]	; (8035c <blink2+0x10>)
   80358:	f7ff ff96 	bl	80288 <blink>
   8035c:	000829c6 	.word	0x000829c6

00080360 <atmel_sam3x_init>:
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
   80360:	f04f 0310 	mov.w	r3, #16
   80364:	f3ef 8111 	mrs	r1, BASEPRI
   80368:	f383 8811 	msr	BASEPRI, r3
static ALWAYS_INLINE void _ClearFaults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   8036c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   80370:	4b1d      	ldr	r3, [pc, #116]	; (803e8 <atmel_sam3x_init+0x88>)
   80372:	629a      	str	r2, [r3, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   80374:	62da      	str	r2, [r3, #44]	; 0x2c
	 * Set FWS (Flash Wait State) value before increasing Master Clock
	 * (MCK) frequency.
	 * TODO: set FWS based on the actual MCK frequency and VDDCORE value
	 * rather than maximum supported 84 MHz at standard VDDCORE=1.8V
	 */
	EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
   80376:	f44f 6380 	mov.w	r3, #1024	; 0x400
   8037a:	4a1c      	ldr	r2, [pc, #112]	; (803ec <atmel_sam3x_init+0x8c>)
   8037c:	6013      	str	r3, [r2, #0]
	EFC1->EEFC_FMR = EEFC_FMR_FWS(4);
   8037e:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	PMC->CKGR_MOR =   CKGR_MOR_KEY_PASSWD
   80382:	4b1b      	ldr	r3, [pc, #108]	; (803f0 <atmel_sam3x_init+0x90>)
   80384:	4a1b      	ldr	r2, [pc, #108]	; (803f4 <atmel_sam3x_init+0x94>)
   80386:	621a      	str	r2, [r3, #32]
	while (!(PMC->PMC_SR & PMC_SR_MOSCXTS)) {
   80388:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   8038a:	07d2      	lsls	r2, r2, #31
   8038c:	d5fc      	bpl.n	80388 <atmel_sam3x_init+0x28>
	PMC->CKGR_MOR =   CKGR_MOR_KEY_PASSWD
   8038e:	4a1a      	ldr	r2, [pc, #104]	; (803f8 <atmel_sam3x_init+0x98>)
   80390:	621a      	str	r2, [r3, #32]
	while (!(PMC->PMC_SR & PMC_SR_MOSCSELS)) {
   80392:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   80394:	03d0      	lsls	r0, r2, #15
   80396:	d5fc      	bpl.n	80392 <atmel_sam3x_init+0x32>
	PMC->CKGR_MOR =   CKGR_MOR_KEY_PASSWD
   80398:	4a18      	ldr	r2, [pc, #96]	; (803fc <atmel_sam3x_init+0x9c>)
   8039a:	621a      	str	r2, [r3, #32]
	while (PMC->PMC_SR & PMC_SR_MOSCRCS) {
   8039c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   8039e:	0392      	lsls	r2, r2, #14
   803a0:	d4fc      	bmi.n	8039c <atmel_sam3x_init+0x3c>
	reg_val = PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk;
   803a2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   803a4:	f022 0203 	bic.w	r2, r2, #3
	PMC->PMC_MCKR = reg_val | PMC_MCKR_CSS_MAIN_CLK;
   803a8:	f042 0201 	orr.w	r2, r2, #1
   803ac:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
   803ae:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   803b0:	0710      	lsls	r0, r2, #28
   803b2:	d5fc      	bpl.n	803ae <atmel_sam3x_init+0x4e>
	PMC->CKGR_PLLAR =   CKGR_PLLAR_ONE
   803b4:	4a12      	ldr	r2, [pc, #72]	; (80400 <atmel_sam3x_init+0xa0>)
   803b6:	629a      	str	r2, [r3, #40]	; 0x28
	while (!(PMC->PMC_SR & PMC_SR_LOCKA)) {
   803b8:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   803ba:	0792      	lsls	r2, r2, #30
   803bc:	d5fc      	bpl.n	803b8 <atmel_sam3x_init+0x58>
	reg_val = PMC->PMC_MCKR & ~PMC_MCKR_PRES_Msk;
   803be:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   803c0:	f022 0270 	bic.w	r2, r2, #112	; 0x70
	PMC->PMC_MCKR = reg_val | PMC_MCKR_PRES_CLK_1;
   803c4:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
   803c6:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   803c8:	0710      	lsls	r0, r2, #28
   803ca:	d5fc      	bpl.n	803c6 <atmel_sam3x_init+0x66>
	reg_val = PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk;
   803cc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   803ce:	f022 0203 	bic.w	r2, r2, #3
	PMC->PMC_MCKR = reg_val | PMC_MCKR_CSS_PLLA_CLK;
   803d2:	f042 0202 	orr.w	r2, r2, #2
   803d6:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
   803d8:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   803da:	0712      	lsls	r2, r2, #28
   803dc:	d5fc      	bpl.n	803d8 <atmel_sam3x_init+0x78>
	if (key) {
		return;
	}
	__asm__ volatile("cpsie i" : : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   803de:	f381 8811 	msr	BASEPRI, r1
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   803e2:	2000      	movs	r0, #0
   803e4:	4770      	bx	lr
   803e6:	bf00      	nop
   803e8:	e000ed00 	.word	0xe000ed00
   803ec:	400e0a00 	.word	0x400e0a00
   803f0:	400e0600 	.word	0x400e0600
   803f4:	0037ff09 	.word	0x0037ff09
   803f8:	0137ff09 	.word	0x0137ff09
   803fc:	0137ff01 	.word	0x0137ff01
   80400:	20063f01 	.word	0x20063f01

00080404 <soc_pmc_peripheral_enable>:
#error "Unsupported SoC, update soc_pmc.c functions"
#endif

void soc_pmc_peripheral_enable(u32_t id)
{
	__ASSERT(id < ID_PERIPH_COUNT, "Invalid peripheral id");
   80404:	282c      	cmp	r0, #44	; 0x2c
{
   80406:	b508      	push	{r3, lr}
	__ASSERT(id < ID_PERIPH_COUNT, "Invalid peripheral id");
   80408:	d909      	bls.n	8041e <soc_pmc_peripheral_enable+0x1a>
   8040a:	2315      	movs	r3, #21
   8040c:	4a0a      	ldr	r2, [pc, #40]	; (80438 <soc_pmc_peripheral_enable+0x34>)
   8040e:	490b      	ldr	r1, [pc, #44]	; (8043c <soc_pmc_peripheral_enable+0x38>)
   80410:	480b      	ldr	r0, [pc, #44]	; (80440 <soc_pmc_peripheral_enable+0x3c>)
   80412:	f000 fbe7 	bl	80be4 <printk>
   80416:	480b      	ldr	r0, [pc, #44]	; (80444 <soc_pmc_peripheral_enable+0x40>)
   80418:	f000 fbe4 	bl	80be4 <printk>
   8041c:	e7fe      	b.n	8041c <soc_pmc_peripheral_enable+0x18>
   8041e:	2301      	movs	r3, #1

	if (id < 32) {
   80420:	281f      	cmp	r0, #31
   80422:	4a09      	ldr	r2, [pc, #36]	; (80448 <soc_pmc_peripheral_enable+0x44>)
		PMC->PMC_PCER0 = BIT(id);
#if ID_PERIPH_COUNT > 32
	} else {
		PMC->PMC_PCER1 = BIT(id & 0x1F);
   80424:	bf8b      	itete	hi
   80426:	f000 001f 	andhi.w	r0, r0, #31
		PMC->PMC_PCER0 = BIT(id);
   8042a:	4083      	lslls	r3, r0
		PMC->PMC_PCER1 = BIT(id & 0x1F);
   8042c:	4083      	lslhi	r3, r0
		PMC->PMC_PCER0 = BIT(id);
   8042e:	6113      	strls	r3, [r2, #16]
		PMC->PMC_PCER1 = BIT(id & 0x1F);
   80430:	bf88      	it	hi
   80432:	f8c2 3100 	strhi.w	r3, [r2, #256]	; 0x100
   80436:	bd08      	pop	{r3, pc}
   80438:	000829eb 	.word	0x000829eb
   8043c:	00082a28 	.word	0x00082a28
   80440:	00082995 	.word	0x00082995
   80444:	00082a32 	.word	0x00082a32
   80448:	400e0600 	.word	0x400e0600

0008044c <soc_gpio_configure>:
	/* Enable control of the I/O line by the PIO_ODSR register */
	pio->PIO_OWER = mask;
}

void soc_gpio_configure(const struct soc_gpio_pin *pin)
{
   8044c:	4603      	mov	r3, r0
   8044e:	b570      	push	{r4, r5, r6, lr}
	u32_t mask = pin->mask;
	Pio *pio = pin->regs;
	u8_t periph_id = pin->periph_id;
	u32_t flags = pin->flags;
   80450:	68de      	ldr	r6, [r3, #12]
	u32_t mask = pin->mask;
   80452:	6805      	ldr	r5, [r0, #0]
	Pio *pio = pin->regs;
   80454:	6844      	ldr	r4, [r0, #4]
	if (flags & SOC_GPIO_PULLUP) {
   80456:	07f2      	lsls	r2, r6, #31
	u8_t periph_id = pin->periph_id;
   80458:	7a00      	ldrb	r0, [r0, #8]
	u32_t type = pin->flags & SOC_GPIO_FUNC_MASK;
   8045a:	f406 23e0 	and.w	r3, r6, #458752	; 0x70000
	pio->PIO_IDR = mask;
   8045e:	6465      	str	r5, [r4, #68]	; 0x44
		pio->PIO_PUER = mask;
   80460:	bf4c      	ite	mi
   80462:	6665      	strmi	r5, [r4, #100]	; 0x64
		pio->PIO_PUDR = mask;
   80464:	6625      	strpl	r5, [r4, #96]	; 0x60
	if (flags & SOC_GPIO_OPENDRAIN) {
   80466:	0771      	lsls	r1, r6, #29
		pio->PIO_MDER = mask;
   80468:	bf4c      	ite	mi
   8046a:	6525      	strmi	r5, [r4, #80]	; 0x50
		pio->PIO_MDDR = mask;
   8046c:	6565      	strpl	r5, [r4, #84]	; 0x54

	/* Configure pin attributes common to all functions */
	configure_common_attr(pio, mask, flags);

	switch (type) {
   8046e:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
   80472:	d01f      	beq.n	804b4 <soc_gpio_configure+0x68>
   80474:	d80d      	bhi.n	80492 <soc_gpio_configure+0x46>
   80476:	b1a3      	cbz	r3, 804a2 <soc_gpio_configure+0x56>
   80478:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   8047c:	d017      	beq.n	804ae <soc_gpio_configure+0x62>
		pio->PIO_OER = mask;
		pio->PIO_PER = mask;
		break;

	default:
		__ASSERT(0, "Unsupported pin function, check pin.flags value");
   8047e:	23c1      	movs	r3, #193	; 0xc1
   80480:	4a23      	ldr	r2, [pc, #140]	; (80510 <soc_gpio_configure+0xc4>)
   80482:	4924      	ldr	r1, [pc, #144]	; (80514 <soc_gpio_configure+0xc8>)
   80484:	4824      	ldr	r0, [pc, #144]	; (80518 <soc_gpio_configure+0xcc>)
   80486:	f000 fbad 	bl	80be4 <printk>
   8048a:	4824      	ldr	r0, [pc, #144]	; (8051c <soc_gpio_configure+0xd0>)
   8048c:	f000 fbaa 	bl	80be4 <printk>
   80490:	e7fe      	b.n	80490 <soc_gpio_configure+0x44>
	switch (type) {
   80492:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
   80496:	d036      	beq.n	80506 <soc_gpio_configure+0xba>
   80498:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
   8049c:	d1ef      	bne.n	8047e <soc_gpio_configure+0x32>
			pio->PIO_SODR = mask;
   8049e:	6325      	str	r5, [r4, #48]	; 0x30
   804a0:	e032      	b.n	80508 <soc_gpio_configure+0xbc>
		pio->PIO_ABSR &= ~mask;
   804a2:	6f23      	ldr	r3, [r4, #112]	; 0x70
   804a4:	ea23 0305 	bic.w	r3, r3, r5
		pio->PIO_ABSR |= mask;
   804a8:	6723      	str	r3, [r4, #112]	; 0x70
		pio->PIO_PDR = mask;
   804aa:	6065      	str	r5, [r4, #4]
		break;
   804ac:	bd70      	pop	{r4, r5, r6, pc}
		pio->PIO_ABSR |= mask;
   804ae:	6f23      	ldr	r3, [r4, #112]	; 0x70
   804b0:	432b      	orrs	r3, r5
   804b2:	e7f9      	b.n	804a8 <soc_gpio_configure+0x5c>
		soc_pmc_peripheral_enable(periph_id);
   804b4:	f7ff ffa6 	bl	80404 <soc_pmc_peripheral_enable>
	if ((flags & SOC_GPIO_IN_FILTER_MASK) != 0) {
   804b8:	f016 0318 	ands.w	r3, r6, #24
   804bc:	d012      	beq.n	804e4 <soc_gpio_configure+0x98>
		if ((flags & SOC_GPIO_IN_FILTER_MASK) == SOC_GPIO_IN_FILTER_DEBOUNCE) {
   804be:	2b08      	cmp	r3, #8
			pio->PIO_DIFSR = mask;
   804c0:	bf0c      	ite	eq
   804c2:	f8c4 5084 	streq.w	r5, [r4, #132]	; 0x84
			pio->PIO_SCIFSR = mask;
   804c6:	f8c4 5080 	strne.w	r5, [r4, #128]	; 0x80
		pio->PIO_IFER = mask;
   804ca:	6225      	str	r5, [r4, #32]
	if (flags & SOC_GPIO_INT_ENABLE) {
   804cc:	06b2      	lsls	r2, r6, #26
   804ce:	d506      	bpl.n	804de <soc_gpio_configure+0x92>
		if ((flags & SOC_GPIO_INT_TRIG_MASK) == SOC_GPIO_INT_TRIG_DOUBLE_EDGE) {
   804d0:	f006 03c0 	and.w	r3, r6, #192	; 0xc0
   804d4:	2b80      	cmp	r3, #128	; 0x80
   804d6:	d107      	bne.n	804e8 <soc_gpio_configure+0x9c>
			pio->PIO_AIMDR = mask;
   804d8:	f8c4 50b4 	str.w	r5, [r4, #180]	; 0xb4
		pio->PIO_IER = mask;
   804dc:	6425      	str	r5, [r4, #64]	; 0x40
		pio->PIO_ODR = mask;
   804de:	6165      	str	r5, [r4, #20]
		pio->PIO_PER = mask;
   804e0:	6025      	str	r5, [r4, #0]
		break;
   804e2:	bd70      	pop	{r4, r5, r6, pc}
		pio->PIO_IFDR = mask;
   804e4:	6265      	str	r5, [r4, #36]	; 0x24
   804e6:	e7f1      	b.n	804cc <soc_gpio_configure+0x80>
			if ((flags & SOC_GPIO_INT_TRIG_MASK) == SOC_GPIO_INT_TRIG_EDGE) {
   804e8:	2b40      	cmp	r3, #64	; 0x40
				pio->PIO_ESR = mask;
   804ea:	bf0c      	ite	eq
   804ec:	f8c4 50c0 	streq.w	r5, [r4, #192]	; 0xc0
				pio->PIO_LSR = mask;
   804f0:	f8c4 50c4 	strne.w	r5, [r4, #196]	; 0xc4
			if (flags & SOC_GPIO_INT_ACTIVE_HIGH) {
   804f4:	05f3      	lsls	r3, r6, #23
				pio->PIO_REHLSR = mask;
   804f6:	bf4c      	ite	mi
   804f8:	f8c4 50d4 	strmi.w	r5, [r4, #212]	; 0xd4
				pio->PIO_FELLSR = mask;
   804fc:	f8c4 50d0 	strpl.w	r5, [r4, #208]	; 0xd0
			pio->PIO_AIMER = mask;
   80500:	f8c4 50b0 	str.w	r5, [r4, #176]	; 0xb0
   80504:	e7ea      	b.n	804dc <soc_gpio_configure+0x90>
			pio->PIO_CODR = mask;
   80506:	6365      	str	r5, [r4, #52]	; 0x34
	pio->PIO_OWER = mask;
   80508:	f8c4 50a0 	str.w	r5, [r4, #160]	; 0xa0
		pio->PIO_OER = mask;
   8050c:	6125      	str	r5, [r4, #16]
   8050e:	e7e7      	b.n	804e0 <soc_gpio_configure+0x94>
   80510:	00082a48 	.word	0x00082a48
   80514:	000834a1 	.word	0x000834a1
   80518:	00082995 	.word	0x00082995
   8051c:	00082a86 	.word	0x00082a86

00080520 <_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void _thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   80520:	b508      	push	{r3, lr}
   80522:	4604      	mov	r4, r0
   80524:	4608      	mov	r0, r1
   80526:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   80528:	461a      	mov	r2, r3
   8052a:	47a0      	blx	r4
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t);
   8052c:	f001 ff74 	bl	82418 <_impl_k_current_get>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread);
   80530:	f000 fe8e 	bl	81250 <_impl_k_thread_abort>

00080534 <get_bit_ptr>:
/* Places a 32 bit output pointer in word, and an integer bit index
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
   80534:	b510      	push	{r4, lr}
	u32_t *bitarray = level <= p->max_inline_level ?
   80536:	7ac4      	ldrb	r4, [r0, #11]
   80538:	68c0      	ldr	r0, [r0, #12]
		&p->levels[level].bits : p->levels[level].bits_p;
   8053a:	428c      	cmp	r4, r1
   8053c:	f04f 040c 	mov.w	r4, #12
   80540:	bfac      	ite	ge
   80542:	fb04 0101 	mlage	r1, r4, r1, r0
   80546:	4361      	mullt	r1, r4

	*word = &bitarray[bn / 32];
   80548:	f04f 0420 	mov.w	r4, #32
   8054c:	fb92 f4f4 	sdiv	r4, r2, r4
		&p->levels[level].bits : p->levels[level].bits_p;
   80550:	bfb8      	it	lt
   80552:	5841      	ldrlt	r1, [r0, r1]

	return bn & 0x1f;
}
   80554:	f002 001f 	and.w	r0, r2, #31
	*word = &bitarray[bn / 32];
   80558:	eb01 0184 	add.w	r1, r1, r4, lsl #2
   8055c:	6019      	str	r1, [r3, #0]
}
   8055e:	bd10      	pop	{r4, pc}

00080560 <set_free_bit>:

static void set_free_bit(struct sys_mem_pool_base *p, int level, int bn)
{
   80560:	b507      	push	{r0, r1, r2, lr}
	u32_t *word;
	int bit = get_bit_ptr(p, level, bn, &word);
   80562:	ab01      	add	r3, sp, #4
   80564:	f7ff ffe6 	bl	80534 <get_bit_ptr>

	*word |= (1<<bit);
   80568:	2301      	movs	r3, #1
   8056a:	9a01      	ldr	r2, [sp, #4]
   8056c:	fa03 f000 	lsl.w	r0, r3, r0
   80570:	6813      	ldr	r3, [r2, #0]
   80572:	4303      	orrs	r3, r0
   80574:	6013      	str	r3, [r2, #0]
}
   80576:	b003      	add	sp, #12
   80578:	f85d fb04 	ldr.w	pc, [sp], #4

0008057c <clear_free_bit>:

static void clear_free_bit(struct sys_mem_pool_base *p, int level, int bn)
{
   8057c:	b507      	push	{r0, r1, r2, lr}
	u32_t *word;
	int bit = get_bit_ptr(p, level, bn, &word);
   8057e:	ab01      	add	r3, sp, #4
   80580:	f7ff ffd8 	bl	80534 <get_bit_ptr>

	*word &= ~(1<<bit);
   80584:	2301      	movs	r3, #1
   80586:	9a01      	ldr	r2, [sp, #4]
   80588:	fa03 f000 	lsl.w	r0, r3, r0
   8058c:	6813      	ldr	r3, [r2, #0]
   8058e:	ea23 0300 	bic.w	r3, r3, r0
   80592:	6013      	str	r3, [r2, #0]
}
   80594:	b003      	add	sp, #12
   80596:	f85d fb04 	ldr.w	pc, [sp], #4

0008059a <_sys_mem_pool_base_init>:
{
	return (block + bsz - 1 - p->buf) < buf_size(p);
}

void _sys_mem_pool_base_init(struct sys_mem_pool_base *p)
{
   8059a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   8059e:	4604      	mov	r4, r0
	int i;
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
	u32_t *bits = p->buf + buflen;

	for (i = 0; i < p->n_levels; i++) {
   805a0:	2100      	movs	r1, #0
		int nblocks = buflen / sz;

		sys_dlist_init(&p->levels[i].free_list);
   805a2:	f04f 0e0c 	mov.w	lr, #12

		if (nblocks < 32) {
			p->max_inline_level = i;
		} else {
			p->levels[i].bits_p = bits;
			bits += (nblocks + 31)/32;
   805a6:	f04f 0c20 	mov.w	ip, #32
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   805aa:	6843      	ldr	r3, [r0, #4]
   805ac:	8905      	ldrh	r5, [r0, #8]
	u32_t *bits = p->buf + buflen;
   805ae:	6800      	ldr	r0, [r0, #0]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   805b0:	435d      	muls	r5, r3
	for (i = 0; i < p->n_levels; i++) {
   805b2:	7aa7      	ldrb	r7, [r4, #10]
	u32_t *bits = p->buf + buflen;
   805b4:	4428      	add	r0, r5
	for (i = 0; i < p->n_levels; i++) {
   805b6:	42b9      	cmp	r1, r7
   805b8:	db05      	blt.n	805c6 <_sys_mem_pool_base_init+0x2c>
   805ba:	2500      	movs	r5, #0
		}

		sz = _ALIGN4(sz / 4);
	}

	for (i = 0; i < p->n_max; i++) {
   805bc:	8923      	ldrh	r3, [r4, #8]
   805be:	429d      	cmp	r5, r3
   805c0:	db24      	blt.n	8060c <_sys_mem_pool_base_init+0x72>
		void *block = block_ptr(p, p->max_sz, i);

		sys_dlist_append(&p->levels[0].free_list, block);
		set_free_bit(p, 0, i);
	}
}
   805c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		int nblocks = buflen / sz;
   805c6:	fbb5 f2f3 	udiv	r2, r5, r3
		if (nblocks < 32) {
   805ca:	2a1f      	cmp	r2, #31
			bits += (nblocks + 31)/32;
   805cc:	bfc4      	itt	gt
   805ce:	321f      	addgt	r2, #31
   805d0:	fb92 f2fc 	sdivgt	r2, r2, ip
		sys_dlist_init(&p->levels[i].free_list);
   805d4:	fb0e f801 	mul.w	r8, lr, r1
   805d8:	f8d4 900c 	ldr.w	r9, [r4, #12]
		sz = _ALIGN4(sz / 4);
   805dc:	ea4f 0393 	mov.w	r3, r3, lsr #2
		sys_dlist_init(&p->levels[i].free_list);
   805e0:	eb09 0608 	add.w	r6, r9, r8
   805e4:	f106 0a04 	add.w	sl, r6, #4
		sz = _ALIGN4(sz / 4);
   805e8:	f103 0303 	add.w	r3, r3, #3
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
   805ec:	f8c6 a004 	str.w	sl, [r6, #4]
	list->tail = (sys_dnode_t *)list;
   805f0:	f8c6 a008 	str.w	sl, [r6, #8]
   805f4:	f023 0303 	bic.w	r3, r3, #3
			p->max_inline_level = i;
   805f8:	bfd4      	ite	le
   805fa:	72e1      	strble	r1, [r4, #11]
			p->levels[i].bits_p = bits;
   805fc:	f849 0008 	strgt.w	r0, [r9, r8]
	for (i = 0; i < p->n_levels; i++) {
   80600:	f101 0101 	add.w	r1, r1, #1
			bits += (nblocks + 31)/32;
   80604:	bfc8      	it	gt
   80606:	eb00 0082 	addgt.w	r0, r0, r2, lsl #2
   8060a:	e7d4      	b.n	805b6 <_sys_mem_pool_base_init+0x1c>
	return p->buf + lsz * block;
   8060c:	6862      	ldr	r2, [r4, #4]
		sys_dlist_append(&p->levels[0].free_list, block);
   8060e:	68e3      	ldr	r3, [r4, #12]
	return p->buf + lsz * block;
   80610:	436a      	muls	r2, r5
   80612:	6820      	ldr	r0, [r4, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
   80614:	1d1e      	adds	r6, r3, #4
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
   80616:	5086      	str	r6, [r0, r2]
	return p->buf + lsz * block;
   80618:	1881      	adds	r1, r0, r2
	node->prev = list->tail;
   8061a:	689a      	ldr	r2, [r3, #8]
		set_free_bit(p, 0, i);
   8061c:	4620      	mov	r0, r4
   8061e:	604a      	str	r2, [r1, #4]

	list->tail->next = node;
   80620:	689a      	ldr	r2, [r3, #8]
   80622:	6011      	str	r1, [r2, #0]
	list->tail = node;
   80624:	6099      	str	r1, [r3, #8]
   80626:	462a      	mov	r2, r5
   80628:	2100      	movs	r1, #0
   8062a:	f7ff ff99 	bl	80560 <set_free_bit>
	for (i = 0; i < p->n_max; i++) {
   8062e:	3501      	adds	r5, #1
   80630:	e7c4      	b.n	805bc <_sys_mem_pool_base_init+0x22>

00080632 <_sys_mem_pool_block_alloc>:
	return block;
}

int _sys_mem_pool_block_alloc(struct sys_mem_pool_base *p, size_t size,
			      u32_t *level_p, u32_t *block_p, void **data_p)
{
   80632:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   80636:	b08b      	sub	sp, #44	; 0x2c
	int i, from_l;
	int alloc_l = -1, free_l = -1;
	void *data;
	size_t lsizes[p->n_levels];
   80638:	7a86      	ldrb	r6, [r0, #10]
{
   8063a:	af00      	add	r7, sp, #0
   8063c:	60fb      	str	r3, [r7, #12]
	size_t lsizes[p->n_levels];
   8063e:	00b3      	lsls	r3, r6, #2
   80640:	330a      	adds	r3, #10
   80642:	f023 0307 	bic.w	r3, r3, #7
   80646:	ebad 0d03 	sub.w	sp, sp, r3
{
   8064a:	613a      	str	r2, [r7, #16]
	 * want to allocate and the smallest one with a free entry
	 * from which we can split an allocation if needed.  Along the
	 * way, we populate an array of sizes for each level so we
	 * don't need to waste RAM storing it.
	 */
	lsizes[0] = _ALIGN4(p->max_sz);
   8064c:	466a      	mov	r2, sp
   8064e:	6843      	ldr	r3, [r0, #4]
{
   80650:	4604      	mov	r4, r0
	lsizes[0] = _ALIGN4(p->max_sz);
   80652:	3303      	adds	r3, #3
   80654:	f023 0303 	bic.w	r3, r3, #3
   80658:	f842 3904 	str.w	r3, [r2], #-4
	size_t lsizes[p->n_levels];
   8065c:	46e9      	mov	r9, sp
	int alloc_l = -1, free_l = -1;
   8065e:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	for (i = 0; i < p->n_levels; i++) {
   80662:	2300      	movs	r3, #0
	return sys_dlist_is_empty(&p->levels[l].free_list);
   80664:	f04f 0e0c 	mov.w	lr, #12
   80668:	1e58      	subs	r0, r3, #1
	for (i = 0; i < p->n_levels; i++) {
   8066a:	42b3      	cmp	r3, r6
   8066c:	6278      	str	r0, [r7, #36]	; 0x24
   8066e:	da09      	bge.n	80684 <_sys_mem_pool_block_alloc+0x52>
		if (i > 0) {
   80670:	b12b      	cbz	r3, 8067e <_sys_mem_pool_block_alloc+0x4c>
			lsizes[i] = _ALIGN4(lsizes[i-1] / 4);
   80672:	6810      	ldr	r0, [r2, #0]
   80674:	0880      	lsrs	r0, r0, #2
   80676:	3003      	adds	r0, #3
   80678:	f020 0003 	bic.w	r0, r0, #3
   8067c:	6050      	str	r0, [r2, #4]
		}

		if (lsizes[i] < size) {
   8067e:	6850      	ldr	r0, [r2, #4]
   80680:	4288      	cmp	r0, r1
   80682:	d20b      	bcs.n	8069c <_sys_mem_pool_block_alloc+0x6a>
		if (!level_empty(p, i)) {
			free_l = i;
		}
	}

	if (alloc_l < 0 || free_l < 0) {
   80684:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   80686:	3301      	adds	r3, #1
   80688:	d114      	bne.n	806b4 <_sys_mem_pool_block_alloc+0x82>
		*data_p = NULL;
   8068a:	2300      	movs	r3, #0
		return -ENOMEM;
   8068c:	f06f 000b 	mvn.w	r0, #11
		*data_p = NULL;
   80690:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   80692:	6013      	str	r3, [r2, #0]
	*level_p = alloc_l;
	*block_p = block_num(p, data, lsizes[alloc_l]);
	*data_p = data;

	return 0;
}
   80694:	372c      	adds	r7, #44	; 0x2c
   80696:	46bd      	mov	sp, r7
   80698:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return sys_dlist_is_empty(&p->levels[l].free_list);
   8069c:	68e0      	ldr	r0, [r4, #12]
   8069e:	3204      	adds	r2, #4
   806a0:	fb0e 0003 	mla	r0, lr, r3, r0
   806a4:	f100 0c04 	add.w	ip, r0, #4
		if (!level_empty(p, i)) {
   806a8:	6840      	ldr	r0, [r0, #4]
   806aa:	4560      	cmp	r0, ip
   806ac:	bf18      	it	ne
   806ae:	461d      	movne	r5, r3
	for (i = 0; i < p->n_levels; i++) {
   806b0:	3301      	adds	r3, #1
   806b2:	e7d9      	b.n	80668 <_sys_mem_pool_block_alloc+0x36>
	if (alloc_l < 0 || free_l < 0) {
   806b4:	1c6b      	adds	r3, r5, #1
   806b6:	d0e8      	beq.n	8068a <_sys_mem_pool_block_alloc+0x58>
	return list->head == list;
   806b8:	230c      	movs	r3, #12
	block = sys_dlist_get(&p->levels[l].free_list);
   806ba:	68e1      	ldr	r1, [r4, #12]
	data = block_alloc(p, free_l, lsizes[free_l]);
   806bc:	f859 2025 	ldr.w	r2, [r9, r5, lsl #2]
   806c0:	fb03 1305 	mla	r3, r3, r5, r1
   806c4:	f853 6f04 	ldr.w	r6, [r3, #4]!

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
   806c8:	429e      	cmp	r6, r3
   806ca:	d061      	beq.n	80790 <_sys_mem_pool_block_alloc+0x15e>
	node->prev->next = node->next;
   806cc:	e896 000a 	ldmia.w	r6, {r1, r3}
   806d0:	6019      	str	r1, [r3, #0]
	node->next->prev = node->prev;
   806d2:	6831      	ldr	r1, [r6, #0]
		clear_free_bit(p, l, block_num(p, block, lsz));
   806d4:	4620      	mov	r0, r4
   806d6:	604b      	str	r3, [r1, #4]
	return (block - p->buf) / sz;
   806d8:	6823      	ldr	r3, [r4, #0]
		clear_free_bit(p, l, block_num(p, block, lsz));
   806da:	4629      	mov	r1, r5
	return (block - p->buf) / sz;
   806dc:	1af3      	subs	r3, r6, r3
		clear_free_bit(p, l, block_num(p, block, lsz));
   806de:	fb93 f2f2 	sdiv	r2, r3, r2
   806e2:	f7ff ff4b 	bl	8057c <clear_free_bit>
   806e6:	eba9 0389 	sub.w	r3, r9, r9, lsl #2
   806ea:	eb09 0a85 	add.w	sl, r9, r5, lsl #2
   806ee:	61bb      	str	r3, [r7, #24]
	for (from_l = free_l; from_l < alloc_l; from_l++) {
   806f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   806f2:	429d      	cmp	r5, r3
   806f4:	6823      	ldr	r3, [r4, #0]
   806f6:	db0e      	blt.n	80716 <_sys_mem_pool_block_alloc+0xe4>
	*level_p = alloc_l;
   806f8:	693a      	ldr	r2, [r7, #16]
	return (block - p->buf) / sz;
   806fa:	1af3      	subs	r3, r6, r3
	*level_p = alloc_l;
   806fc:	4611      	mov	r1, r2
   806fe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
	return 0;
   80700:	2000      	movs	r0, #0
	*level_p = alloc_l;
   80702:	600a      	str	r2, [r1, #0]
	return (block - p->buf) / sz;
   80704:	f859 2022 	ldr.w	r2, [r9, r2, lsl #2]
   80708:	fb93 f3f2 	sdiv	r3, r3, r2
	*block_p = block_num(p, data, lsizes[alloc_l]);
   8070c:	68fa      	ldr	r2, [r7, #12]
   8070e:	6013      	str	r3, [r2, #0]
	*data_p = data;
   80710:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   80712:	601e      	str	r6, [r3, #0]
	return 0;
   80714:	e7be      	b.n	80694 <_sys_mem_pool_block_alloc+0x62>
	bn = block_num(p, block, lsizes[l]);
   80716:	f85a 2b04 	ldr.w	r2, [sl], #4
	return (block - p->buf) / sz;
   8071a:	1af3      	subs	r3, r6, r3
   8071c:	fb93 f3f2 	sdiv	r3, r3, r2
	for (i = 1; i < 4; i++) {
   80720:	f04f 0b01 	mov.w	fp, #1
		int lbn = 4*bn + i;
   80724:	009b      	lsls	r3, r3, #2
   80726:	69ba      	ldr	r2, [r7, #24]
   80728:	617b      	str	r3, [r7, #20]
   8072a:	eb0a 034a 	add.w	r3, sl, sl, lsl #1
   8072e:	4413      	add	r3, r2
   80730:	61fb      	str	r3, [r7, #28]
		set_free_bit(p, l + 1, lbn);
   80732:	eb05 030b 	add.w	r3, r5, fp
   80736:	60bb      	str	r3, [r7, #8]
		int lsz = lsizes[l + 1];
   80738:	f8da 8000 	ldr.w	r8, [sl]
		set_free_bit(p, l + 1, lbn);
   8073c:	68b9      	ldr	r1, [r7, #8]
		void *block2 = (lsz * i) + (char *)block;
   8073e:	fb0b f308 	mul.w	r3, fp, r8
   80742:	623b      	str	r3, [r7, #32]
   80744:	18f3      	adds	r3, r6, r3
   80746:	607b      	str	r3, [r7, #4]
		set_free_bit(p, l + 1, lbn);
   80748:	697b      	ldr	r3, [r7, #20]
   8074a:	4620      	mov	r0, r4
   8074c:	eb0b 0203 	add.w	r2, fp, r3
   80750:	f7ff ff06 	bl	80560 <set_free_bit>
	return (block + bsz - 1 - p->buf) < buf_size(p);
   80754:	687b      	ldr	r3, [r7, #4]
   80756:	6822      	ldr	r2, [r4, #0]
   80758:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   8075c:	4498      	add	r8, r3
   8075e:	eba8 0802 	sub.w	r8, r8, r2
	return p->n_max * p->max_sz;
   80762:	8921      	ldrh	r1, [r4, #8]
   80764:	6862      	ldr	r2, [r4, #4]
   80766:	434a      	muls	r2, r1
		if (block_fits(p, block2, lsz)) {
   80768:	4590      	cmp	r8, r2
   8076a:	d20a      	bcs.n	80782 <_sys_mem_pool_block_alloc+0x150>
			sys_dlist_append(&p->levels[l + 1].free_list, block2);
   8076c:	68e2      	ldr	r2, [r4, #12]
   8076e:	69f9      	ldr	r1, [r7, #28]
	node->next = list;
   80770:	6a38      	ldr	r0, [r7, #32]
   80772:	440a      	add	r2, r1
   80774:	1d11      	adds	r1, r2, #4
   80776:	5031      	str	r1, [r6, r0]
	node->prev = list->tail;
   80778:	6891      	ldr	r1, [r2, #8]
   8077a:	6059      	str	r1, [r3, #4]
	list->tail->next = node;
   8077c:	6891      	ldr	r1, [r2, #8]
   8077e:	600b      	str	r3, [r1, #0]
	list->tail = node;
   80780:	6093      	str	r3, [r2, #8]
	for (i = 1; i < 4; i++) {
   80782:	f10b 0b01 	add.w	fp, fp, #1
   80786:	f1bb 0f04 	cmp.w	fp, #4
   8078a:	d1d5      	bne.n	80738 <_sys_mem_pool_block_alloc+0x106>
   8078c:	3501      	adds	r5, #1
   8078e:	e7af      	b.n	806f0 <_sys_mem_pool_block_alloc+0xbe>
		return -EAGAIN;
   80790:	f06f 000a 	mvn.w	r0, #10
   80794:	e77e      	b.n	80694 <_sys_mem_pool_block_alloc+0x62>

00080796 <_sys_mem_pool_block_free>:

void _sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
   80796:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   8079a:	b085      	sub	sp, #20
	size_t lsizes[p->n_levels];
   8079c:	7a83      	ldrb	r3, [r0, #10]
{
   8079e:	af00      	add	r7, sp, #0
	size_t lsizes[p->n_levels];
   807a0:	009b      	lsls	r3, r3, #2
   807a2:	330a      	adds	r3, #10
   807a4:	f023 0307 	bic.w	r3, r3, #7
   807a8:	ebad 0d03 	sub.w	sp, sp, r3
{
   807ac:	4605      	mov	r5, r0
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = _ALIGN4(p->max_sz);
   807ae:	6843      	ldr	r3, [r0, #4]
	size_t lsizes[p->n_levels];
   807b0:	46ea      	mov	sl, sp
   807b2:	466c      	mov	r4, sp
	for (i = 1; i <= level; i++) {
   807b4:	2001      	movs	r0, #1
	lsizes[0] = _ALIGN4(p->max_sz);
   807b6:	3303      	adds	r3, #3
   807b8:	f023 0303 	bic.w	r3, r3, #3
   807bc:	9300      	str	r3, [sp, #0]
	for (i = 1; i <= level; i++) {
   807be:	4281      	cmp	r1, r0
   807c0:	d24c      	bcs.n	8085c <_sys_mem_pool_block_free+0xc6>
		lsizes[i] = _ALIGN4(lsizes[i-1] / 4);
	}

	block_free(p, level, lsizes, block);
   807c2:	460c      	mov	r4, r1
   807c4:	4616      	mov	r6, r2
	set_free_bit(p, level, bn);
   807c6:	4632      	mov	r2, r6
   807c8:	4621      	mov	r1, r4
   807ca:	4628      	mov	r0, r5
	int i, key, lsz = lsizes[level];
   807cc:	f85a 8024 	ldr.w	r8, [sl, r4, lsl #2]
   807d0:	f8d5 9000 	ldr.w	r9, [r5]
	set_free_bit(p, level, bn);
   807d4:	f7ff fec4 	bl	80560 <set_free_bit>
	if (level && partner_bits(p, level, bn) == 0xf) {
   807d8:	2c00      	cmp	r4, #0
   807da:	d048      	beq.n	8086e <_sys_mem_pool_block_free+0xd8>
	int bit = get_bit_ptr(p, level, bn, &word);
   807dc:	f107 030c 	add.w	r3, r7, #12
   807e0:	4632      	mov	r2, r6
   807e2:	4621      	mov	r1, r4
   807e4:	4628      	mov	r0, r5
   807e6:	f7ff fea5 	bl	80534 <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
   807ea:	2304      	movs	r3, #4
   807ec:	fb90 f0f3 	sdiv	r0, r0, r3
   807f0:	68fa      	ldr	r2, [r7, #12]
   807f2:	0083      	lsls	r3, r0, #2
   807f4:	6810      	ldr	r0, [r2, #0]
   807f6:	40d8      	lsrs	r0, r3
   807f8:	f000 000f 	and.w	r0, r0, #15
	if (level && partner_bits(p, level, bn) == 0xf) {
   807fc:	280f      	cmp	r0, #15
   807fe:	d136      	bne.n	8086e <_sys_mem_pool_block_free+0xd8>
   80800:	f04f 0900 	mov.w	r9, #0
			int b = (bn & ~3) + i;
   80804:	f026 0303 	bic.w	r3, r6, #3
   80808:	607b      	str	r3, [r7, #4]
	return (block + bsz - 1 - p->buf) < buf_size(p);
   8080a:	f108 3bff 	add.w	fp, r8, #4294967295	; 0xffffffff
			int b = (bn & ~3) + i;
   8080e:	687b      	ldr	r3, [r7, #4]
			clear_free_bit(p, level, b);
   80810:	4621      	mov	r1, r4
			int b = (bn & ~3) + i;
   80812:	444b      	add	r3, r9
			clear_free_bit(p, level, b);
   80814:	461a      	mov	r2, r3
   80816:	4628      	mov	r0, r5
   80818:	603b      	str	r3, [r7, #0]
   8081a:	f7ff feaf 	bl	8057c <clear_free_bit>
			if (b != bn &&
   8081e:	683b      	ldr	r3, [r7, #0]
   80820:	429e      	cmp	r6, r3
   80822:	d012      	beq.n	8084a <_sys_mem_pool_block_free+0xb4>
	return p->buf + lsz * block;
   80824:	fb08 f203 	mul.w	r2, r8, r3
	return p->n_max * p->max_sz;
   80828:	f8b5 c008 	ldrh.w	ip, [r5, #8]
   8082c:	686b      	ldr	r3, [r5, #4]
   8082e:	6829      	ldr	r1, [r5, #0]
   80830:	fb03 f30c 	mul.w	r3, r3, ip
	return (block + bsz - 1 - p->buf) < buf_size(p);
   80834:	eb02 0e0b 	add.w	lr, r2, fp
			if (b != bn &&
   80838:	459e      	cmp	lr, r3
	return (block + bsz - 1 - p->buf) < buf_size(p);
   8083a:	eb01 0002 	add.w	r0, r1, r2
			if (b != bn &&
   8083e:	d204      	bcs.n	8084a <_sys_mem_pool_block_free+0xb4>
	node->prev->next = node->next;
   80840:	588b      	ldr	r3, [r1, r2]
   80842:	6840      	ldr	r0, [r0, #4]
   80844:	6003      	str	r3, [r0, #0]
	node->next->prev = node->prev;
   80846:	588b      	ldr	r3, [r1, r2]
   80848:	6058      	str	r0, [r3, #4]
		for (i = 0; i < 4; i++) {
   8084a:	f109 0901 	add.w	r9, r9, #1
   8084e:	f1b9 0f04 	cmp.w	r9, #4
   80852:	d1dc      	bne.n	8080e <_sys_mem_pool_block_free+0x78>
		block_free(p, level-1, lsizes, bn / 4);
   80854:	3c01      	subs	r4, #1
   80856:	fb96 f6f9 	sdiv	r6, r6, r9
   8085a:	e7b4      	b.n	807c6 <_sys_mem_pool_block_free+0x30>
		lsizes[i] = _ALIGN4(lsizes[i-1] / 4);
   8085c:	6823      	ldr	r3, [r4, #0]
	for (i = 1; i <= level; i++) {
   8085e:	3001      	adds	r0, #1
		lsizes[i] = _ALIGN4(lsizes[i-1] / 4);
   80860:	089b      	lsrs	r3, r3, #2
   80862:	3303      	adds	r3, #3
   80864:	f023 0303 	bic.w	r3, r3, #3
   80868:	f844 3f04 	str.w	r3, [r4, #4]!
   8086c:	e7a7      	b.n	807be <_sys_mem_pool_block_free+0x28>
	return p->buf + lsz * block;
   8086e:	fb08 f606 	mul.w	r6, r8, r6
	return (block + bsz - 1 - p->buf) < buf_size(p);
   80872:	682a      	ldr	r2, [r5, #0]
	return p->buf + lsz * block;
   80874:	eb09 0306 	add.w	r3, r9, r6
	return (block + bsz - 1 - p->buf) < buf_size(p);
   80878:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   8087c:	4498      	add	r8, r3
   8087e:	eba8 0802 	sub.w	r8, r8, r2
	return p->n_max * p->max_sz;
   80882:	6869      	ldr	r1, [r5, #4]
   80884:	892a      	ldrh	r2, [r5, #8]
   80886:	4351      	muls	r1, r2
	if (block_fits(p, block, lsz)) {
   80888:	4588      	cmp	r8, r1
   8088a:	d20b      	bcs.n	808a4 <_sys_mem_pool_block_free+0x10e>
		sys_dlist_append(&p->levels[level].free_list, block);
   8088c:	220c      	movs	r2, #12
   8088e:	68e9      	ldr	r1, [r5, #12]
   80890:	fb02 1404 	mla	r4, r2, r4, r1
   80894:	1d22      	adds	r2, r4, #4
	node->next = list;
   80896:	f849 2006 	str.w	r2, [r9, r6]
	node->prev = list->tail;
   8089a:	68a2      	ldr	r2, [r4, #8]
   8089c:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
   8089e:	68a2      	ldr	r2, [r4, #8]
   808a0:	6013      	str	r3, [r2, #0]
	list->tail = node;
   808a2:	60a3      	str	r3, [r4, #8]
}
   808a4:	3714      	adds	r7, #20
   808a6:	46bd      	mov	sp, r7
   808a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000808ac <_nop_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
   808ac:	2000      	movs	r0, #0
   808ae:	4770      	bx	lr

000808b0 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
   808b0:	680b      	ldr	r3, [r1, #0]
   808b2:	3301      	adds	r3, #1
   808b4:	600b      	str	r3, [r1, #0]
	return _char_out(c);
   808b6:	4b01      	ldr	r3, [pc, #4]	; (808bc <char_out+0xc>)
   808b8:	681b      	ldr	r3, [r3, #0]
   808ba:	4718      	bx	r3
   808bc:	20071c88 	.word	0x20071c88

000808c0 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
   808c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   808c4:	b085      	sub	sp, #20
   808c6:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   808c8:	469b      	mov	fp, r3
   808ca:	2c01      	cmp	r4, #1
   808cc:	bfb8      	it	lt
   808ce:	2401      	movlt	r4, #1
   808d0:	2b01      	cmp	r3, #1
   808d2:	bf0c      	ite	eq
   808d4:	2330      	moveq	r3, #48	; 0x30
   808d6:	2320      	movne	r3, #32
   808d8:	4615      	mov	r5, r2
   808da:	4680      	mov	r8, r0
   808dc:	4689      	mov	r9, r1
   808de:	2601      	movs	r6, #1
   808e0:	270a      	movs	r7, #10
   808e2:	2200      	movs	r2, #0
   808e4:	f8df a070 	ldr.w	sl, [pc, #112]	; 80958 <_printk_dec_ulong+0x98>
   808e8:	9401      	str	r4, [sp, #4]
   808ea:	9302      	str	r3, [sp, #8]
   808ec:	f10a 0401 	add.w	r4, sl, #1
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
   808f0:	b90a      	cbnz	r2, 808f6 <_printk_dec_ulong+0x36>
   808f2:	45aa      	cmp	sl, r5
   808f4:	d21e      	bcs.n	80934 <_printk_dec_ulong+0x74>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
   808f6:	fbb5 f0f4 	udiv	r0, r5, r4
   808fa:	4649      	mov	r1, r9
   808fc:	3030      	adds	r0, #48	; 0x30
   808fe:	47c0      	blx	r8
			found_largest_digit = 1;
   80900:	2201      	movs	r2, #1
			digits++;
   80902:	3601      	adds	r6, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= (pos + 1);
   80904:	fbb5 f1f4 	udiv	r1, r5, r4
		pos /= 10;
   80908:	230a      	movs	r3, #10
		remaining--;
   8090a:	3f01      	subs	r7, #1
	while (pos >= 9) {
   8090c:	2f01      	cmp	r7, #1
		remainder %= (pos + 1);
   8090e:	fb04 5511 	mls	r5, r4, r1, r5
		pos /= 10;
   80912:	fbba faf3 	udiv	sl, sl, r3
	while (pos >= 9) {
   80916:	d1e9      	bne.n	808ec <_printk_dec_ulong+0x2c>
	}
	out((int)(remainder + 48), ctx);
   80918:	4649      	mov	r1, r9
   8091a:	f105 0030 	add.w	r0, r5, #48	; 0x30
   8091e:	47c0      	blx	r8

	if (padding == PAD_SPACE_AFTER) {
   80920:	f1bb 0f03 	cmp.w	fp, #3
   80924:	d103      	bne.n	8092e <_printk_dec_ulong+0x6e>
		remaining = min_width - digits;
   80926:	9b01      	ldr	r3, [sp, #4]
   80928:	1b9c      	subs	r4, r3, r6
		while (remaining-- > 0) {
   8092a:	2c00      	cmp	r4, #0
   8092c:	dc0f      	bgt.n	8094e <_printk_dec_ulong+0x8e>
			out(' ', ctx);
		}
	}
}
   8092e:	b005      	add	sp, #20
   80930:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
   80934:	9b01      	ldr	r3, [sp, #4]
   80936:	42bb      	cmp	r3, r7
   80938:	dbe4      	blt.n	80904 <_printk_dec_ulong+0x44>
				&& padding < PAD_SPACE_AFTER) {
   8093a:	f1bb 0f02 	cmp.w	fp, #2
   8093e:	d8e1      	bhi.n	80904 <_printk_dec_ulong+0x44>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
   80940:	4649      	mov	r1, r9
   80942:	9802      	ldr	r0, [sp, #8]
   80944:	9203      	str	r2, [sp, #12]
			digits++;
   80946:	3601      	adds	r6, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
   80948:	47c0      	blx	r8
			digits++;
   8094a:	9a03      	ldr	r2, [sp, #12]
   8094c:	e7da      	b.n	80904 <_printk_dec_ulong+0x44>
			out(' ', ctx);
   8094e:	4649      	mov	r1, r9
   80950:	2020      	movs	r0, #32
   80952:	47c0      	blx	r8
   80954:	3c01      	subs	r4, #1
   80956:	e7e8      	b.n	8092a <_printk_dec_ulong+0x6a>
   80958:	3b9ac9ff 	.word	0x3b9ac9ff

0008095c <__printk_hook_install>:
	_char_out = fn;
   8095c:	4b01      	ldr	r3, [pc, #4]	; (80964 <__printk_hook_install+0x8>)
   8095e:	6018      	str	r0, [r3, #0]
   80960:	4770      	bx	lr
   80962:	bf00      	nop
   80964:	20071c88 	.word	0x20071c88

00080968 <_vprintk>:
{
   80968:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int long_ctr = 0;
   8096c:	f04f 0a00 	mov.w	sl, #0
{
   80970:	4606      	mov	r6, r0
   80972:	460f      	mov	r7, r1
   80974:	461c      	mov	r4, r3
	int min_width = -1;
   80976:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	enum pad_type padding = PAD_NONE;
   8097a:	46d0      	mov	r8, sl
	int might_format = 0; /* 1 if encountered a '%' */
   8097c:	4655      	mov	r5, sl
{
   8097e:	b089      	sub	sp, #36	; 0x24
   80980:	9204      	str	r2, [sp, #16]
	while (*fmt) {
   80982:	9b04      	ldr	r3, [sp, #16]
   80984:	7818      	ldrb	r0, [r3, #0]
   80986:	b910      	cbnz	r0, 8098e <_vprintk+0x26>
}
   80988:	b009      	add	sp, #36	; 0x24
   8098a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!might_format) {
   8098e:	b945      	cbnz	r5, 809a2 <_vprintk+0x3a>
			if (*fmt != '%') {
   80990:	2825      	cmp	r0, #37	; 0x25
   80992:	f000 810b 	beq.w	80bac <_vprintk+0x244>
				out((int)*fmt, ctx);
   80996:	4639      	mov	r1, r7
   80998:	47b0      	blx	r6
		++fmt;
   8099a:	9b04      	ldr	r3, [sp, #16]
   8099c:	3301      	adds	r3, #1
   8099e:	9304      	str	r3, [sp, #16]
   809a0:	e7ef      	b.n	80982 <_vprintk+0x1a>
			switch (*fmt) {
   809a2:	2864      	cmp	r0, #100	; 0x64
   809a4:	d061      	beq.n	80a6a <_vprintk+0x102>
   809a6:	d819      	bhi.n	809dc <_vprintk+0x74>
   809a8:	2839      	cmp	r0, #57	; 0x39
   809aa:	d80a      	bhi.n	809c2 <_vprintk+0x5a>
   809ac:	2831      	cmp	r0, #49	; 0x31
   809ae:	d250      	bcs.n	80a52 <_vprintk+0xea>
   809b0:	282d      	cmp	r0, #45	; 0x2d
   809b2:	d03c      	beq.n	80a2e <_vprintk+0xc6>
   809b4:	2830      	cmp	r0, #48	; 0x30
   809b6:	d03d      	beq.n	80a34 <_vprintk+0xcc>
   809b8:	2825      	cmp	r0, #37	; 0x25
   809ba:	d108      	bne.n	809ce <_vprintk+0x66>
				out((int)'%', ctx);
   809bc:	4639      	mov	r1, r7
				out((int)*fmt, ctx);
   809be:	47b0      	blx	r6
   809c0:	e06f      	b.n	80aa2 <_vprintk+0x13a>
			switch (*fmt) {
   809c2:	2858      	cmp	r0, #88	; 0x58
   809c4:	f000 8089 	beq.w	80ada <_vprintk+0x172>
   809c8:	2863      	cmp	r0, #99	; 0x63
   809ca:	f000 80e9 	beq.w	80ba0 <_vprintk+0x238>
				out((int)'%', ctx);
   809ce:	4639      	mov	r1, r7
   809d0:	2025      	movs	r0, #37	; 0x25
   809d2:	47b0      	blx	r6
				out((int)*fmt, ctx);
   809d4:	9b04      	ldr	r3, [sp, #16]
   809d6:	4639      	mov	r1, r7
   809d8:	7818      	ldrb	r0, [r3, #0]
   809da:	e7f0      	b.n	809be <_vprintk+0x56>
			switch (*fmt) {
   809dc:	2870      	cmp	r0, #112	; 0x70
   809de:	d072      	beq.n	80ac6 <_vprintk+0x15e>
   809e0:	d806      	bhi.n	809f0 <_vprintk+0x88>
   809e2:	2869      	cmp	r0, #105	; 0x69
   809e4:	d041      	beq.n	80a6a <_vprintk+0x102>
   809e6:	286c      	cmp	r0, #108	; 0x6c
   809e8:	d03c      	beq.n	80a64 <_vprintk+0xfc>
   809ea:	2868      	cmp	r0, #104	; 0x68
   809ec:	d0d5      	beq.n	8099a <_vprintk+0x32>
   809ee:	e7ee      	b.n	809ce <_vprintk+0x66>
   809f0:	2875      	cmp	r0, #117	; 0x75
   809f2:	d058      	beq.n	80aa6 <_vprintk+0x13e>
   809f4:	d817      	bhi.n	80a26 <_vprintk+0xbe>
   809f6:	2873      	cmp	r0, #115	; 0x73
   809f8:	d1e9      	bne.n	809ce <_vprintk+0x66>
				char *s = va_arg(ap, char *);
   809fa:	6823      	ldr	r3, [r4, #0]
   809fc:	f104 0b04 	add.w	fp, r4, #4
   80a00:	461c      	mov	r4, r3
				while (*s)
   80a02:	4625      	mov	r5, r4
   80a04:	f815 0b01 	ldrb.w	r0, [r5], #1
   80a08:	2800      	cmp	r0, #0
   80a0a:	f040 80be 	bne.w	80b8a <_vprintk+0x222>
				if (padding == PAD_SPACE_AFTER) {
   80a0e:	f1b8 0f03 	cmp.w	r8, #3
   80a12:	f040 80d4 	bne.w	80bbe <_vprintk+0x256>
					int remaining = min_width - (s - start);
   80a16:	1ae4      	subs	r4, r4, r3
   80a18:	eba9 0404 	sub.w	r4, r9, r4
					while (remaining-- > 0) {
   80a1c:	2c00      	cmp	r4, #0
   80a1e:	f300 80ba 	bgt.w	80b96 <_vprintk+0x22e>
				char *s = va_arg(ap, char *);
   80a22:	465c      	mov	r4, fp
   80a24:	e03d      	b.n	80aa2 <_vprintk+0x13a>
			switch (*fmt) {
   80a26:	2878      	cmp	r0, #120	; 0x78
   80a28:	d057      	beq.n	80ada <_vprintk+0x172>
   80a2a:	287a      	cmp	r0, #122	; 0x7a
   80a2c:	e7de      	b.n	809ec <_vprintk+0x84>
				padding = PAD_SPACE_AFTER;
   80a2e:	f04f 0803 	mov.w	r8, #3
   80a32:	e7b2      	b.n	8099a <_vprintk+0x32>
				if (min_width < 0 && padding == PAD_NONE) {
   80a34:	f1b9 0f00 	cmp.w	r9, #0
   80a38:	da0e      	bge.n	80a58 <_vprintk+0xf0>
   80a3a:	f1b8 0f00 	cmp.w	r8, #0
   80a3e:	f000 80bb 	beq.w	80bb8 <_vprintk+0x250>
					min_width = *fmt - '0';
   80a42:	f1a0 0930 	sub.w	r9, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
   80a46:	f1b8 0f00 	cmp.w	r8, #0
   80a4a:	bf08      	it	eq
   80a4c:	f04f 0802 	moveq.w	r8, #2
   80a50:	e7a3      	b.n	8099a <_vprintk+0x32>
				if (min_width < 0) {
   80a52:	f1b9 0f00 	cmp.w	r9, #0
   80a56:	dbf4      	blt.n	80a42 <_vprintk+0xda>
					min_width = 10 * min_width + *fmt - '0';
   80a58:	230a      	movs	r3, #10
   80a5a:	fb03 0909 	mla	r9, r3, r9, r0
   80a5e:	f1a9 0930 	sub.w	r9, r9, #48	; 0x30
   80a62:	e7f0      	b.n	80a46 <_vprintk+0xde>
				long_ctr++;
   80a64:	f10a 0a01 	add.w	sl, sl, #1
   80a68:	e797      	b.n	8099a <_vprintk+0x32>
				if (long_ctr < 2) {
   80a6a:	f1ba 0f01 	cmp.w	sl, #1
					d = (long)va_arg(ap, long long);
   80a6e:	bfc5      	ittet	gt
   80a70:	3407      	addgt	r4, #7
   80a72:	f024 0307 	bicgt.w	r3, r4, #7
					d = va_arg(ap, long);
   80a76:	6825      	ldrle	r5, [r4, #0]
					d = (long)va_arg(ap, long long);
   80a78:	681d      	ldrgt	r5, [r3, #0]
					d = va_arg(ap, long);
   80a7a:	bfd4      	ite	le
   80a7c:	3404      	addle	r4, #4
					d = (long)va_arg(ap, long long);
   80a7e:	f103 0408 	addgt.w	r4, r3, #8
				if (d < 0) {
   80a82:	2d00      	cmp	r5, #0
   80a84:	da05      	bge.n	80a92 <_vprintk+0x12a>
					out((int)'-', ctx);
   80a86:	4639      	mov	r1, r7
   80a88:	202d      	movs	r0, #45	; 0x2d
   80a8a:	47b0      	blx	r6
					d = -d;
   80a8c:	426d      	negs	r5, r5
					min_width--;
   80a8e:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
				_printk_dec_ulong(out, ctx, d, padding,
   80a92:	4643      	mov	r3, r8
   80a94:	462a      	mov	r2, r5
   80a96:	f8cd 9000 	str.w	r9, [sp]
				_printk_dec_ulong(out, ctx, u, padding,
   80a9a:	4639      	mov	r1, r7
   80a9c:	4630      	mov	r0, r6
   80a9e:	f7ff ff0f 	bl	808c0 <_printk_dec_ulong>
			might_format = 0;
   80aa2:	2500      	movs	r5, #0
				break;
   80aa4:	e779      	b.n	8099a <_vprintk+0x32>
				if (long_ctr < 2) {
   80aa6:	f1ba 0f01 	cmp.w	sl, #1
					u = (unsigned long)va_arg(ap,
   80aaa:	bfc5      	ittet	gt
   80aac:	3407      	addgt	r4, #7
   80aae:	f024 0307 	bicgt.w	r3, r4, #7
					u = va_arg(ap, unsigned long);
   80ab2:	6822      	ldrle	r2, [r4, #0]
					u = (unsigned long)va_arg(ap,
   80ab4:	681a      	ldrgt	r2, [r3, #0]
   80ab6:	bfcc      	ite	gt
   80ab8:	f103 0408 	addgt.w	r4, r3, #8
					u = va_arg(ap, unsigned long);
   80abc:	3404      	addle	r4, #4
				_printk_dec_ulong(out, ctx, u, padding,
   80abe:	f8cd 9000 	str.w	r9, [sp]
   80ac2:	4643      	mov	r3, r8
   80ac4:	e7e9      	b.n	80a9a <_vprintk+0x132>
				  out('0', ctx);
   80ac6:	4639      	mov	r1, r7
   80ac8:	2030      	movs	r0, #48	; 0x30
   80aca:	47b0      	blx	r6
				  out('x', ctx);
   80acc:	4639      	mov	r1, r7
   80ace:	2078      	movs	r0, #120	; 0x78
   80ad0:	47b0      	blx	r6
				  min_width = 8;
   80ad2:	f04f 0908 	mov.w	r9, #8
				  padding = PAD_ZERO_BEFORE;
   80ad6:	f04f 0801 	mov.w	r8, #1
	int remaining = 8; /* 8 digits max */
   80ada:	2208      	movs	r2, #8
				if (long_ctr < 2) {
   80adc:	f1ba 0f01 	cmp.w	sl, #1
					x = (unsigned long)va_arg(ap,
   80ae0:	bfc5      	ittet	gt
   80ae2:	3407      	addgt	r4, #7
   80ae4:	f024 0307 	bicgt.w	r3, r4, #7
					x = va_arg(ap, unsigned long);
   80ae8:	6823      	ldrle	r3, [r4, #0]
					x = (unsigned long)va_arg(ap,
   80aea:	f103 0408 	addgt.w	r4, r3, #8
   80aee:	bfca      	itet	gt
   80af0:	681b      	ldrgt	r3, [r3, #0]
					x = va_arg(ap, unsigned long);
   80af2:	9305      	strle	r3, [sp, #20]
					x = (unsigned long)va_arg(ap,
   80af4:	9305      	strgt	r3, [sp, #20]
	int digits = 0;
   80af6:	f04f 0300 	mov.w	r3, #0
	int size = sizeof(num) * 2;
   80afa:	4693      	mov	fp, r2
					x = va_arg(ap, unsigned long);
   80afc:	bfd8      	it	le
   80afe:	3404      	addle	r4, #4
	int digits = 0;
   80b00:	9303      	str	r3, [sp, #12]
	int found_largest_digit = 0;
   80b02:	9307      	str	r3, [sp, #28]
		char nibble = (num >> ((size - 1) << 2) & 0xf);
   80b04:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
   80b08:	9b05      	ldr	r3, [sp, #20]
   80b0a:	ea4f 008b 	mov.w	r0, fp, lsl #2
   80b0e:	fa23 f000 	lsr.w	r0, r3, r0
		if (nibble || found_largest_digit || size == 1) {
   80b12:	f010 000f 	ands.w	r0, r0, #15
   80b16:	d109      	bne.n	80b2c <_vprintk+0x1c4>
   80b18:	9b07      	ldr	r3, [sp, #28]
   80b1a:	b913      	cbnz	r3, 80b22 <_vprintk+0x1ba>
   80b1c:	f1bb 0f00 	cmp.w	fp, #0
   80b20:	d122      	bne.n	80b68 <_vprintk+0x200>
			nibble += nibble > 9 ? 87 : 48;
   80b22:	f04f 0e30 	mov.w	lr, #48	; 0x30
   80b26:	e007      	b.n	80b38 <_vprintk+0x1d0>
	for (; size; size--) {
   80b28:	9a06      	ldr	r2, [sp, #24]
   80b2a:	e7eb      	b.n	80b04 <_vprintk+0x19c>
			nibble += nibble > 9 ? 87 : 48;
   80b2c:	2809      	cmp	r0, #9
   80b2e:	bf8c      	ite	hi
   80b30:	f04f 0e57 	movhi.w	lr, #87	; 0x57
   80b34:	f04f 0e30 	movls.w	lr, #48	; 0x30
			out((int)nibble, ctx);
   80b38:	4639      	mov	r1, r7
   80b3a:	4470      	add	r0, lr
   80b3c:	9206      	str	r2, [sp, #24]
   80b3e:	47b0      	blx	r6
			digits++;
   80b40:	9b03      	ldr	r3, [sp, #12]
			found_largest_digit = 1;
   80b42:	9507      	str	r5, [sp, #28]
			digits++;
   80b44:	3301      	adds	r3, #1
   80b46:	9303      	str	r3, [sp, #12]
	for (; size; size--) {
   80b48:	f1bb 0f00 	cmp.w	fp, #0
   80b4c:	d1ec      	bne.n	80b28 <_vprintk+0x1c0>
	if (padding == PAD_SPACE_AFTER) {
   80b4e:	f1b8 0f03 	cmp.w	r8, #3
   80b52:	d1a6      	bne.n	80aa2 <_vprintk+0x13a>
		remaining = min_width * 2 - digits;
   80b54:	9b03      	ldr	r3, [sp, #12]
   80b56:	ebc3 0549 	rsb	r5, r3, r9, lsl #1
		while (remaining-- > 0) {
   80b5a:	2d00      	cmp	r5, #0
   80b5c:	dda1      	ble.n	80aa2 <_vprintk+0x13a>
			out(' ', ctx);
   80b5e:	4639      	mov	r1, r7
   80b60:	2020      	movs	r0, #32
   80b62:	47b0      	blx	r6
   80b64:	3d01      	subs	r5, #1
   80b66:	e7f8      	b.n	80b5a <_vprintk+0x1f2>
		if (remaining-- <= min_width) {
   80b68:	1e53      	subs	r3, r2, #1
   80b6a:	4591      	cmp	r9, r2
   80b6c:	9306      	str	r3, [sp, #24]
   80b6e:	dbeb      	blt.n	80b48 <_vprintk+0x1e0>
			if (padding == PAD_ZERO_BEFORE) {
   80b70:	f1b8 0f01 	cmp.w	r8, #1
   80b74:	d103      	bne.n	80b7e <_vprintk+0x216>
				out('0', ctx);
   80b76:	4639      	mov	r1, r7
   80b78:	2030      	movs	r0, #48	; 0x30
				out(' ', ctx);
   80b7a:	47b0      	blx	r6
   80b7c:	e7e4      	b.n	80b48 <_vprintk+0x1e0>
			} else if (padding == PAD_SPACE_BEFORE) {
   80b7e:	f1b8 0f02 	cmp.w	r8, #2
   80b82:	d1e1      	bne.n	80b48 <_vprintk+0x1e0>
				out(' ', ctx);
   80b84:	4639      	mov	r1, r7
   80b86:	2020      	movs	r0, #32
   80b88:	e7f7      	b.n	80b7a <_vprintk+0x212>
					out((int)(*s++), ctx);
   80b8a:	4639      	mov	r1, r7
   80b8c:	9303      	str	r3, [sp, #12]
   80b8e:	462c      	mov	r4, r5
   80b90:	47b0      	blx	r6
   80b92:	9b03      	ldr	r3, [sp, #12]
   80b94:	e735      	b.n	80a02 <_vprintk+0x9a>
						out(' ', ctx);
   80b96:	4639      	mov	r1, r7
   80b98:	2020      	movs	r0, #32
   80b9a:	47b0      	blx	r6
   80b9c:	3c01      	subs	r4, #1
   80b9e:	e73d      	b.n	80a1c <_vprintk+0xb4>
				out(c, ctx);
   80ba0:	6820      	ldr	r0, [r4, #0]
				int c = va_arg(ap, int);
   80ba2:	1d25      	adds	r5, r4, #4
				out(c, ctx);
   80ba4:	4639      	mov	r1, r7
   80ba6:	47b0      	blx	r6
				int c = va_arg(ap, int);
   80ba8:	462c      	mov	r4, r5
   80baa:	e77a      	b.n	80aa2 <_vprintk+0x13a>
				long_ctr = 0;
   80bac:	46aa      	mov	sl, r5
				padding = PAD_NONE;
   80bae:	46a8      	mov	r8, r5
				min_width = -1;
   80bb0:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
				might_format = 1;
   80bb4:	2501      	movs	r5, #1
   80bb6:	e6f0      	b.n	8099a <_vprintk+0x32>
					padding = PAD_ZERO_BEFORE;
   80bb8:	f04f 0801 	mov.w	r8, #1
   80bbc:	e6ed      	b.n	8099a <_vprintk+0x32>
				char *s = va_arg(ap, char *);
   80bbe:	465c      	mov	r4, fp
			might_format = 0;
   80bc0:	4605      	mov	r5, r0
   80bc2:	e6ea      	b.n	8099a <_vprintk+0x32>

00080bc4 <vprintk>:
	struct out_context ctx = { 0 };
   80bc4:	2300      	movs	r3, #0
{
   80bc6:	b513      	push	{r0, r1, r4, lr}
	struct out_context ctx = { 0 };
   80bc8:	ac02      	add	r4, sp, #8
   80bca:	f844 3d04 	str.w	r3, [r4, #-4]!
	_vprintk(char_out, &ctx, fmt, ap);
   80bce:	4602      	mov	r2, r0
   80bd0:	460b      	mov	r3, r1
   80bd2:	4803      	ldr	r0, [pc, #12]	; (80be0 <vprintk+0x1c>)
   80bd4:	4621      	mov	r1, r4
   80bd6:	f7ff fec7 	bl	80968 <_vprintk>
}
   80bda:	9801      	ldr	r0, [sp, #4]
   80bdc:	b002      	add	sp, #8
   80bde:	bd10      	pop	{r4, pc}
   80be0:	000808b1 	.word	0x000808b1

00080be4 <printk>:
{
   80be4:	b40f      	push	{r0, r1, r2, r3}
   80be6:	b507      	push	{r0, r1, r2, lr}
   80be8:	a904      	add	r1, sp, #16
   80bea:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   80bee:	9101      	str	r1, [sp, #4]
		ret = vprintk(fmt, ap);
   80bf0:	f7ff ffe8 	bl	80bc4 <vprintk>
}
   80bf4:	b003      	add	sp, #12
   80bf6:	f85d eb04 	ldr.w	lr, [sp], #4
   80bfa:	b004      	add	sp, #16
   80bfc:	4770      	bx	lr

00080bfe <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_HAS_DTS, 1);
GEN_ABSOLUTE_SYM(CONFIG_ARM, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_POWER_LOW_POWER_STATE_SUPPORTED, 1);
GEN_ABSOLUTE_SYM(CONFIG_ARCH_HAS_THREAD_ABORT, 1);
GEN_ABSOLUTE_SYM(CONFIG_CPU_CORTEX, 1);
GEN_ABSOLUTE_SYM(CONFIG_ATOMIC_OPERATIONS_BUILTIN, 1);
   80bfe:	4770      	bx	lr

00080c00 <console_out>:
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
   80c00:	280a      	cmp	r0, #10
{
   80c02:	b538      	push	{r3, r4, r5, lr}
   80c04:	4604      	mov	r4, r0
   80c06:	4d07      	ldr	r5, [pc, #28]	; (80c24 <console_out+0x24>)
	if ('\n' == c) {
   80c08:	d104      	bne.n	80c14 <console_out+0x14>
		uart_poll_out(uart_console_dev, '\r');
   80c0a:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	return api->poll_out(dev, out_char);
   80c0c:	210d      	movs	r1, #13
   80c0e:	6843      	ldr	r3, [r0, #4]
   80c10:	685b      	ldr	r3, [r3, #4]
   80c12:	4798      	blx	r3
	}
	uart_poll_out(uart_console_dev, c);
   80c14:	6828      	ldr	r0, [r5, #0]
   80c16:	b2e1      	uxtb	r1, r4
   80c18:	6843      	ldr	r3, [r0, #4]
   80c1a:	685b      	ldr	r3, [r3, #4]
   80c1c:	4798      	blx	r3

	return c;
}
   80c1e:	4620      	mov	r0, r4
   80c20:	bd38      	pop	{r3, r4, r5, pc}
   80c22:	bf00      	nop
   80c24:	20070000 	.word	0x20070000

00080c28 <uart_console_hook_install>:
 */

void uart_console_hook_install(void)
{
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
   80c28:	4801      	ldr	r0, [pc, #4]	; (80c30 <uart_console_hook_install+0x8>)
   80c2a:	f7ff be97 	b.w	8095c <__printk_hook_install>
   80c2e:	bf00      	nop
   80c30:	00080c01 	.word	0x00080c01

00080c34 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
   80c34:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
   80c36:	4804      	ldr	r0, [pc, #16]	; (80c48 <uart_console_init+0x14>)
   80c38:	f000 fe5a 	bl	818f0 <device_get_binding>
   80c3c:	4b03      	ldr	r3, [pc, #12]	; (80c4c <uart_console_init+0x18>)
   80c3e:	6018      	str	r0, [r3, #0]
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
   80c40:	f7ff fff2 	bl	80c28 <uart_console_hook_install>

	return 0;
}
   80c44:	2000      	movs	r0, #0
   80c46:	bd08      	pop	{r3, pc}
   80c48:	00082ab6 	.word	0x00082ab6
   80c4c:	20070000 	.word	0x20070000

00080c50 <wdt_sam_disable>:
	SYS_LOG_ERR("Function not implemented!");
}

static int wdt_sam_disable(struct device *dev)
{
	Wdt *const wdt = DEV_CFG(dev)->regs;
   80c50:	6803      	ldr	r3, [r0, #0]

	wdt->WDT_MR |= WDT_MR_WDDIS;

	return 0;
}
   80c52:	2000      	movs	r0, #0
	Wdt *const wdt = DEV_CFG(dev)->regs;
   80c54:	689b      	ldr	r3, [r3, #8]
   80c56:	681a      	ldr	r2, [r3, #0]
	wdt->WDT_MR |= WDT_MR_WDDIS;
   80c58:	6853      	ldr	r3, [r2, #4]
   80c5a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   80c5e:	6053      	str	r3, [r2, #4]
}
   80c60:	4770      	bx	lr

00080c62 <wdt_sam_set_config>:
	ARG_UNUSED(config);

	SYS_LOG_ERR("Function not implemented!");

	return -ENOTSUP;
}
   80c62:	f06f 0022 	mvn.w	r0, #34	; 0x22
   80c66:	4770      	bx	lr

00080c68 <wdt_sam_get_config>:

static void wdt_sam_get_config(struct device *dev, struct wdt_config *config)
{
   80c68:	4770      	bx	lr

00080c6a <wdt_sam_reload>:

	SYS_LOG_ERR("Function not implemented!");
}

static void wdt_sam_reload(struct device *dev)
{
   80c6a:	4770      	bx	lr

00080c6c <wdt_sam_init>:
	.set_config = wdt_sam_set_config,
	.reload = wdt_sam_reload
};

static int wdt_sam_init(struct device *dev)
{
   80c6c:	b508      	push	{r3, lr}
#ifdef CONFIG_WDT_SAM_DISABLE_AT_BOOT
	wdt_sam_disable(dev);
   80c6e:	f7ff ffef 	bl	80c50 <wdt_sam_disable>
#endif
	return 0;
}
   80c72:	2000      	movs	r0, #0
   80c74:	bd08      	pop	{r3, pc}

00080c76 <wdt_sam_enable>:
   80c76:	4770      	bx	lr

00080c78 <_timer_int_handler>:
	__asm__(" cpsie i"); /* re-enable interrupts (PRIMASK = 0) */

#else /* !CONFIG_SYS_POWER_MANAGEMENT */

	/* accumulate total counter value */
	clock_accumulated_count += sys_clock_hw_cycles_per_tick;
   80c78:	4a07      	ldr	r2, [pc, #28]	; (80c98 <_timer_int_handler+0x20>)
   80c7a:	4908      	ldr	r1, [pc, #32]	; (80c9c <_timer_int_handler+0x24>)
{
   80c7c:	b508      	push	{r3, lr}
	clock_accumulated_count += sys_clock_hw_cycles_per_tick;
   80c7e:	6809      	ldr	r1, [r1, #0]
   80c80:	6813      	ldr	r3, [r2, #0]
   80c82:	440b      	add	r3, r1
   80c84:	6013      	str	r3, [r2, #0]

	/*
	 * one more tick has occurred -- don't need to do anything special since
	 * timer is already configured to interrupt on the following tick
	 */
	_sys_clock_tick_announce();
   80c86:	4b06      	ldr	r3, [pc, #24]	; (80ca0 <_timer_int_handler+0x28>)
   80c88:	6818      	ldr	r0, [r3, #0]
   80c8a:	f001 fbd9 	bl	82440 <_nano_sys_clock_tick_announce>
	read_timer_end_of_tick_handler();
#endif

	extern void _ExcExit(void);
	_ExcExit();
}
   80c8e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	_ExcExit();
   80c92:	f000 b833 	b.w	80cfc <_ExcExit>
   80c96:	bf00      	nop
   80c98:	20070004 	.word	0x20070004
   80c9c:	20071c94 	.word	0x20071c94
   80ca0:	20071c90 	.word	0x20071c90

00080ca4 <_sys_clock_driver_init>:
 * rate specified via the 'sys_clock_us_per_tick' global variable.
 *
 * @return 0
 */
int _sys_clock_driver_init(struct device *device)
{
   80ca4:	b508      	push	{r3, lr}
	/*
	 * Determine the reload value to achieve the configured tick rate.
	 */

	/* systick supports 24-bit H/W counter */
	__ASSERT(sys_clock_hw_cycles_per_tick <= (1 << 24),
   80ca6:	4b0e      	ldr	r3, [pc, #56]	; (80ce0 <_sys_clock_driver_init+0x3c>)
   80ca8:	681a      	ldr	r2, [r3, #0]
   80caa:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
   80cae:	dd0a      	ble.n	80cc6 <_sys_clock_driver_init+0x22>
   80cb0:	f44f 7333 	mov.w	r3, #716	; 0x2cc
   80cb4:	4a0b      	ldr	r2, [pc, #44]	; (80ce4 <_sys_clock_driver_init+0x40>)
   80cb6:	490c      	ldr	r1, [pc, #48]	; (80ce8 <_sys_clock_driver_init+0x44>)
   80cb8:	480c      	ldr	r0, [pc, #48]	; (80cec <_sys_clock_driver_init+0x48>)
   80cba:	f7ff ff93 	bl	80be4 <printk>
   80cbe:	480c      	ldr	r0, [pc, #48]	; (80cf0 <_sys_clock_driver_init+0x4c>)
   80cc0:	f7ff ff90 	bl	80be4 <printk>
   80cc4:	e7fe      	b.n	80cc4 <_sys_clock_driver_init+0x20>
	SysTick->VAL = 0; /* also clears the countflag */
   80cc6:	2000      	movs	r0, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   80cc8:	2110      	movs	r1, #16
	SysTick->LOAD = count;
   80cca:	4b0a      	ldr	r3, [pc, #40]	; (80cf4 <_sys_clock_driver_init+0x50>)
		 "sys_clock_hw_cycles_per_tick too large");
	sysTickReloadSet(sys_clock_hw_cycles_per_tick - 1);
   80ccc:	3a01      	subs	r2, #1
	SysTick->LOAD = count;
   80cce:	605a      	str	r2, [r3, #4]
   80cd0:	4a09      	ldr	r2, [pc, #36]	; (80cf8 <_sys_clock_driver_init+0x54>)
	SysTick->VAL = 0; /* also clears the countflag */
   80cd2:	6098      	str	r0, [r3, #8]
   80cd4:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23

#endif /* CONFIG_TICKLESS_IDLE */

	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);

	SysTick->CTRL = ctrl;
   80cd8:	2207      	movs	r2, #7
   80cda:	601a      	str	r2, [r3, #0]

	SysTick->VAL = 0; /* triggers immediate reload of count */
   80cdc:	6098      	str	r0, [r3, #8]

	return 0;
}
   80cde:	bd08      	pop	{r3, pc}
   80ce0:	20071c94 	.word	0x20071c94
   80ce4:	00082af6 	.word	0x00082af6
   80ce8:	00082b2c 	.word	0x00082b2c
   80cec:	00082995 	.word	0x00082995
   80cf0:	00082b56 	.word	0x00082b56
   80cf4:	e000e010 	.word	0xe000e010
   80cf8:	e000ed00 	.word	0xe000ed00

00080cfc <_ExcExit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, _ExcExit)

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
   80cfc:	4807      	ldr	r0, [pc, #28]	; (80d1c <_EXIT_EXC+0x4>)

    ldr r1, [r0, #_kernel_offset_to_current]
   80cfe:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, _kernel_offset_to_ready_q_cache]
   80d00:	69c0      	ldr	r0, [r0, #28]
    cmp r0, r1
   80d02:	4288      	cmp	r0, r1
    beq _EXIT_EXC
   80d04:	d008      	beq.n	80d18 <_EXIT_EXC>

#ifdef CONFIG_TIMESLICING
    push {lr}
   80d06:	b500      	push	{lr}
    bl _update_time_slice_before_swap
   80d08:	f001 fac2 	bl	82290 <_update_time_slice_before_swap>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    pop {r0}
    mov lr, r0
#else
    pop {lr}
   80d0c:	f85d eb04 	ldr.w	lr, [sp], #4
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TIMESLICING */

    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
   80d10:	4903      	ldr	r1, [pc, #12]	; (80d20 <_EXIT_EXC+0x8>)
    ldr r2, =_SCS_ICSR_PENDSV
   80d12:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
   80d16:	600a      	str	r2, [r1, #0]

00080d18 <_EXIT_EXC>:
#else
    pop {lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

    bx lr
   80d18:	4770      	bx	lr
   80d1a:	0000      	.short	0x0000
    ldr r0, =_kernel
   80d1c:	20070350 	.word	0x20070350
    ldr r1, =_SCS_ICSR
   80d20:	e000ed04 	.word	0xe000ed04

00080d24 <_IntLibInit>:
 * @return N/A
 */

void _IntLibInit(void)
{
	int irq = 0;
   80d24:	2300      	movs	r3, #0
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   80d26:	2110      	movs	r1, #16
   80d28:	4803      	ldr	r0, [pc, #12]	; (80d38 <_IntLibInit+0x14>)
   80d2a:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   80d2c:	3301      	adds	r3, #1
   80d2e:	2b2d      	cmp	r3, #45	; 0x2d
   80d30:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   80d34:	d1f9      	bne.n	80d2a <_IntLibInit+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   80d36:	4770      	bx	lr
   80d38:	e000e100 	.word	0xe000e100

00080d3c <__swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
   80d3c:	4a08      	ldr	r2, [pc, #32]	; (80d60 <__swap+0x24>)
	_current->arch.swap_return_value = _k_neg_eagain;
   80d3e:	4909      	ldr	r1, [pc, #36]	; (80d64 <__swap+0x28>)
	_current->arch.basepri = key;
   80d40:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   80d42:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   80d44:	6618      	str	r0, [r3, #96]	; 0x60
	_current->arch.swap_return_value = _k_neg_eagain;
   80d46:	6659      	str	r1, [r3, #100]	; 0x64

	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   80d48:	4907      	ldr	r1, [pc, #28]	; (80d68 <__swap+0x2c>)
   80d4a:	684b      	ldr	r3, [r1, #4]
   80d4c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   80d50:	604b      	str	r3, [r1, #4]
   80d52:	2300      	movs	r3, #0
   80d54:	f383 8811 	msr	BASEPRI, r3

	/* clear mask or enable all irqs to take a pendsv */
	irq_unlock(0);

	return _current->arch.swap_return_value;
   80d58:	6893      	ldr	r3, [r2, #8]
}
   80d5a:	6e58      	ldr	r0, [r3, #100]	; 0x64
   80d5c:	4770      	bx	lr
   80d5e:	bf00      	nop
   80d60:	20070350 	.word	0x20070350
   80d64:	000832f0 	.word	0x000832f0
   80d68:	e000ed00 	.word	0xe000ed00

00080d6c <__pendsv>:

    /* protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   80d6c:	2010      	movs	r0, #16
    msr BASEPRI, r0
   80d6e:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   80d72:	490d      	ldr	r1, [pc, #52]	; (80da8 <__pendsv+0x3c>)
    ldr r2, [r1, #_kernel_offset_to_current]
   80d74:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   80d76:	202c      	movs	r0, #44	; 0x2c
    add r0, r2
   80d78:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
    mrs ip, PSP
   80d7a:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   80d7e:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
     * don't clear it yet. PendSV must not be cleared until
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
    ldr v4, =_SCS_ICSR
   80d82:	4f0a      	ldr	r7, [pc, #40]	; (80dac <__pendsv+0x40>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   80d84:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, _kernel_offset_to_ready_q_cache]
   80d88:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
   80d8a:	608a      	str	r2, [r1, #8]
     * since they were based on the previous kernel state and this
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
    str v3, [v4, #0]
   80d8c:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   80d8e:	6e10      	ldr	r0, [r2, #96]	; 0x60
    movs.n r3, #0
   80d90:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   80d92:	6613      	str	r3, [r2, #96]	; 0x60
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   80d94:	f380 8811 	msr	BASEPRI, r0
    blx configure_mpu_user_context
    pop {r2, lr}
#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   80d98:	f102 002c 	add.w	r0, r2, #44	; 0x2c
    ldmia r0, {v1-v8, ip}
   80d9c:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

    msr PSP, ip
   80da0:	f38c 8809 	msr	PSP, ip
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
    ldm sp!,{r0-r3} /* Load back regs ro to r4 */
#endif /* CONFIG_EXECUTION_BENCHMARKING */

    /* exc return */
    bx lr
   80da4:	4770      	bx	lr
   80da6:	0000      	.short	0x0000
    ldr r1, =_kernel
   80da8:	20070350 	.word	0x20070350
    ldr v4, =_SCS_ICSR
   80dac:	e000ed04 	.word	0xe000ed04

00080db0 <__svc>:
 *
 * @return N/A
 */

SECTION_FUNC(TEXT, __svc)
    tst lr, #0x4    /* did we come from thread mode ? */
   80db0:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   80db4:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   80db6:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   80dba:	f3ef 8009 	mrsne	r0, PSP

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   80dbe:	6981      	ldr	r1, [r0, #24]
    /* SVC is a two-byte instruction, point to it and read  encoding */
    ldrh r1, [r1, #-2]
   80dc0:	f831 1c02 	ldrh.w	r1, [r1, #-2]
    * 2: kernel panic or oops (software generated fatal exception)
    * 3: System call
    * Planned implementation of system calls for memory protection will
    * expand this case.
    */
    ands r1, #0xff
   80dc4:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
    tst r2, #0x1
    bne _oops

#endif

    cmp r1, #2
   80dc8:	2902      	cmp	r1, #2
    beq _oops
   80dca:	d0ff      	beq.n	80dcc <_oops>

00080dcc <_oops>:
    /* exception return is done in _IntExit() */
    b _IntExit
#endif

_oops:
    push {lr}
   80dcc:	b500      	push	{lr}
    blx _do_kernel_oops
   80dce:	f000 fa0f 	bl	811f0 <_do_kernel_oops>
    pop {pc}
   80dd2:	bd00      	pop	{pc}

00080dd4 <_MpuFault.isra.2>:
 *
 * See _FaultDump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t _MpuFault(NANO_ESF *esf, int fromHardFault)
   80dd4:	b538      	push	{r3, r4, r5, lr}
{
	u32_t reason = _NANO_ERR_HW_EXCEPTION;

	PR_FAULT_INFO("***** MPU FAULT *****\n");

	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
   80dd6:	4c16      	ldr	r4, [pc, #88]	; (80e30 <_MpuFault.isra.2+0x5c>)
static u32_t _MpuFault(NANO_ESF *esf, int fromHardFault)
   80dd8:	4605      	mov	r5, r0
	PR_FAULT_INFO("***** MPU FAULT *****\n");
   80dda:	4816      	ldr	r0, [pc, #88]	; (80e34 <_MpuFault.isra.2+0x60>)
   80ddc:	f7ff ff02 	bl	80be4 <printk>
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
   80de0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80de2:	06db      	lsls	r3, r3, #27
   80de4:	d502      	bpl.n	80dec <_MpuFault.isra.2+0x18>
		PR_FAULT_INFO("  Stacking error\n");
   80de6:	4814      	ldr	r0, [pc, #80]	; (80e38 <_MpuFault.isra.2+0x64>)
   80de8:	f7ff fefc 	bl	80be4 <printk>
	}
	if (SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) {
   80dec:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80dee:	0718      	lsls	r0, r3, #28
   80df0:	d502      	bpl.n	80df8 <_MpuFault.isra.2+0x24>
		PR_FAULT_INFO("  Unstacking error\n");
   80df2:	4812      	ldr	r0, [pc, #72]	; (80e3c <_MpuFault.isra.2+0x68>)
   80df4:	f7ff fef6 	bl	80be4 <printk>
	}
	if (SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) {
   80df8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80dfa:	0799      	lsls	r1, r3, #30
   80dfc:	d50e      	bpl.n	80e1c <_MpuFault.isra.2+0x48>
		PR_FAULT_INFO("  Data Access Violation\n");
   80dfe:	4810      	ldr	r0, [pc, #64]	; (80e40 <_MpuFault.isra.2+0x6c>)
   80e00:	f7ff fef0 	bl	80be4 <printk>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		u32_t mmfar = SCB->MMFAR;
   80e04:	6b61      	ldr	r1, [r4, #52]	; 0x34

		if (SCB->CFSR & SCB_CFSR_MMARVALID_Msk) {
   80e06:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80e08:	061a      	lsls	r2, r3, #24
   80e0a:	d507      	bpl.n	80e1c <_MpuFault.isra.2+0x48>
			PR_EXC("  MMFAR Address: 0x%x\n", mmfar);
   80e0c:	480d      	ldr	r0, [pc, #52]	; (80e44 <_MpuFault.isra.2+0x70>)
   80e0e:	f7ff fee9 	bl	80be4 <printk>
			if (fromHardFault) {
   80e12:	b11d      	cbz	r5, 80e1c <_MpuFault.isra.2+0x48>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   80e14:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80e16:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   80e1a:	62a3      	str	r3, [r4, #40]	; 0x28
#else
		(void)mmfar;
#endif /* CONFIG_HW_STACK_PROTECTION */
		}
	}
	if (SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) {
   80e1c:	4b04      	ldr	r3, [pc, #16]	; (80e30 <_MpuFault.isra.2+0x5c>)
   80e1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   80e20:	07db      	lsls	r3, r3, #31
   80e22:	d502      	bpl.n	80e2a <_MpuFault.isra.2+0x56>
		PR_FAULT_INFO("  Instruction Access Violation\n");
   80e24:	4808      	ldr	r0, [pc, #32]	; (80e48 <_MpuFault.isra.2+0x74>)
   80e26:	f7ff fedd 	bl	80be4 <printk>
	if (_MemoryFaultIsRecoverable(esf)) {
		reason = _NANO_ERR_RECOVERABLE;
	}

	return reason;
}
   80e2a:	2000      	movs	r0, #0
   80e2c:	bd38      	pop	{r3, r4, r5, pc}
   80e2e:	bf00      	nop
   80e30:	e000ed00 	.word	0xe000ed00
   80e34:	00082ccc 	.word	0x00082ccc
   80e38:	00082ce3 	.word	0x00082ce3
   80e3c:	00082cf5 	.word	0x00082cf5
   80e40:	00082d09 	.word	0x00082d09
   80e44:	00082d22 	.word	0x00082d22
   80e48:	00082d39 	.word	0x00082d39

00080e4c <_BusFault.isra.3>:
 *
 * See _FaultDump() for example.
 *
 * @return N/A
 */
static int _BusFault(NANO_ESF *esf, int fromHardFault)
   80e4c:	b538      	push	{r3, r4, r5, lr}
{
	PR_FAULT_INFO("***** BUS FAULT *****\n");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   80e4e:	4c19      	ldr	r4, [pc, #100]	; (80eb4 <_BusFault.isra.3+0x68>)
static int _BusFault(NANO_ESF *esf, int fromHardFault)
   80e50:	4605      	mov	r5, r0
	PR_FAULT_INFO("***** BUS FAULT *****\n");
   80e52:	4819      	ldr	r0, [pc, #100]	; (80eb8 <_BusFault.isra.3+0x6c>)
   80e54:	f7ff fec6 	bl	80be4 <printk>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   80e58:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80e5a:	04d9      	lsls	r1, r3, #19
   80e5c:	d504      	bpl.n	80e68 <_BusFault.isra.3+0x1c>
		PR_FAULT_INFO("  Stacking error\n");
   80e5e:	4817      	ldr	r0, [pc, #92]	; (80ebc <_BusFault.isra.3+0x70>)
			PR_FAULT_INFO("  Imprecise data bus error\n");
		}
	} else if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
		PR_FAULT_INFO("  Imprecise data bus error\n");
	} else if (SCB->CFSR & SCB_CFSR_IBUSERR_Msk) {
		PR_FAULT_INFO("  Instruction bus error\n");
   80e60:	f7ff fec0 	bl	80be4 <printk>
	if (_MemoryFaultIsRecoverable(esf)) {
		return _NANO_ERR_RECOVERABLE;
	}

	return _NANO_ERR_HW_EXCEPTION;
}
   80e64:	2000      	movs	r0, #0
   80e66:	bd38      	pop	{r3, r4, r5, pc}
	} else if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   80e68:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80e6a:	051a      	lsls	r2, r3, #20
   80e6c:	d501      	bpl.n	80e72 <_BusFault.isra.3+0x26>
		PR_FAULT_INFO("  Unstacking error\n");
   80e6e:	4814      	ldr	r0, [pc, #80]	; (80ec0 <_BusFault.isra.3+0x74>)
   80e70:	e7f6      	b.n	80e60 <_BusFault.isra.3+0x14>
	} else if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   80e72:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80e74:	059b      	lsls	r3, r3, #22
   80e76:	d514      	bpl.n	80ea2 <_BusFault.isra.3+0x56>
		PR_FAULT_INFO("  Precise data bus error\n");
   80e78:	4812      	ldr	r0, [pc, #72]	; (80ec4 <_BusFault.isra.3+0x78>)
   80e7a:	f7ff feb3 	bl	80be4 <printk>
		STORE_xFAR(bfar, SCB->BFAR);
   80e7e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
		if (SCB->CFSR & SCB_CFSR_BFARVALID_Msk) {
   80e80:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80e82:	0418      	lsls	r0, r3, #16
   80e84:	d507      	bpl.n	80e96 <_BusFault.isra.3+0x4a>
			PR_EXC("  BFAR Address: 0x%x\n", bfar);
   80e86:	4810      	ldr	r0, [pc, #64]	; (80ec8 <_BusFault.isra.3+0x7c>)
   80e88:	f7ff feac 	bl	80be4 <printk>
			if (fromHardFault) {
   80e8c:	b11d      	cbz	r5, 80e96 <_BusFault.isra.3+0x4a>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   80e8e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80e90:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   80e94:	62a3      	str	r3, [r4, #40]	; 0x28
		if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   80e96:	4b07      	ldr	r3, [pc, #28]	; (80eb4 <_BusFault.isra.3+0x68>)
   80e98:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   80e9a:	0559      	lsls	r1, r3, #21
   80e9c:	d5e2      	bpl.n	80e64 <_BusFault.isra.3+0x18>
			PR_FAULT_INFO("  Imprecise data bus error\n");
   80e9e:	480b      	ldr	r0, [pc, #44]	; (80ecc <_BusFault.isra.3+0x80>)
   80ea0:	e7de      	b.n	80e60 <_BusFault.isra.3+0x14>
	} else if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   80ea2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80ea4:	055a      	lsls	r2, r3, #21
   80ea6:	d4fa      	bmi.n	80e9e <_BusFault.isra.3+0x52>
	} else if (SCB->CFSR & SCB_CFSR_IBUSERR_Msk) {
   80ea8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80eaa:	05db      	lsls	r3, r3, #23
   80eac:	d5da      	bpl.n	80e64 <_BusFault.isra.3+0x18>
		PR_FAULT_INFO("  Instruction bus error\n");
   80eae:	4808      	ldr	r0, [pc, #32]	; (80ed0 <_BusFault.isra.3+0x84>)
   80eb0:	e7d6      	b.n	80e60 <_BusFault.isra.3+0x14>
   80eb2:	bf00      	nop
   80eb4:	e000ed00 	.word	0xe000ed00
   80eb8:	00082b7d 	.word	0x00082b7d
   80ebc:	00082ce3 	.word	0x00082ce3
   80ec0:	00082cf5 	.word	0x00082cf5
   80ec4:	00082b94 	.word	0x00082b94
   80ec8:	00082bae 	.word	0x00082bae
   80ecc:	00082bc4 	.word	0x00082bc4
   80ed0:	00082be0 	.word	0x00082be0

00080ed4 <_UsageFault.isra.5>:
 *
 * See _FaultDump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t _UsageFault(const NANO_ESF *esf)
   80ed4:	b510      	push	{r4, lr}
	u32_t reason = _NANO_ERR_HW_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****\n");

	/* bits are sticky: they stack and must be reset */
	if (SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) {
   80ed6:	4c19      	ldr	r4, [pc, #100]	; (80f3c <_UsageFault.isra.5+0x68>)
	PR_FAULT_INFO("***** USAGE FAULT *****\n");
   80ed8:	4819      	ldr	r0, [pc, #100]	; (80f40 <_UsageFault.isra.5+0x6c>)
   80eda:	f7ff fe83 	bl	80be4 <printk>
	if (SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) {
   80ede:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80ee0:	019a      	lsls	r2, r3, #6
   80ee2:	d502      	bpl.n	80eea <_UsageFault.isra.5+0x16>
		PR_FAULT_INFO("  Division by zero\n");
   80ee4:	4817      	ldr	r0, [pc, #92]	; (80f44 <_UsageFault.isra.5+0x70>)
   80ee6:	f7ff fe7d 	bl	80be4 <printk>
	}
	if (SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) {
   80eea:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80eec:	01db      	lsls	r3, r3, #7
   80eee:	d502      	bpl.n	80ef6 <_UsageFault.isra.5+0x22>
		PR_FAULT_INFO("  Unaligned memory access\n");
   80ef0:	4815      	ldr	r0, [pc, #84]	; (80f48 <_UsageFault.isra.5+0x74>)
   80ef2:	f7ff fe77 	bl	80be4 <printk>
		 */
		reason = _NANO_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_HW_STACK_PROTECTION */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if (SCB->CFSR & SCB_CFSR_NOCP_Msk) {
   80ef6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80ef8:	0318      	lsls	r0, r3, #12
   80efa:	d502      	bpl.n	80f02 <_UsageFault.isra.5+0x2e>
		PR_FAULT_INFO("  No coprocessor instructions\n");
   80efc:	4813      	ldr	r0, [pc, #76]	; (80f4c <_UsageFault.isra.5+0x78>)
   80efe:	f7ff fe71 	bl	80be4 <printk>
	}
	if (SCB->CFSR & SCB_CFSR_INVPC_Msk) {
   80f02:	4c0e      	ldr	r4, [pc, #56]	; (80f3c <_UsageFault.isra.5+0x68>)
   80f04:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80f06:	0359      	lsls	r1, r3, #13
   80f08:	d502      	bpl.n	80f10 <_UsageFault.isra.5+0x3c>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC\n");
   80f0a:	4811      	ldr	r0, [pc, #68]	; (80f50 <_UsageFault.isra.5+0x7c>)
   80f0c:	f7ff fe6a 	bl	80be4 <printk>
	}
	if (SCB->CFSR & SCB_CFSR_INVSTATE_Msk) {
   80f10:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80f12:	039a      	lsls	r2, r3, #14
   80f14:	d502      	bpl.n	80f1c <_UsageFault.isra.5+0x48>
		PR_FAULT_INFO("  Illegal use of the EPSR\n");
   80f16:	480f      	ldr	r0, [pc, #60]	; (80f54 <_UsageFault.isra.5+0x80>)
   80f18:	f7ff fe64 	bl	80be4 <printk>
	}
	if (SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) {
   80f1c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   80f1e:	03db      	lsls	r3, r3, #15
   80f20:	d502      	bpl.n	80f28 <_UsageFault.isra.5+0x54>
		PR_FAULT_INFO("  Attempt to execute undefined instruction\n");
   80f22:	480d      	ldr	r0, [pc, #52]	; (80f58 <_UsageFault.isra.5+0x84>)
   80f24:	f7ff fe5e 	bl	80be4 <printk>
	}

	/* clear USFR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   80f28:	4a04      	ldr	r2, [pc, #16]	; (80f3c <_UsageFault.isra.5+0x68>)

	return reason;
}
   80f2a:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   80f2c:	6a93      	ldr	r3, [r2, #40]	; 0x28
   80f2e:	ea6f 4303 	mvn.w	r3, r3, lsl #16
   80f32:	ea6f 4313 	mvn.w	r3, r3, lsr #16
   80f36:	6293      	str	r3, [r2, #40]	; 0x28
}
   80f38:	bd10      	pop	{r4, pc}
   80f3a:	bf00      	nop
   80f3c:	e000ed00 	.word	0xe000ed00
   80f40:	00082d59 	.word	0x00082d59
   80f44:	00082d72 	.word	0x00082d72
   80f48:	00082d86 	.word	0x00082d86
   80f4c:	00082da1 	.word	0x00082da1
   80f50:	00082dc0 	.word	0x00082dc0
   80f54:	00082de6 	.word	0x00082de6
   80f58:	00082e01 	.word	0x00082e01

00080f5c <_Fault>:
 *
 * Note: exc_return argument shall only be used by the Fault handler if we are
 * running a Secure Firmware.
 */
void _Fault(NANO_ESF *esf, u32_t exc_return)
{
   80f5c:	b538      	push	{r3, r4, r5, lr}
	u32_t reason;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   80f5e:	4c27      	ldr	r4, [pc, #156]	; (80ffc <_Fault+0xa0>)
{
   80f60:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   80f62:	6863      	ldr	r3, [r4, #4]
   80f64:	f3c3 0308 	ubfx	r3, r3, #0, #9
	switch (fault) {
   80f68:	1eda      	subs	r2, r3, #3
   80f6a:	2a09      	cmp	r2, #9
   80f6c:	d83a      	bhi.n	80fe4 <_Fault+0x88>
   80f6e:	e8df f002 	tbb	[pc, r2]
   80f72:	3305      	.short	0x3305
   80f74:	39393035 	.word	0x39393035
   80f78:	37393939 	.word	0x37393939
	PR_FAULT_INFO("***** HARD FAULT *****\n");
   80f7c:	4820      	ldr	r0, [pc, #128]	; (81000 <_Fault+0xa4>)
   80f7e:	f7ff fe31 	bl	80be4 <printk>
	if (SCB->HFSR & SCB_HFSR_VECTTBL_Msk) {
   80f82:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   80f84:	079a      	lsls	r2, r3, #30
   80f86:	d503      	bpl.n	80f90 <_Fault+0x34>
		PR_EXC("  Bus fault on vector table read\n");
   80f88:	481e      	ldr	r0, [pc, #120]	; (81004 <_Fault+0xa8>)
	PR_FAULT_INFO(
   80f8a:	f7ff fe2b 	bl	80be4 <printk>
   80f8e:	e002      	b.n	80f96 <_Fault+0x3a>
	} else if (SCB->HFSR & SCB_HFSR_FORCED_Msk) {
   80f90:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   80f92:	005b      	lsls	r3, r3, #1
   80f94:	d405      	bmi.n	80fa2 <_Fault+0x46>
	PR_FAULT_INFO(
   80f96:	2000      	movs	r0, #0
	}

#if defined(CONFIG_ARM_SECURE_FIRMWARE)
_exit_fatal:
#endif
	_NanoFatalErrorHandler(reason, esf);
   80f98:	4629      	mov	r1, r5
}
   80f9a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	_NanoFatalErrorHandler(reason, esf);
   80f9e:	f000 b8f5 	b.w	8118c <_NanoFatalErrorHandler>
		PR_EXC("  Fault escalation (see below)\n");
   80fa2:	4819      	ldr	r0, [pc, #100]	; (81008 <_Fault+0xac>)
   80fa4:	f7ff fe1e 	bl	80be4 <printk>
		if (SCB_MMFSR) {
   80fa8:	4b18      	ldr	r3, [pc, #96]	; (8100c <_Fault+0xb0>)
   80faa:	781b      	ldrb	r3, [r3, #0]
   80fac:	b12b      	cbz	r3, 80fba <_Fault+0x5e>
			reason = _MpuFault(esf, 1);
   80fae:	2001      	movs	r0, #1
		reason = _MpuFault(esf, 0);
   80fb0:	f7ff ff10 	bl	80dd4 <_MpuFault.isra.2>
	if (reason == _NANO_ERR_RECOVERABLE) {
   80fb4:	2806      	cmp	r0, #6
   80fb6:	d1ef      	bne.n	80f98 <_Fault+0x3c>
   80fb8:	bd38      	pop	{r3, r4, r5, pc}
		} else if (SCB_BFSR) {
   80fba:	4b15      	ldr	r3, [pc, #84]	; (81010 <_Fault+0xb4>)
   80fbc:	781b      	ldrb	r3, [r3, #0]
   80fbe:	b11b      	cbz	r3, 80fc8 <_Fault+0x6c>
			reason = _BusFault(esf, 1);
   80fc0:	2001      	movs	r0, #1
		reason = _BusFault(esf, 0);
   80fc2:	f7ff ff43 	bl	80e4c <_BusFault.isra.3>
   80fc6:	e7f5      	b.n	80fb4 <_Fault+0x58>
		} else if (SCB_UFSR) {
   80fc8:	4b12      	ldr	r3, [pc, #72]	; (81014 <_Fault+0xb8>)
   80fca:	881b      	ldrh	r3, [r3, #0]
   80fcc:	b29b      	uxth	r3, r3
   80fce:	2b00      	cmp	r3, #0
   80fd0:	d0e1      	beq.n	80f96 <_Fault+0x3a>
		reason = _UsageFault(esf);
   80fd2:	f7ff ff7f 	bl	80ed4 <_UsageFault.isra.5>
   80fd6:	e7ed      	b.n	80fb4 <_Fault+0x58>
		reason = _MpuFault(esf, 0);
   80fd8:	2000      	movs	r0, #0
   80fda:	e7e9      	b.n	80fb0 <_Fault+0x54>
		reason = _BusFault(esf, 0);
   80fdc:	2000      	movs	r0, #0
   80fde:	e7f0      	b.n	80fc2 <_Fault+0x66>
	PR_FAULT_INFO(
   80fe0:	480d      	ldr	r0, [pc, #52]	; (81018 <_Fault+0xbc>)
   80fe2:	e7d2      	b.n	80f8a <_Fault+0x2e>
	PR_FAULT_INFO("***** %s %d) *****\n",
   80fe4:	480d      	ldr	r0, [pc, #52]	; (8101c <_Fault+0xc0>)
   80fe6:	490e      	ldr	r1, [pc, #56]	; (81020 <_Fault+0xc4>)
   80fe8:	f1a3 0210 	sub.w	r2, r3, #16
   80fec:	2b0f      	cmp	r3, #15
   80fee:	bfd8      	it	le
   80ff0:	4601      	movle	r1, r0
   80ff2:	480c      	ldr	r0, [pc, #48]	; (81024 <_Fault+0xc8>)
   80ff4:	f7ff fdf6 	bl	80be4 <printk>
   80ff8:	e7cd      	b.n	80f96 <_Fault+0x3a>
   80ffa:	bf00      	nop
   80ffc:	e000ed00 	.word	0xe000ed00
   81000:	00082c27 	.word	0x00082c27
   81004:	00082c3f 	.word	0x00082c3f
   81008:	00082c61 	.word	0x00082c61
   8100c:	e000ed28 	.word	0xe000ed28
   81010:	e000ed29 	.word	0xe000ed29
   81014:	e000ed2a 	.word	0xe000ed2a
   81018:	00082c81 	.word	0x00082c81
   8101c:	00082bf9 	.word	0x00082bf9
   81020:	00082c0e 	.word	0x00082c0e
   81024:	00082cb8 	.word	0x00082cb8

00081028 <_FaultInit>:
 */
void _FaultInit(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   81028:	4a02      	ldr	r2, [pc, #8]	; (81034 <_FaultInit+0xc>)
   8102a:	6953      	ldr	r3, [r2, #20]
   8102c:	f043 0310 	orr.w	r3, r3, #16
   81030:	6153      	str	r3, [r2, #20]
   81032:	4770      	bx	lr
   81034:	e000ed00 	.word	0xe000ed00

00081038 <_arch_irq_enable>:
 *
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   81038:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
   8103a:	2b00      	cmp	r3, #0
   8103c:	db08      	blt.n	81050 <_arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   8103e:	2201      	movs	r2, #1
   81040:	f000 001f 	and.w	r0, r0, #31
   81044:	fa02 f000 	lsl.w	r0, r2, r0
   81048:	4a02      	ldr	r2, [pc, #8]	; (81054 <_arch_irq_enable+0x1c>)
   8104a:	095b      	lsrs	r3, r3, #5
   8104c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
   81050:	4770      	bx	lr
   81052:	bf00      	nop
   81054:	e000e100 	.word	0xe000e100

00081058 <_irq_priority_set>:
	} else {
		prio += _IRQ_PRIO_OFFSET;
	}
#else
	ARG_UNUSED(flags);
	prio += _IRQ_PRIO_OFFSET;
   81058:	1c4b      	adds	r3, r1, #1
	/* The last priority level is also used by PendSV exception, but
	 * allow other interrupts to use the same level, even if it ends up
	 * affecting performance (can still be useful on systems with a
	 * reduced set of priorities, like Cortex-M0/M0+).
	 */
	__ASSERT(prio <= ((1 << CONFIG_NUM_IRQ_PRIO_BITS) - 1),
   8105a:	2b0f      	cmp	r3, #15
{
   8105c:	b510      	push	{r4, lr}
   8105e:	460c      	mov	r4, r1
	__ASSERT(prio <= ((1 << CONFIG_NUM_IRQ_PRIO_BITS) - 1),
   81060:	d90b      	bls.n	8107a <_irq_priority_set+0x22>
   81062:	4a0f      	ldr	r2, [pc, #60]	; (810a0 <_irq_priority_set+0x48>)
   81064:	490f      	ldr	r1, [pc, #60]	; (810a4 <_irq_priority_set+0x4c>)
   81066:	2372      	movs	r3, #114	; 0x72
   81068:	480f      	ldr	r0, [pc, #60]	; (810a8 <_irq_priority_set+0x50>)
   8106a:	f7ff fdbb 	bl	80be4 <printk>
   8106e:	220f      	movs	r2, #15
   81070:	4621      	mov	r1, r4
   81072:	480e      	ldr	r0, [pc, #56]	; (810ac <_irq_priority_set+0x54>)
   81074:	f7ff fdb6 	bl	80be4 <printk>
   81078:	e7fe      	b.n	81078 <_irq_priority_set+0x20>
		 "invalid priority %d! values must be less than %d\n",
		 prio - _IRQ_PRIO_OFFSET,
		 (1 << CONFIG_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   8107a:	b242      	sxtb	r2, r0
  if ((int32_t)(IRQn) >= 0)
   8107c:	2a00      	cmp	r2, #0
   8107e:	ea4f 1303 	mov.w	r3, r3, lsl #4
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   81082:	bfa9      	itett	ge
   81084:	f102 4260 	addge.w	r2, r2, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   81088:	4a09      	ldrlt	r2, [pc, #36]	; (810b0 <_irq_priority_set+0x58>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   8108a:	b2db      	uxtbge	r3, r3
   8108c:	f502 4261 	addge.w	r2, r2, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   81090:	bfbb      	ittet	lt
   81092:	f000 000f 	andlt.w	r0, r0, #15
   81096:	b2db      	uxtblt	r3, r3
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   81098:	f882 3300 	strbge.w	r3, [r2, #768]	; 0x300
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   8109c:	5413      	strblt	r3, [r2, r0]
   8109e:	bd10      	pop	{r4, pc}
   810a0:	00082e2d 	.word	0x00082e2d
   810a4:	00082e5d 	.word	0x00082e5d
   810a8:	00082995 	.word	0x00082995
   810ac:	00082e74 	.word	0x00082e74
   810b0:	e000ed14 	.word	0xe000ed14

000810b4 <_irq_spurious>:
 * @return N/A
 */
void _irq_spurious(void *unused)
{
	ARG_UNUSED(unused);
	__reserved();
   810b4:	f000 b856 	b.w	81164 <__bus_fault>

000810b8 <_new_thread>:

void _new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		 size_t stackSize, k_thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned int options)
{
   810b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   810bc:	9e09      	ldr	r6, [sp, #36]	; 0x24
   810be:	4605      	mov	r5, r0
	char *pStackMem = K_THREAD_STACK_BUFFER(stack);

	_ASSERT_VALID_PRIO(priority, pEntry);
   810c0:	2e0f      	cmp	r6, #15
{
   810c2:	460c      	mov	r4, r1
   810c4:	4690      	mov	r8, r2
   810c6:	461f      	mov	r7, r3
	_ASSERT_VALID_PRIO(priority, pEntry);
   810c8:	d122      	bne.n	81110 <_new_thread+0x58>
   810ca:	4b1a      	ldr	r3, [pc, #104]	; (81134 <_new_thread+0x7c>)
   810cc:	429f      	cmp	r7, r3
   810ce:	d123      	bne.n	81118 <_new_thread+0x60>
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
   810d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   810d2:	2204      	movs	r2, #4
   810d4:	4631      	mov	r1, r6
   810d6:	4628      	mov	r0, r5
   810d8:	f001 fbf8 	bl	828cc <_init_thread_base>

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
   810dc:	2300      	movs	r3, #0

	_new_thread_init(thread, pStackMem, stackEnd - pStackMem, priority,
			 options);

	/* carve the thread entry struct from the "base" of the stack */
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
   810de:	f1a8 0120 	sub.w	r1, r8, #32
#else
	pInitCtx->pc = (u32_t)_thread_entry;
#endif

	/* force ARM mode by clearing LSB of address */
	pInitCtx->pc &= 0xfffffffe;
   810e2:	4a15      	ldr	r2, [pc, #84]	; (81138 <_new_thread+0x80>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
   810e4:	4421      	add	r1, r4
   810e6:	f021 0107 	bic.w	r1, r1, #7
	pInitCtx->pc &= 0xfffffffe;
   810ea:	f022 0201 	bic.w	r2, r2, #1
   810ee:	652b      	str	r3, [r5, #80]	; 0x50
	thread->fn_abort = NULL;
   810f0:	656b      	str	r3, [r5, #84]	; 0x54
   810f2:	618a      	str	r2, [r1, #24]

	pInitCtx->a1 = (u32_t)pEntry;
	pInitCtx->a2 = (u32_t)parameter1;
   810f4:	9a06      	ldr	r2, [sp, #24]
	pInitCtx->a1 = (u32_t)pEntry;
   810f6:	600f      	str	r7, [r1, #0]
	pInitCtx->a2 = (u32_t)parameter1;
   810f8:	604a      	str	r2, [r1, #4]
	pInitCtx->a3 = (u32_t)parameter2;
   810fa:	9a07      	ldr	r2, [sp, #28]
   810fc:	608a      	str	r2, [r1, #8]
	pInitCtx->a4 = (u32_t)parameter3;
   810fe:	9a08      	ldr	r2, [sp, #32]
   81100:	60ca      	str	r2, [r1, #12]
	pInitCtx->xpsr =
   81102:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   81106:	61ca      	str	r2, [r1, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
   81108:	64e9      	str	r1, [r5, #76]	; 0x4c
	thread->arch.basepri = 0;
   8110a:	662b      	str	r3, [r5, #96]	; 0x60
   8110c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	_ASSERT_VALID_PRIO(priority, pEntry);
   81110:	f106 0310 	add.w	r3, r6, #16
   81114:	2b1e      	cmp	r3, #30
   81116:	d9db      	bls.n	810d0 <_new_thread+0x18>
   81118:	233f      	movs	r3, #63	; 0x3f
   8111a:	4a08      	ldr	r2, [pc, #32]	; (8113c <_new_thread+0x84>)
   8111c:	4908      	ldr	r1, [pc, #32]	; (81140 <_new_thread+0x88>)
   8111e:	4809      	ldr	r0, [pc, #36]	; (81144 <_new_thread+0x8c>)
   81120:	f7ff fd60 	bl	80be4 <printk>
   81124:	f06f 030f 	mvn.w	r3, #15
   81128:	220e      	movs	r2, #14
   8112a:	4631      	mov	r1, r6
   8112c:	4806      	ldr	r0, [pc, #24]	; (81148 <_new_thread+0x90>)
   8112e:	f7ff fd59 	bl	80be4 <printk>
   81132:	e7fe      	b.n	81132 <_new_thread+0x7a>
   81134:	0008193d 	.word	0x0008193d
   81138:	00080521 	.word	0x00080521
   8113c:	00082ea6 	.word	0x00082ea6
   81140:	00082ed2 	.word	0x00082ed2
   81144:	00082995 	.word	0x00082995
   81148:	00082f6e 	.word	0x00082f6e

0008114c <_CpuIdleInit>:
 *
 * void _CpuIdleInit (void);
 */

SECTION_FUNC(TEXT, _CpuIdleInit)
	ldr r1, =_SCB_SCR
   8114c:	4901      	ldr	r1, [pc, #4]	; (81154 <_CpuIdleInit+0x8>)
	movs.n r2, #_SCR_INIT_BITS
   8114e:	2210      	movs	r2, #16
	str r2, [r1]
   81150:	600a      	str	r2, [r1, #0]
	bx lr
   81152:	4770      	bx	lr
	ldr r1, =_SCB_SCR
   81154:	e000ed10 	.word	0xe000ed10

00081158 <k_cpu_idle>:

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
   81158:	4040      	eors	r0, r0
	msr BASEPRI, r0
   8115a:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
   8115e:	bf30      	wfi

	bx lr
   81160:	4770      	bx	lr
   81162:	bf00      	nop

00081164 <__bus_fault>:
	mrs r0, MSP
_stack_frame_endif:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* force unlock interrupts */
	eors.n r0, r0
   81164:	4040      	eors	r0, r0
	msr BASEPRI, r0
   81166:	f380 8811 	msr	BASEPRI, r0

#if !defined(CONFIG_ARM_SECURE_FIRMWARE)
	/* this checks to see if we are in a nested exception */
	ldr ip, =_SCS_ICSR
   8116a:	f8df c01c 	ldr.w	ip, [pc, #28]	; 81188 <__bus_fault+0x24>
	ldr ip, [ip]
   8116e:	f8dc c000 	ldr.w	ip, [ip]
	ands.w ip, #_SCS_ICSR_RETTOBASE
   81172:	f41c 6c00 	ands.w	ip, ip, #2048	; 0x800

	ite eq			/* is the RETTOBASE bit zero ? */
   81176:	bf0c      	ite	eq
		mrseq r0, MSP	/* if so, we're not returning to thread mode,
   81178:	f3ef 8008 	mrseq	r0, MSP
				 * thus this is a nested exception: the stack
				 * frame is on the MSP */
		mrsne r0, PSP	/* if not, we are returning to thread mode, thus
   8117c:	f3ef 8009 	mrsne	r0, PSP
	 * located in the LR. Therefore, we supply the LR value as an
	 * argument to the fault handler.
	 */
	mov r1, lr
#endif /* CONFIG_ARM_SECURE_FIRMWARE */
	push {lr}
   81180:	b500      	push	{lr}
	bl _Fault
   81182:	f7ff feeb 	bl	80f5c <_Fault>

	pop {pc}
   81186:	bd00      	pop	{pc}
	ldr ip, =_SCS_ICSR
   81188:	e000ed04 	.word	0xe000ed04

0008118c <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
   8118c:	b538      	push	{r3, r4, r5, lr}
   8118e:	4604      	mov	r4, r0
   81190:	460d      	mov	r5, r1
	switch (reason) {
   81192:	2805      	cmp	r0, #5
   81194:	d81a      	bhi.n	811cc <_NanoFatalErrorHandler+0x40>
   81196:	e8df f000 	tbb	[pc, r0]
   8119a:	1903      	.short	0x1903
   8119c:	17151319 	.word	0x17151319
	case _NANO_ERR_HW_EXCEPTION:
		printk("***** Hardware exception *****\n");
   811a0:	480d      	ldr	r0, [pc, #52]	; (811d8 <_NanoFatalErrorHandler+0x4c>)
		printk("***** Stack Check Fail! *****\n");
		break;
#endif /* CONFIG_STACK_CANARIES */

	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
   811a2:	f7ff fd1f 	bl	80be4 <printk>
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t);
   811a6:	f001 f937 	bl	82418 <_impl_k_current_get>

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
		break;
	}
	printk("Current thread ID = %p\n"
   811aa:	69aa      	ldr	r2, [r5, #24]
   811ac:	4601      	mov	r1, r0
   811ae:	480b      	ldr	r0, [pc, #44]	; (811dc <_NanoFatalErrorHandler+0x50>)
   811b0:	f7ff fd18 	bl	80be4 <printk>
	 * to respond to the error.  The decisions as to what responses are
	 * appropriate to the various errors are something the customer must
	 * decide.
	 */

	_SysFatalErrorHandler(reason, pEsf);
   811b4:	4629      	mov	r1, r5
   811b6:	4620      	mov	r0, r4
}
   811b8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	_SysFatalErrorHandler(reason, pEsf);
   811bc:	f000 b81c 	b.w	811f8 <_SysFatalErrorHandler>
		printk("**** Kernel Allocation Failure! ****\n");
   811c0:	4807      	ldr	r0, [pc, #28]	; (811e0 <_NanoFatalErrorHandler+0x54>)
   811c2:	e7ee      	b.n	811a2 <_NanoFatalErrorHandler+0x16>
		printk("***** Kernel OOPS! *****\n");
   811c4:	4807      	ldr	r0, [pc, #28]	; (811e4 <_NanoFatalErrorHandler+0x58>)
   811c6:	e7ec      	b.n	811a2 <_NanoFatalErrorHandler+0x16>
		printk("***** Kernel Panic! *****\n");
   811c8:	4807      	ldr	r0, [pc, #28]	; (811e8 <_NanoFatalErrorHandler+0x5c>)
   811ca:	e7ea      	b.n	811a2 <_NanoFatalErrorHandler+0x16>
		printk("**** Unknown Fatal Error %d! ****\n", reason);
   811cc:	4601      	mov	r1, r0
   811ce:	4807      	ldr	r0, [pc, #28]	; (811ec <_NanoFatalErrorHandler+0x60>)
   811d0:	f7ff fd08 	bl	80be4 <printk>
		break;
   811d4:	e7e7      	b.n	811a6 <_NanoFatalErrorHandler+0x1a>
   811d6:	bf00      	nop
   811d8:	00082f9d 	.word	0x00082f9d
   811dc:	0008303b 	.word	0x0008303b
   811e0:	00082fbd 	.word	0x00082fbd
   811e4:	00082fe3 	.word	0x00082fe3
   811e8:	00082ffd 	.word	0x00082ffd
   811ec:	00083018 	.word	0x00083018

000811f0 <_do_kernel_oops>:

void _do_kernel_oops(const NANO_ESF *esf)
{
   811f0:	4601      	mov	r1, r0
	_NanoFatalErrorHandler(esf->r0, esf);
   811f2:	6800      	ldr	r0, [r0, #0]
   811f4:	f7ff bfca 	b.w	8118c <_NanoFatalErrorHandler>

000811f8 <_SysFatalErrorHandler>:
#ifdef CONFIG_STACK_SENTINEL
	if (reason == _NANO_ERR_STACK_CHK_FAIL) {
		goto hang_system;
	}
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
   811f8:	2805      	cmp	r0, #5
{
   811fa:	b510      	push	{r4, lr}
	if (reason == _NANO_ERR_KERNEL_PANIC) {
   811fc:	d00c      	beq.n	81218 <_SysFatalErrorHandler+0x20>
		goto hang_system;
	}
	if (k_is_in_isr() || _is_thread_essential()) {
   811fe:	f001 fa87 	bl	82710 <k_is_in_isr>
   81202:	b160      	cbz	r0, 8121e <_SysFatalErrorHandler+0x26>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
   81204:	f001 fa84 	bl	82710 <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
   81208:	4b0c      	ldr	r3, [pc, #48]	; (8123c <_SysFatalErrorHandler+0x44>)
   8120a:	490d      	ldr	r1, [pc, #52]	; (81240 <_SysFatalErrorHandler+0x48>)
   8120c:	2800      	cmp	r0, #0
   8120e:	bf08      	it	eq
   81210:	4619      	moveq	r1, r3
   81212:	480c      	ldr	r0, [pc, #48]	; (81244 <_SysFatalErrorHandler+0x4c>)
   81214:	f7ff fce6 	bl	80be4 <printk>
#else
	ARG_UNUSED(reason);
#endif

	for (;;) {
		k_cpu_idle();
   81218:	f7ff ff9e 	bl	81158 <k_cpu_idle>
   8121c:	e7fc      	b.n	81218 <_SysFatalErrorHandler+0x20>
	if (k_is_in_isr() || _is_thread_essential()) {
   8121e:	f001 fa87 	bl	82730 <_is_thread_essential>
   81222:	2800      	cmp	r0, #0
   81224:	d1ee      	bne.n	81204 <_SysFatalErrorHandler+0xc>
	printk("Fatal fault in thread %p! Aborting.\n", _current);
   81226:	4c08      	ldr	r4, [pc, #32]	; (81248 <_SysFatalErrorHandler+0x50>)
   81228:	4808      	ldr	r0, [pc, #32]	; (8124c <_SysFatalErrorHandler+0x54>)
   8122a:	68a1      	ldr	r1, [r4, #8]
   8122c:	f7ff fcda 	bl	80be4 <printk>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread);
   81230:	68a0      	ldr	r0, [r4, #8]
	}
	CODE_UNREACHABLE;
}
   81232:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   81236:	f000 b80b 	b.w	81250 <_impl_k_thread_abort>
   8123a:	bf00      	nop
   8123c:	0008307b 	.word	0x0008307b
   81240:	00083077 	.word	0x00083077
   81244:	0008308c 	.word	0x0008308c
   81248:	20070350 	.word	0x20070350
   8124c:	000830ac 	.word	0x000830ac

00081250 <_impl_k_thread_abort>:
#include <misc/__assert.h>

extern void _k_thread_single_abort(struct k_thread *thread);

void _impl_k_thread_abort(k_tid_t thread)
{
   81250:	b538      	push	{r3, r4, r5, lr}
   81252:	4605      	mov	r5, r0
	__asm__ volatile(
   81254:	f04f 0310 	mov.w	r3, #16
   81258:	f3ef 8411 	mrs	r4, BASEPRI
   8125c:	f383 8811 	msr	BASEPRI, r3
	unsigned int key;

	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
   81260:	7a03      	ldrb	r3, [r0, #8]
   81262:	07db      	lsls	r3, r3, #31
   81264:	d509      	bpl.n	8127a <_impl_k_thread_abort+0x2a>
   81266:	2325      	movs	r3, #37	; 0x25
   81268:	4a10      	ldr	r2, [pc, #64]	; (812ac <_impl_k_thread_abort+0x5c>)
   8126a:	4911      	ldr	r1, [pc, #68]	; (812b0 <_impl_k_thread_abort+0x60>)
   8126c:	4811      	ldr	r0, [pc, #68]	; (812b4 <_impl_k_thread_abort+0x64>)
   8126e:	f7ff fcb9 	bl	80be4 <printk>
   81272:	4811      	ldr	r0, [pc, #68]	; (812b8 <_impl_k_thread_abort+0x68>)
   81274:	f7ff fcb6 	bl	80be4 <printk>
   81278:	e7fe      	b.n	81278 <_impl_k_thread_abort+0x28>
		 "essential thread aborted");

	_k_thread_single_abort(thread);
   8127a:	f001 fa93 	bl	827a4 <_k_thread_single_abort>
	_thread_monitor_exit(thread);

	if (_current == thread) {
   8127e:	4b0f      	ldr	r3, [pc, #60]	; (812bc <_impl_k_thread_abort+0x6c>)
   81280:	689b      	ldr	r3, [r3, #8]
   81282:	429d      	cmp	r5, r3
   81284:	d10d      	bne.n	812a2 <_impl_k_thread_abort+0x52>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
   81286:	4b0e      	ldr	r3, [pc, #56]	; (812c0 <_impl_k_thread_abort+0x70>)
   81288:	685a      	ldr	r2, [r3, #4]
   8128a:	f3c2 0208 	ubfx	r2, r2, #0, #9
   8128e:	b922      	cbnz	r2, 8129a <_impl_k_thread_abort+0x4a>
extern unsigned int __swap(unsigned int key);

static inline unsigned int _Swap(unsigned int key)
{
	_check_stack_sentinel();
	_update_time_slice_before_swap();
   81290:	f000 fffe 	bl	82290 <_update_time_slice_before_swap>

	return __swap(key);
   81294:	4620      	mov	r0, r4
   81296:	f7ff fd51 	bl	80d3c <__swap>
			_Swap(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   8129a:	685a      	ldr	r2, [r3, #4]
   8129c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   812a0:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule(key);
   812a2:	4620      	mov	r0, r4
}
   812a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	_reschedule(key);
   812a8:	f000 bdd4 	b.w	81e54 <_reschedule>
   812ac:	000830d1 	.word	0x000830d1
   812b0:	00083103 	.word	0x00083103
   812b4:	00082995 	.word	0x00082995
   812b8:	0008312b 	.word	0x0008312b
   812bc:	20070350 	.word	0x20070350
   812c0:	e000ed00 	.word	0xe000ed00

000812c4 <_isr_wrapper>:
 *
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

	push {lr}		/* lr is now the first item on the stack */
   812c4:	b500      	push	{lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
#endif

	mrs r0, IPSR	/* get exception number */
   812c6:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   812ca:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   812ce:	ea4f 00c0 	mov.w	r0, r0, lsl #3
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
   812d2:	4904      	ldr	r1, [pc, #16]	; (812e4 <_isr_wrapper+0x20>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   812d4:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   812d6:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r4 regs */
#endif
	blx r3		/* call ISR */
   812d8:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {lr}
   812da:	f85d eb04 	ldr.w	lr, [sp], #4
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* exception return is done in _IntExit() */
	b _IntExit
   812de:	f7ff bd0d 	b.w	80cfc <_ExcExit>
   812e2:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
   812e4:	000800f4 	.word	0x000800f4

000812e8 <__reset>:

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   812e8:	2010      	movs	r0, #16
    msr BASEPRI, r0
   812ea:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialisation.
     */
    ldr r0, =_interrupt_stack
   812ee:	4806      	ldr	r0, [pc, #24]	; (81308 <__reset+0x20>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
   812f0:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   812f4:	1840      	adds	r0, r0, r1
    msr PSP, r0
   812f6:	f380 8809 	msr	PSP, r0
    movs.n r0, #2	/* switch to using PSP (bit1 of CONTROL reg) */
   812fa:	2002      	movs	r0, #2
    msr CONTROL, r0
   812fc:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
    */
    isb
   81300:	f3bf 8f6f 	isb	sy

    b _PrepC
   81304:	f000 b806 	b.w	81314 <_PrepC>
    ldr r0, =_interrupt_stack
   81308:	20071488 	.word	0x20071488

0008130c <_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(_SysNmiOnReset)

SECTION_FUNC(TEXT, _SysNmiOnReset)
    wfi
   8130c:	bf30      	wfi
    b _SysNmiOnReset
   8130e:	f7ff bffd 	b.w	8130c <_SysNmiOnReset>
   81312:	bf00      	nop

00081314 <_PrepC>:

#ifdef CONFIG_BOOT_TIME_MEASUREMENT
	extern u64_t __start_time_stamp;
#endif
void _PrepC(void)
{
   81314:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   81316:	4b08      	ldr	r3, [pc, #32]	; (81338 <_PrepC+0x24>)
   81318:	4a08      	ldr	r2, [pc, #32]	; (8133c <_PrepC+0x28>)
   8131a:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   8131e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   81322:	6093      	str	r3, [r2, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   81324:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   81328:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
	enable_floating_point();
	_bss_zero();
   8132c:	f000 fb10 	bl	81950 <_bss_zero>
	_data_copy();
   81330:	f000 fb18 	bl	81964 <_data_copy>
#ifdef CONFIG_BOOT_TIME_MEASUREMENT
	__start_time_stamp = 0;
#endif
	_Cstart();
   81334:	f000 fb3c 	bl	819b0 <_Cstart>
   81338:	00080000 	.word	0x00080000
   8133c:	e000ed00 	.word	0xe000ed00

00081340 <__nmi>:
 *
 * @return N/A
 */

void __nmi(void)
{
   81340:	b508      	push	{r3, lr}
	handler();
   81342:	f7ff ffe3 	bl	8130c <_SysNmiOnReset>
	_ExcExit();
}
   81346:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	_ExcExit();
   8134a:	f7ff bcd7 	b.w	80cfc <_ExcExit>

0008134e <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
   8134e:	3801      	subs	r0, #1
   81350:	3901      	subs	r1, #1
	while ((*s1 == *s2) && (*s1 != '\0')) {
   81352:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   81356:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   8135a:	4293      	cmp	r3, r2
   8135c:	d102      	bne.n	81364 <strcmp+0x16>
   8135e:	2b00      	cmp	r3, #0
   81360:	d1f7      	bne.n	81352 <strcmp+0x4>
   81362:	461a      	mov	r2, r3
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
   81364:	1a98      	subs	r0, r3, r2
   81366:	4770      	bx	lr

00081368 <memcpy>:
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
   81368:	ea81 0300 	eor.w	r3, r1, r0
   8136c:	f013 0f03 	tst.w	r3, #3
{
   81370:	b570      	push	{r4, r5, r6, lr}
   81372:	4603      	mov	r3, r0
	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
   81374:	d00b      	beq.n	8138e <memcpy+0x26>
   81376:	3b01      	subs	r3, #1
   81378:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
   8137a:	4291      	cmp	r1, r2
   8137c:	d11b      	bne.n	813b6 <memcpy+0x4e>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   8137e:	bd70      	pop	{r4, r5, r6, pc}
			if (n == 0) {
   81380:	2a00      	cmp	r2, #0
   81382:	d0fc      	beq.n	8137e <memcpy+0x16>
			*(d_byte++) = *(s_byte++);
   81384:	f811 4b01 	ldrb.w	r4, [r1], #1
			n--;
   81388:	3a01      	subs	r2, #1
			*(d_byte++) = *(s_byte++);
   8138a:	f803 4b01 	strb.w	r4, [r3], #1
		while (((unsigned int)d_byte) & 0x3) {
   8138e:	079c      	lsls	r4, r3, #30
   81390:	d1f6      	bne.n	81380 <memcpy+0x18>
   81392:	460d      	mov	r5, r1
   81394:	1f1e      	subs	r6, r3, #4
   81396:	1b54      	subs	r4, r2, r5
   81398:	440c      	add	r4, r1
		while (n >= sizeof(unsigned int)) {
   8139a:	2c03      	cmp	r4, #3
   8139c:	d806      	bhi.n	813ac <memcpy+0x44>
   8139e:	f022 0403 	bic.w	r4, r2, #3
   813a2:	4421      	add	r1, r4
   813a4:	4423      	add	r3, r4
   813a6:	f002 0203 	and.w	r2, r2, #3
   813aa:	e7e4      	b.n	81376 <memcpy+0xe>
			*(d_word++) = *(s_word++);
   813ac:	f855 4b04 	ldr.w	r4, [r5], #4
   813b0:	f846 4f04 	str.w	r4, [r6, #4]!
   813b4:	e7ef      	b.n	81396 <memcpy+0x2e>
		*(d_byte++) = *(s_byte++);
   813b6:	f811 4b01 	ldrb.w	r4, [r1], #1
   813ba:	f803 4f01 	strb.w	r4, [r3, #1]!
   813be:	e7dc      	b.n	8137a <memcpy+0x12>

000813c0 <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   813c0:	4603      	mov	r3, r0
{
   813c2:	b570      	push	{r4, r5, r6, lr}
	unsigned char c_byte = (unsigned char)c;
   813c4:	b2c9      	uxtb	r1, r1

	while (((unsigned int)d_byte) & 0x3) {
   813c6:	079c      	lsls	r4, r3, #30
   813c8:	d111      	bne.n	813ee <memset+0x2e>
	unsigned int c_word = (unsigned int)(unsigned char)c;

	c_word |= c_word << 8;
	c_word |= c_word << 16;

	while (n >= sizeof(unsigned int)) {
   813ca:	461e      	mov	r6, r3
	c_word |= c_word << 8;
   813cc:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
   813d0:	ea44 4404 	orr.w	r4, r4, r4, lsl #16
   813d4:	1b95      	subs	r5, r2, r6
   813d6:	441d      	add	r5, r3
	while (n >= sizeof(unsigned int)) {
   813d8:	2d03      	cmp	r5, #3
   813da:	d80e      	bhi.n	813fa <memset+0x3a>
   813dc:	f022 0403 	bic.w	r4, r2, #3
   813e0:	4423      	add	r3, r4
   813e2:	f002 0203 	and.w	r2, r2, #3
   813e6:	441a      	add	r2, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
   813e8:	4293      	cmp	r3, r2
   813ea:	d109      	bne.n	81400 <memset+0x40>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   813ec:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
   813ee:	2a00      	cmp	r2, #0
   813f0:	d0fc      	beq.n	813ec <memset+0x2c>
		*(d_byte++) = c_byte;
   813f2:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   813f6:	3a01      	subs	r2, #1
   813f8:	e7e5      	b.n	813c6 <memset+0x6>
		*(d_word++) = c_word;
   813fa:	f846 4b04 	str.w	r4, [r6], #4
   813fe:	e7e9      	b.n	813d4 <memset+0x14>
		*(d_byte++) = c_byte;
   81400:	f803 1b01 	strb.w	r1, [r3], #1
   81404:	e7f0      	b.n	813e8 <memset+0x28>
	...

00081408 <pinmux_init>:
	PIOC->PIO_PUDR = ~(pull_up[N_PIOC]);
	PIOD->PIO_PUDR = ~(pull_up[N_PIOD]);
}

static int pinmux_init(struct device *port)
{
   81408:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	ab_select[N_PIOA] = PIOA->PIO_ABSR;
   8140c:	4842      	ldr	r0, [pc, #264]	; (81518 <pinmux_init+0x110>)
	ab_select[N_PIOB] = PIOB->PIO_ABSR;
   8140e:	4943      	ldr	r1, [pc, #268]	; (8151c <pinmux_init+0x114>)
	ab_select[N_PIOA] = PIOA->PIO_ABSR;
   81410:	6f03      	ldr	r3, [r0, #112]	; 0x70
{
   81412:	b08b      	sub	sp, #44	; 0x2c
	ab_select[N_PIOC] = PIOC->PIO_ABSR;
   81414:	4a42      	ldr	r2, [pc, #264]	; (81520 <pinmux_init+0x118>)
	ab_select[N_PIOA] = PIOA->PIO_ABSR;
   81416:	9303      	str	r3, [sp, #12]
	ab_select[N_PIOB] = PIOB->PIO_ABSR;
   81418:	6f0b      	ldr	r3, [r1, #112]	; 0x70
   8141a:	9304      	str	r3, [sp, #16]
	ab_select[N_PIOC] = PIOC->PIO_ABSR;
   8141c:	6f13      	ldr	r3, [r2, #112]	; 0x70
   8141e:	9305      	str	r3, [sp, #20]
	ab_select[N_PIOD] = PIOD->PIO_ABSR;
   81420:	4b40      	ldr	r3, [pc, #256]	; (81524 <pinmux_init+0x11c>)
   81422:	6f1c      	ldr	r4, [r3, #112]	; 0x70
	output_en[N_PIOA] = PIOA->PIO_OSR;
   81424:	f8d0 c018 	ldr.w	ip, [r0, #24]
	ab_select[N_PIOD] = PIOD->PIO_ABSR;
   81428:	9406      	str	r4, [sp, #24]
	output_en[N_PIOB] = PIOB->PIO_OSR;
   8142a:	f8d1 e018 	ldr.w	lr, [r1, #24]
	output_en[N_PIOC] = PIOC->PIO_OSR;
   8142e:	6994      	ldr	r4, [r2, #24]
	output_en[N_PIOB] &= ~(tmp);
   81430:	f42e 1ef0 	bic.w	lr, lr, #1966080	; 0x1e0000
	output_en[N_PIOC] = PIOC->PIO_OSR;
   81434:	9400      	str	r4, [sp, #0]
	output_en[N_PIOD] = PIOD->PIO_OSR;
   81436:	699c      	ldr	r4, [r3, #24]
	pio_ctrl[N_PIOA] = PIOA->PIO_PSR;
   81438:	6886      	ldr	r6, [r0, #8]
	output_en[N_PIOD] = PIOD->PIO_OSR;
   8143a:	9401      	str	r4, [sp, #4]
	pio_ctrl[N_PIOB] = PIOB->PIO_PSR;
   8143c:	688c      	ldr	r4, [r1, #8]
	pio_ctrl[N_PIOC] = PIOC->PIO_PSR;
   8143e:	f8d2 b008 	ldr.w	fp, [r2, #8]
	pio_ctrl[N_PIOD] = PIOD->PIO_PSR;
   81442:	f8d3 a008 	ldr.w	sl, [r3, #8]
	pull_up[N_PIOA] = ~(PIOA->PIO_PUSR);
   81446:	6e85      	ldr	r5, [r0, #104]	; 0x68
	pio_ctrl[N_PIOA] &= ~(BIT(17) | BIT(18));
   81448:	f426 26c0 	bic.w	r6, r6, #393216	; 0x60000
	pull_up[N_PIOA] = ~(PIOA->PIO_PUSR);
   8144c:	9507      	str	r5, [sp, #28]
	pull_up[N_PIOB] = ~(PIOB->PIO_PUSR);
   8144e:	6e8d      	ldr	r5, [r1, #104]	; 0x68
	pull_up[N_PIOC] = ~(PIOC->PIO_PUSR);
   81450:	f8d2 9068 	ldr.w	r9, [r2, #104]	; 0x68
	pull_up[N_PIOD] = ~(PIOD->PIO_PUSR);
   81454:	f8d3 8068 	ldr.w	r8, [r3, #104]	; 0x68
	pull_up[N_PIOC] = ~(PIOC->PIO_PUSR);
   81458:	ea6f 0709 	mvn.w	r7, r9
   8145c:	9708      	str	r7, [sp, #32]
	pull_up[N_PIOD] = ~(PIOD->PIO_PUSR);
   8145e:	ea6f 0708 	mvn.w	r7, r8
   81462:	9709      	str	r7, [sp, #36]	; 0x24
	pio_ctrl[N_PIOA] |= tmp;
   81464:	4f30      	ldr	r7, [pc, #192]	; (81528 <pinmux_init+0x120>)
	pio_ctrl[N_PIOA] &= ~(BIT(17) | BIT(18));
   81466:	f426 7640 	bic.w	r6, r6, #768	; 0x300
	pio_ctrl[N_PIOA] |= tmp;
   8146a:	4337      	orrs	r7, r6
   8146c:	9702      	str	r7, [sp, #8]
	output_en[N_PIOA] &= ~(tmp);
   8146e:	4e2f      	ldr	r6, [pc, #188]	; (8152c <pinmux_init+0x124>)
	pull_up[N_PIOA] &= ~(tmp);
   81470:	9f07      	ldr	r7, [sp, #28]
	output_en[N_PIOA] &= ~(tmp);
   81472:	ea0c 0c06 	and.w	ip, ip, r6
	pull_up[N_PIOA] &= ~(tmp);
   81476:	ea26 0607 	bic.w	r6, r6, r7
	PIOA->PIO_ABSR = ab_select[N_PIOA];
   8147a:	9f03      	ldr	r7, [sp, #12]
	pio_ctrl[N_PIOB] &= ~(BIT(12) | BIT(13));
   8147c:	f024 4470 	bic.w	r4, r4, #4026531840	; 0xf0000000
	PIOA->PIO_ABSR = ab_select[N_PIOA];
   81480:	6707      	str	r7, [r0, #112]	; 0x70
	PIOB->PIO_ABSR = ab_select[N_PIOB];
   81482:	9f04      	ldr	r7, [sp, #16]
	pio_ctrl[N_PIOB] &= ~(BIT(12) | BIT(13));
   81484:	f424 5440 	bic.w	r4, r4, #12288	; 0x3000
	PIOB->PIO_ABSR = ab_select[N_PIOB];
   81488:	670f      	str	r7, [r1, #112]	; 0x70
	PIOC->PIO_ABSR = ab_select[N_PIOC];
   8148a:	9f05      	ldr	r7, [sp, #20]
	pio_ctrl[N_PIOB] |= tmp;
   8148c:	f444 14f0 	orr.w	r4, r4, #1966080	; 0x1e0000
	PIOC->PIO_ABSR = ab_select[N_PIOC];
   81490:	6717      	str	r7, [r2, #112]	; 0x70
	PIOD->PIO_ABSR = ab_select[N_PIOD];
   81492:	9f06      	ldr	r7, [sp, #24]
	pull_up[N_PIOB] = ~(PIOB->PIO_PUSR);
   81494:	43ed      	mvns	r5, r5
	PIOD->PIO_ABSR = ab_select[N_PIOD];
   81496:	671f      	str	r7, [r3, #112]	; 0x70
	PIOA->PIO_OER = output_en[N_PIOA];
   81498:	f8c0 c010 	str.w	ip, [r0, #16]
	PIOB->PIO_OER = output_en[N_PIOB];
   8149c:	f8c1 e010 	str.w	lr, [r1, #16]
	PIOA->PIO_ODR = ~(output_en[N_PIOA]);
   814a0:	ea6f 0c0c 	mvn.w	ip, ip
	PIOB->PIO_ODR = ~(output_en[N_PIOB]);
   814a4:	ea6f 0e0e 	mvn.w	lr, lr
	PIOC->PIO_OER = output_en[N_PIOC];
   814a8:	9f00      	ldr	r7, [sp, #0]
	pull_up[N_PIOB] &= ~(tmp);
   814aa:	f425 15f0 	bic.w	r5, r5, #1966080	; 0x1e0000
	PIOC->PIO_OER = output_en[N_PIOC];
   814ae:	6117      	str	r7, [r2, #16]
	PIOD->PIO_OER = output_en[N_PIOD];
   814b0:	9f01      	ldr	r7, [sp, #4]
   814b2:	611f      	str	r7, [r3, #16]
	PIOC->PIO_ODR = ~(output_en[N_PIOC]);
   814b4:	9f00      	ldr	r7, [sp, #0]
	PIOA->PIO_ODR = ~(output_en[N_PIOA]);
   814b6:	f8c0 c014 	str.w	ip, [r0, #20]
	PIOB->PIO_ODR = ~(output_en[N_PIOB]);
   814ba:	f8c1 e014 	str.w	lr, [r1, #20]
	PIOC->PIO_ODR = ~(output_en[N_PIOC]);
   814be:	ea6f 0e07 	mvn.w	lr, r7
	PIOD->PIO_ODR = ~(output_en[N_PIOD]);
   814c2:	9f01      	ldr	r7, [sp, #4]
	PIOC->PIO_ODR = ~(output_en[N_PIOC]);
   814c4:	f8c2 e014 	str.w	lr, [r2, #20]
	PIOD->PIO_ODR = ~(output_en[N_PIOD]);
   814c8:	ea6f 0e07 	mvn.w	lr, r7
	PIOA->PIO_PER = pio_ctrl[N_PIOA];
   814cc:	9f02      	ldr	r7, [sp, #8]
	PIOD->PIO_ODR = ~(output_en[N_PIOD]);
   814ce:	f8c3 e014 	str.w	lr, [r3, #20]
	PIOA->PIO_PER = pio_ctrl[N_PIOA];
   814d2:	6007      	str	r7, [r0, #0]
	PIOA->PIO_PDR = ~(pio_ctrl[N_PIOA]);
   814d4:	9f02      	ldr	r7, [sp, #8]
	PIOB->PIO_PER = pio_ctrl[N_PIOB];
   814d6:	600c      	str	r4, [r1, #0]
	PIOA->PIO_PDR = ~(pio_ctrl[N_PIOA]);
   814d8:	43ff      	mvns	r7, r7
	PIOB->PIO_PDR = ~(pio_ctrl[N_PIOB]);
   814da:	43e4      	mvns	r4, r4
	PIOC->PIO_PER = pio_ctrl[N_PIOC];
   814dc:	f8c2 b000 	str.w	fp, [r2]
	PIOD->PIO_PER = pio_ctrl[N_PIOD];
   814e0:	f8c3 a000 	str.w	sl, [r3]
	PIOA->PIO_PDR = ~(pio_ctrl[N_PIOA]);
   814e4:	6047      	str	r7, [r0, #4]
	PIOB->PIO_PDR = ~(pio_ctrl[N_PIOB]);
   814e6:	604c      	str	r4, [r1, #4]
	PIOC->PIO_PDR = ~(pio_ctrl[N_PIOC]);
   814e8:	ea6f 040b 	mvn.w	r4, fp
   814ec:	6054      	str	r4, [r2, #4]
	PIOD->PIO_PDR = ~(pio_ctrl[N_PIOD]);
   814ee:	ea6f 040a 	mvn.w	r4, sl
   814f2:	605c      	str	r4, [r3, #4]
	PIOA->PIO_PUER = pull_up[N_PIOA];
   814f4:	6646      	str	r6, [r0, #100]	; 0x64
	PIOA->PIO_PUDR = ~(pull_up[N_PIOA]);
   814f6:	43f6      	mvns	r6, r6
	PIOC->PIO_PUER = pull_up[N_PIOC];
   814f8:	9c08      	ldr	r4, [sp, #32]
	PIOB->PIO_PUER = pull_up[N_PIOB];
   814fa:	664d      	str	r5, [r1, #100]	; 0x64
	PIOC->PIO_PUER = pull_up[N_PIOC];
   814fc:	6654      	str	r4, [r2, #100]	; 0x64
	PIOD->PIO_PUER = pull_up[N_PIOD];
   814fe:	9c09      	ldr	r4, [sp, #36]	; 0x24
	PIOB->PIO_PUDR = ~(pull_up[N_PIOB]);
   81500:	43ed      	mvns	r5, r5
	PIOD->PIO_PUER = pull_up[N_PIOD];
   81502:	665c      	str	r4, [r3, #100]	; 0x64
	PIOA->PIO_PUDR = ~(pull_up[N_PIOA]);
   81504:	6606      	str	r6, [r0, #96]	; 0x60
	ARG_UNUSED(port);

	__pinmux_defaults();

	return 0;
}
   81506:	2000      	movs	r0, #0
	PIOB->PIO_PUDR = ~(pull_up[N_PIOB]);
   81508:	660d      	str	r5, [r1, #96]	; 0x60
	PIOC->PIO_PUDR = ~(pull_up[N_PIOC]);
   8150a:	f8c2 9060 	str.w	r9, [r2, #96]	; 0x60
	PIOD->PIO_PUDR = ~(pull_up[N_PIOD]);
   8150e:	f8c3 8060 	str.w	r8, [r3, #96]	; 0x60
}
   81512:	b00b      	add	sp, #44	; 0x2c
   81514:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   81518:	400e0e00 	.word	0x400e0e00
   8151c:	400e1000 	.word	0x400e1000
   81520:	400e1200 	.word	0x400e1200
   81524:	400e1400 	.word	0x400e1400
   81528:	01c1005c 	.word	0x01c1005c
   8152c:	fe3effa3 	.word	0xfe3effa3

00081530 <gpio_sam3_write>:
 * @return 0 if successful, failed otherwise
 */
static int gpio_sam3_write(struct device *dev, int access_op,
			   u32_t pin, u32_t value)
{
	const struct gpio_sam3_config *cfg = dev->config->config_info;
   81530:	6800      	ldr	r0, [r0, #0]
{
   81532:	b510      	push	{r4, lr}
	const struct gpio_sam3_config *cfg = dev->config->config_info;
   81534:	6880      	ldr	r0, [r0, #8]

	switch (access_op) {
   81536:	b121      	cbz	r1, 81542 <gpio_sam3_write+0x12>
   81538:	2901      	cmp	r1, #1
   8153a:	d00b      	beq.n	81554 <gpio_sam3_write+0x24>
			/* clear all pins */
			cfg->port->PIO_CODR = 0xFFFFFFFF;
		}
		break;
	default:
		return -ENOTSUP;
   8153c:	f06f 0122 	mvn.w	r1, #34	; 0x22
   81540:	e004      	b.n	8154c <gpio_sam3_write+0x1c>
   81542:	6804      	ldr	r4, [r0, #0]
   81544:	2001      	movs	r0, #1
			cfg->port->PIO_SODR = BIT(pin);
   81546:	4090      	lsls	r0, r2
		if (value) {
   81548:	b113      	cbz	r3, 81550 <gpio_sam3_write+0x20>
			cfg->port->PIO_SODR = BIT(pin);
   8154a:	6320      	str	r0, [r4, #48]	; 0x30
	}

	return 0;
}
   8154c:	4608      	mov	r0, r1
   8154e:	bd10      	pop	{r4, pc}
			cfg->port->PIO_CODR = BIT(pin);
   81550:	6360      	str	r0, [r4, #52]	; 0x34
   81552:	e7fb      	b.n	8154c <gpio_sam3_write+0x1c>
   81554:	6802      	ldr	r2, [r0, #0]
   81556:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
		if (value) {
   8155a:	b113      	cbz	r3, 81562 <gpio_sam3_write+0x32>
			cfg->port->PIO_SODR = 0xFFFFFFFF;
   8155c:	6311      	str	r1, [r2, #48]	; 0x30
	return 0;
   8155e:	2100      	movs	r1, #0
   81560:	e7f4      	b.n	8154c <gpio_sam3_write+0x1c>
			cfg->port->PIO_CODR = 0xFFFFFFFF;
   81562:	6351      	str	r1, [r2, #52]	; 0x34
   81564:	e7fb      	b.n	8155e <gpio_sam3_write+0x2e>

00081566 <gpio_sam3_read>:
 * @return 0 if successful, failed otherwise
 */
static int gpio_sam3_read(struct device *dev, int access_op,
				       u32_t pin, u32_t *value)
{
	const struct gpio_sam3_config *cfg = dev->config->config_info;
   81566:	6800      	ldr	r0, [r0, #0]
{
   81568:	b510      	push	{r4, lr}

	*value = cfg->port->PIO_PDSR;
   8156a:	6880      	ldr	r0, [r0, #8]
   8156c:	6800      	ldr	r0, [r0, #0]
   8156e:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
   81570:	601c      	str	r4, [r3, #0]

	switch (access_op) {
   81572:	b131      	cbz	r1, 81582 <gpio_sam3_read+0x1c>
   81574:	2901      	cmp	r1, #1
		*value = (*value >> pin) & 0x01;
		break;
	case GPIO_ACCESS_BY_PORT:
		break;
	default:
		return -ENOTSUP;
   81576:	bf0c      	ite	eq
   81578:	2100      	moveq	r1, #0
   8157a:	f06f 0122 	mvnne.w	r1, #34	; 0x22
	}

	return 0;
}
   8157e:	4608      	mov	r0, r1
   81580:	bd10      	pop	{r4, pc}
		*value = (*value >> pin) & 0x01;
   81582:	40d4      	lsrs	r4, r2
   81584:	f004 0401 	and.w	r4, r4, #1
   81588:	601c      	str	r4, [r3, #0]
		break;
   8158a:	e7f8      	b.n	8157e <gpio_sam3_read+0x18>

0008158c <gpio_sam3_enable_callback>:
				     int access_op, u32_t pin)
{
	const struct gpio_sam3_config *cfg = dev->config->config_info;
	u32_t mask;

	switch (access_op) {
   8158c:	b121      	cbz	r1, 81598 <gpio_sam3_enable_callback+0xc>
   8158e:	2901      	cmp	r1, #1
   81590:	d00d      	beq.n	815ae <gpio_sam3_enable_callback+0x22>
		break;
	case GPIO_ACCESS_BY_PORT:
		mask = 0xFFFFFFFF;
		break;
	default:
		return -ENOTSUP;
   81592:	f06f 0022 	mvn.w	r0, #34	; 0x22
	}

	cfg->port->PIO_IER |= mask;

	return 0;
}
   81596:	4770      	bx	lr
		mask = BIT(pin);
   81598:	2301      	movs	r3, #1
   8159a:	fa03 f202 	lsl.w	r2, r3, r2
	const struct gpio_sam3_config *cfg = dev->config->config_info;
   8159e:	6803      	ldr	r3, [r0, #0]
	return 0;
   815a0:	2000      	movs	r0, #0
	cfg->port->PIO_IER |= mask;
   815a2:	689b      	ldr	r3, [r3, #8]
   815a4:	681b      	ldr	r3, [r3, #0]
   815a6:	6c19      	ldr	r1, [r3, #64]	; 0x40
   815a8:	430a      	orrs	r2, r1
   815aa:	641a      	str	r2, [r3, #64]	; 0x40
	return 0;
   815ac:	4770      	bx	lr
		mask = 0xFFFFFFFF;
   815ae:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   815b2:	e7f4      	b.n	8159e <gpio_sam3_enable_callback+0x12>

000815b4 <gpio_sam3_disable_callback>:
				      int access_op, u32_t pin)
{
	const struct gpio_sam3_config *cfg = dev->config->config_info;
	u32_t mask;

	switch (access_op) {
   815b4:	b121      	cbz	r1, 815c0 <gpio_sam3_disable_callback+0xc>
   815b6:	2901      	cmp	r1, #1
   815b8:	d00d      	beq.n	815d6 <gpio_sam3_disable_callback+0x22>
		break;
	case GPIO_ACCESS_BY_PORT:
		mask = 0xFFFFFFFF;
		break;
	default:
		return -ENOTSUP;
   815ba:	f06f 0022 	mvn.w	r0, #34	; 0x22
	}

	cfg->port->PIO_IDR |= mask;

	return 0;
}
   815be:	4770      	bx	lr
		mask = BIT(pin);
   815c0:	2301      	movs	r3, #1
   815c2:	fa03 f202 	lsl.w	r2, r3, r2
	const struct gpio_sam3_config *cfg = dev->config->config_info;
   815c6:	6803      	ldr	r3, [r0, #0]
	return 0;
   815c8:	2000      	movs	r0, #0
	cfg->port->PIO_IDR |= mask;
   815ca:	689b      	ldr	r3, [r3, #8]
   815cc:	681b      	ldr	r3, [r3, #0]
   815ce:	6c59      	ldr	r1, [r3, #68]	; 0x44
   815d0:	430a      	orrs	r2, r1
   815d2:	645a      	str	r2, [r3, #68]	; 0x44
	return 0;
   815d4:	4770      	bx	lr
		mask = 0xFFFFFFFF;
   815d6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   815da:	e7f4      	b.n	815c6 <gpio_sam3_disable_callback+0x12>

000815dc <gpio_sam3_init>:
 *
 * @param dev Device struct
 * @return 0 if successful, failed otherwise.
 */
static int gpio_sam3_init(struct device *dev)
{
   815dc:	b508      	push	{r3, lr}
	const struct gpio_sam3_config *cfg = dev->config->config_info;
   815de:	6803      	ldr	r3, [r0, #0]

	cfg->config_func(dev);
   815e0:	689b      	ldr	r3, [r3, #8]
   815e2:	685b      	ldr	r3, [r3, #4]
   815e4:	4798      	blx	r3

	return 0;
}
   815e6:	2000      	movs	r0, #0
   815e8:	bd08      	pop	{r3, pc}
	...

000815ec <gpio_sam3_config_a>:
		    &gpio_sam3_drv_api_funcs);

static void gpio_sam3_config_a(struct device *dev)
{
	/* Enable clock for PIO controller */
	PMC->PMC_PCER0 = BIT(ID_PIOA);
   815ec:	f44f 6200 	mov.w	r2, #2048	; 0x800
{
   815f0:	b508      	push	{r3, lr}
	PMC->PMC_PCER0 = BIT(ID_PIOA);
   815f2:	4b06      	ldr	r3, [pc, #24]	; (8160c <gpio_sam3_config_a+0x20>)

	IRQ_CONNECT(PIOA_IRQn, CONFIG_GPIO_ATMEL_SAM3_PORTA_IRQ_PRI,
   815f4:	200b      	movs	r0, #11
	PMC->PMC_PCER0 = BIT(ID_PIOA);
   815f6:	611a      	str	r2, [r3, #16]
	IRQ_CONNECT(PIOA_IRQn, CONFIG_GPIO_ATMEL_SAM3_PORTA_IRQ_PRI,
   815f8:	2103      	movs	r1, #3
   815fa:	2200      	movs	r2, #0
   815fc:	f7ff fd2c 	bl	81058 <_irq_priority_set>
		    gpio_sam3_isr, DEVICE_GET(gpio_sam3_a), 0);
	irq_enable(PIOA_IRQn);
}
   81600:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(PIOA_IRQn);
   81604:	200b      	movs	r0, #11
   81606:	f7ff bd17 	b.w	81038 <_arch_irq_enable>
   8160a:	bf00      	nop
   8160c:	400e0600 	.word	0x400e0600

00081610 <gpio_sam3_config_b>:
		    &gpio_sam3_drv_api_funcs);

static void gpio_sam3_config_b(struct device *dev)
{
	/* Enable clock for PIO controller */
	PMC->PMC_PCER0 = BIT(ID_PIOB);
   81610:	f44f 5280 	mov.w	r2, #4096	; 0x1000
{
   81614:	b508      	push	{r3, lr}
	PMC->PMC_PCER0 = BIT(ID_PIOB);
   81616:	4b06      	ldr	r3, [pc, #24]	; (81630 <gpio_sam3_config_b+0x20>)

	IRQ_CONNECT(PIOB_IRQn, CONFIG_GPIO_ATMEL_SAM3_PORTB_IRQ_PRI,
   81618:	200c      	movs	r0, #12
	PMC->PMC_PCER0 = BIT(ID_PIOB);
   8161a:	611a      	str	r2, [r3, #16]
	IRQ_CONNECT(PIOB_IRQn, CONFIG_GPIO_ATMEL_SAM3_PORTB_IRQ_PRI,
   8161c:	2103      	movs	r1, #3
   8161e:	2200      	movs	r2, #0
   81620:	f7ff fd1a 	bl	81058 <_irq_priority_set>
		    gpio_sam3_isr, DEVICE_GET(gpio_sam3_b), 0);
	irq_enable(PIOB_IRQn);
}
   81624:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(PIOB_IRQn);
   81628:	200c      	movs	r0, #12
   8162a:	f7ff bd05 	b.w	81038 <_arch_irq_enable>
   8162e:	bf00      	nop
   81630:	400e0600 	.word	0x400e0600

00081634 <gpio_sam3_config_c>:
		    &gpio_sam3_drv_api_funcs);

static void gpio_sam3_config_c(struct device *dev)
{
	/* Enable clock for PIO controller */
	PMC->PMC_PCER0 = BIT(ID_PIOC);
   81634:	f44f 5200 	mov.w	r2, #8192	; 0x2000
{
   81638:	b508      	push	{r3, lr}
	PMC->PMC_PCER0 = BIT(ID_PIOC);
   8163a:	4b06      	ldr	r3, [pc, #24]	; (81654 <gpio_sam3_config_c+0x20>)

	IRQ_CONNECT(PIOC_IRQn, CONFIG_GPIO_ATMEL_SAM3_PORTC_IRQ_PRI,
   8163c:	200d      	movs	r0, #13
	PMC->PMC_PCER0 = BIT(ID_PIOC);
   8163e:	611a      	str	r2, [r3, #16]
	IRQ_CONNECT(PIOC_IRQn, CONFIG_GPIO_ATMEL_SAM3_PORTC_IRQ_PRI,
   81640:	2103      	movs	r1, #3
   81642:	2200      	movs	r2, #0
   81644:	f7ff fd08 	bl	81058 <_irq_priority_set>
		    gpio_sam3_isr, DEVICE_GET(gpio_sam3_c), 0);
	irq_enable(PIOC_IRQn);
}
   81648:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(PIOC_IRQn);
   8164c:	200d      	movs	r0, #13
   8164e:	f7ff bcf3 	b.w	81038 <_arch_irq_enable>
   81652:	bf00      	nop
   81654:	400e0600 	.word	0x400e0600

00081658 <gpio_sam3_config_d>:
		    &gpio_sam3_drv_api_funcs);

static void gpio_sam3_config_d(struct device *dev)
{
	/* Enable clock for PIO controller */
	PMC->PMC_PCER0 = BIT(ID_PIOD);
   81658:	f44f 4280 	mov.w	r2, #16384	; 0x4000
{
   8165c:	b508      	push	{r3, lr}
	PMC->PMC_PCER0 = BIT(ID_PIOD);
   8165e:	4b06      	ldr	r3, [pc, #24]	; (81678 <gpio_sam3_config_d+0x20>)

	IRQ_CONNECT(PIOD_IRQn, CONFIG_GPIO_ATMEL_SAM3_PORTD_IRQ_PRI,
   81660:	200e      	movs	r0, #14
	PMC->PMC_PCER0 = BIT(ID_PIOD);
   81662:	611a      	str	r2, [r3, #16]
	IRQ_CONNECT(PIOD_IRQn, CONFIG_GPIO_ATMEL_SAM3_PORTD_IRQ_PRI,
   81664:	2103      	movs	r1, #3
   81666:	2200      	movs	r2, #0
   81668:	f7ff fcf6 	bl	81058 <_irq_priority_set>
		    gpio_sam3_isr, DEVICE_GET(gpio_sam3_d), 0);
	irq_enable(PIOD_IRQn);
}
   8166c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(PIOD_IRQn);
   81670:	200e      	movs	r0, #14
   81672:	f7ff bce1 	b.w	81038 <_arch_irq_enable>
   81676:	bf00      	nop
   81678:	400e0600 	.word	0x400e0600

0008167c <gpio_sam3_isr>:
{
   8167c:	b570      	push	{r4, r5, r6, lr}
   8167e:	4605      	mov	r5, r0
	const struct gpio_sam3_config *cfg = dev->config->config_info;
   81680:	6803      	ldr	r3, [r0, #0]
	int_stat = cfg->port->PIO_ISR;
   81682:	689b      	ldr	r3, [r3, #8]
   81684:	681b      	ldr	r3, [r3, #0]
   81686:	6cde      	ldr	r6, [r3, #76]	; 0x4c
   81688:	6883      	ldr	r3, [r0, #8]
   8168a:	681c      	ldr	r4, [r3, #0]
					struct device *port,
					u32_t pins)
{
	struct gpio_callback *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
   8168c:	b1a4      	cbz	r4, 816b8 <gpio_sam3_isr+0x3c>
		if (cb->pin_mask & pins) {
   8168e:	68a3      	ldr	r3, [r4, #8]
   81690:	421e      	tst	r6, r3
   81692:	d00f      	beq.n	816b4 <gpio_sam3_isr+0x38>
			__ASSERT(cb->handler, "No callback handler!");
   81694:	6863      	ldr	r3, [r4, #4]
   81696:	b94b      	cbnz	r3, 816ac <gpio_sam3_isr+0x30>
   81698:	2333      	movs	r3, #51	; 0x33
   8169a:	4a08      	ldr	r2, [pc, #32]	; (816bc <gpio_sam3_isr+0x40>)
   8169c:	4908      	ldr	r1, [pc, #32]	; (816c0 <gpio_sam3_isr+0x44>)
   8169e:	4809      	ldr	r0, [pc, #36]	; (816c4 <gpio_sam3_isr+0x48>)
   816a0:	f7ff faa0 	bl	80be4 <printk>
   816a4:	4808      	ldr	r0, [pc, #32]	; (816c8 <gpio_sam3_isr+0x4c>)
   816a6:	f7ff fa9d 	bl	80be4 <printk>
   816aa:	e7fe      	b.n	816aa <gpio_sam3_isr+0x2e>
			cb->handler(port, cb, pins);
   816ac:	4632      	mov	r2, r6
   816ae:	4621      	mov	r1, r4
   816b0:	4628      	mov	r0, r5
   816b2:	4798      	blx	r3

#define SYS_SLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}

static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
	return node->next;
   816b4:	6824      	ldr	r4, [r4, #0]
   816b6:	e7e9      	b.n	8168c <gpio_sam3_isr+0x10>
   816b8:	bd70      	pop	{r4, r5, r6, pc}
   816ba:	bf00      	nop
   816bc:	00083180 	.word	0x00083180
   816c0:	000831af 	.word	0x000831af
   816c4:	00082995 	.word	0x00082995
   816c8:	000831bb 	.word	0x000831bb

000816cc <gpio_sam3_manage_callback>:
{
   816cc:	b508      	push	{r3, lr}
	struct gpio_sam3_runtime *context = dev->driver_data;
   816ce:	6883      	ldr	r3, [r0, #8]
	__ASSERT(callback, "No callback!");
   816d0:	b949      	cbnz	r1, 816e6 <gpio_sam3_manage_callback+0x1a>
   816d2:	231a      	movs	r3, #26
   816d4:	4a1a      	ldr	r2, [pc, #104]	; (81740 <gpio_sam3_manage_callback+0x74>)
   816d6:	491b      	ldr	r1, [pc, #108]	; (81744 <gpio_sam3_manage_callback+0x78>)
   816d8:	481b      	ldr	r0, [pc, #108]	; (81748 <gpio_sam3_manage_callback+0x7c>)
   816da:	f7ff fa83 	bl	80be4 <printk>
   816de:	481b      	ldr	r0, [pc, #108]	; (8174c <gpio_sam3_manage_callback+0x80>)
   816e0:	f7ff fa80 	bl	80be4 <printk>
   816e4:	e7fe      	b.n	816e4 <gpio_sam3_manage_callback+0x18>
	__ASSERT(callback->handler, "No callback handler!");
   816e6:	6848      	ldr	r0, [r1, #4]
   816e8:	b948      	cbnz	r0, 816fe <gpio_sam3_manage_callback+0x32>
   816ea:	231b      	movs	r3, #27
   816ec:	4a14      	ldr	r2, [pc, #80]	; (81740 <gpio_sam3_manage_callback+0x74>)
   816ee:	4918      	ldr	r1, [pc, #96]	; (81750 <gpio_sam3_manage_callback+0x84>)
   816f0:	4815      	ldr	r0, [pc, #84]	; (81748 <gpio_sam3_manage_callback+0x7c>)
   816f2:	f7ff fa77 	bl	80be4 <printk>
   816f6:	4817      	ldr	r0, [pc, #92]	; (81754 <gpio_sam3_manage_callback+0x88>)
   816f8:	f7ff fa74 	bl	80be4 <printk>
   816fc:	e7fe      	b.n	816fc <gpio_sam3_manage_callback+0x30>
   816fe:	6818      	ldr	r0, [r3, #0]
	if (set) {
   81700:	b172      	cbz	r2, 81720 <gpio_sam3_manage_callback+0x54>
}

static inline void z_snode_next_set(sys_snode_t *parent, sys_snode_t *child)
{
	parent->next = child;
   81702:	6008      	str	r0, [r1, #0]
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node);

Z_GENLIST_PREPEND(slist, snode);
   81704:	685a      	ldr	r2, [r3, #4]
	list->head = node;
   81706:	6019      	str	r1, [r3, #0]
Z_GENLIST_PREPEND(slist, snode);
   81708:	b902      	cbnz	r2, 8170c <gpio_sam3_manage_callback+0x40>
	list->tail = node;
   8170a:	6059      	str	r1, [r3, #4]
}
   8170c:	2000      	movs	r0, #0
   8170e:	bd08      	pop	{r3, pc}
	parent->next = child;
   81710:	6010      	str	r0, [r2, #0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode);
   81712:	6858      	ldr	r0, [r3, #4]
   81714:	4281      	cmp	r1, r0
	list->tail = node;
   81716:	bf08      	it	eq
   81718:	605a      	streq	r2, [r3, #4]
   8171a:	e00d      	b.n	81738 <gpio_sam3_manage_callback+0x6c>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode);
   8171c:	4602      	mov	r2, r0
   8171e:	6800      	ldr	r0, [r0, #0]
   81720:	2800      	cmp	r0, #0
   81722:	d0f3      	beq.n	8170c <gpio_sam3_manage_callback+0x40>
   81724:	4281      	cmp	r1, r0
   81726:	d1f9      	bne.n	8171c <gpio_sam3_manage_callback+0x50>
   81728:	6808      	ldr	r0, [r1, #0]
Z_GENLIST_REMOVE(slist, snode);
   8172a:	2a00      	cmp	r2, #0
   8172c:	d1f0      	bne.n	81710 <gpio_sam3_manage_callback+0x44>
   8172e:	685a      	ldr	r2, [r3, #4]
	list->head = node;
   81730:	6018      	str	r0, [r3, #0]
Z_GENLIST_REMOVE(slist, snode);
   81732:	4291      	cmp	r1, r2
   81734:	d100      	bne.n	81738 <gpio_sam3_manage_callback+0x6c>
	list->tail = node;
   81736:	6058      	str	r0, [r3, #4]
	parent->next = child;
   81738:	2300      	movs	r3, #0
   8173a:	600b      	str	r3, [r1, #0]
   8173c:	e7e6      	b.n	8170c <gpio_sam3_manage_callback+0x40>
   8173e:	bf00      	nop
   81740:	00083180 	.word	0x00083180
   81744:	000831d0 	.word	0x000831d0
   81748:	00082995 	.word	0x00082995
   8174c:	000831d9 	.word	0x000831d9
   81750:	000831e6 	.word	0x000831e6
   81754:	000831bb 	.word	0x000831bb

00081758 <_config.isra.4>:
	const struct gpio_sam3_config *cfg = dev->config->config_info;
   81758:	6883      	ldr	r3, [r0, #8]
	if ((flags & GPIO_DIR_MASK) == GPIO_DIR_OUT) {
   8175a:	f012 0f01 	tst.w	r2, #1
   8175e:	681b      	ldr	r3, [r3, #0]
		cfg->port->PIO_OER = mask;
   81760:	bf14      	ite	ne
   81762:	6119      	strne	r1, [r3, #16]
		cfg->port->PIO_ODR = mask;
   81764:	6159      	streq	r1, [r3, #20]
	if (flags & GPIO_INT) {
   81766:	0790      	lsls	r0, r2, #30
   81768:	d503      	bpl.n	81772 <_config.isra.4+0x1a>
		if (flags & GPIO_INT_DOUBLE_EDGE) {
   8176a:	0650      	lsls	r0, r2, #25
   8176c:	d510      	bpl.n	81790 <_config.isra.4+0x38>
			cfg->port->PIO_AIMDR = mask;
   8176e:	f8c3 10b4 	str.w	r1, [r3, #180]	; 0xb4
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
   81772:	f402 7040 	and.w	r0, r2, #768	; 0x300
   81776:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
		cfg->port->PIO_PUER = mask;
   8177a:	bf0c      	ite	eq
   8177c:	6659      	streq	r1, [r3, #100]	; 0x64
		cfg->port->PIO_PUDR = mask;
   8177e:	6619      	strne	r1, [r3, #96]	; 0x60
	if (flags & GPIO_INT_DEBOUNCE) {
   81780:	06d2      	lsls	r2, r2, #27
		cfg->port->PIO_DIFSR = mask;
   81782:	bf4c      	ite	mi
   81784:	f8c3 1084 	strmi.w	r1, [r3, #132]	; 0x84
		cfg->port->PIO_SCIFSR = mask;
   81788:	f8c3 1080 	strpl.w	r1, [r3, #128]	; 0x80
	cfg->port->PIO_PER = mask;
   8178c:	6019      	str	r1, [r3, #0]
   8178e:	4770      	bx	lr
			if (flags & GPIO_INT_EDGE) {
   81790:	0690      	lsls	r0, r2, #26
			cfg->port->PIO_AIMER = mask;
   81792:	f8c3 10b0 	str.w	r1, [r3, #176]	; 0xb0
				cfg->port->PIO_ESR = mask;
   81796:	bf4c      	ite	mi
   81798:	f8c3 10c0 	strmi.w	r1, [r3, #192]	; 0xc0
				cfg->port->PIO_LSR = mask;
   8179c:	f8c3 10c4 	strpl.w	r1, [r3, #196]	; 0xc4
			if (flags & GPIO_INT_ACTIVE_HIGH) {
   817a0:	0750      	lsls	r0, r2, #29
				cfg->port->PIO_REHLSR = mask;
   817a2:	bf4c      	ite	mi
   817a4:	f8c3 10d4 	strmi.w	r1, [r3, #212]	; 0xd4
				cfg->port->PIO_FELLSR = mask;
   817a8:	f8c3 10d0 	strpl.w	r1, [r3, #208]	; 0xd0
   817ac:	e7e1      	b.n	81772 <_config.isra.4+0x1a>

000817ae <gpio_sam3_config>:
{
   817ae:	b538      	push	{r3, r4, r5, lr}
   817b0:	4615      	mov	r5, r2
	switch (access_op) {
   817b2:	460c      	mov	r4, r1
{
   817b4:	461a      	mov	r2, r3
	switch (access_op) {
   817b6:	b121      	cbz	r1, 817c2 <gpio_sam3_config+0x14>
   817b8:	2901      	cmp	r1, #1
   817ba:	d009      	beq.n	817d0 <gpio_sam3_config+0x22>
		return -ENOTSUP;
   817bc:	f06f 0422 	mvn.w	r4, #34	; 0x22
   817c0:	e004      	b.n	817cc <gpio_sam3_config+0x1e>
		_config(dev, BIT(pin), flags);
   817c2:	2101      	movs	r1, #1
   817c4:	6800      	ldr	r0, [r0, #0]
   817c6:	40a9      	lsls	r1, r5
   817c8:	f7ff ffc6 	bl	81758 <_config.isra.4>
}
   817cc:	4620      	mov	r0, r4
   817ce:	bd38      	pop	{r3, r4, r5, pc}
		_config(dev, (0xFFFFFFFF), flags);
   817d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   817d4:	6800      	ldr	r0, [r0, #0]
   817d6:	f7ff ffbf 	bl	81758 <_config.isra.4>
	return 0;
   817da:	2400      	movs	r4, #0
		break;
   817dc:	e7f6      	b.n	817cc <gpio_sam3_config+0x1e>

000817de <uart_sam_poll_in>:
	return 0;
}

static int uart_sam_poll_in(struct device *dev, unsigned char *c)
{
	Uart *const uart = DEV_CFG(dev)->regs;
   817de:	6803      	ldr	r3, [r0, #0]
   817e0:	689b      	ldr	r3, [r3, #8]
   817e2:	681b      	ldr	r3, [r3, #0]

	if (!(uart->UART_SR & UART_SR_RXRDY)) {
   817e4:	695a      	ldr	r2, [r3, #20]
   817e6:	07d2      	lsls	r2, r2, #31
		return -EBUSY;
	}

	/* got a character */
	*c = (unsigned char)uart->UART_RHR;
   817e8:	bf43      	ittte	mi
   817ea:	699b      	ldrmi	r3, [r3, #24]

	return 0;
   817ec:	2000      	movmi	r0, #0
	*c = (unsigned char)uart->UART_RHR;
   817ee:	700b      	strbmi	r3, [r1, #0]
		return -EBUSY;
   817f0:	f06f 000f 	mvnpl.w	r0, #15
}
   817f4:	4770      	bx	lr

000817f6 <uart_sam_poll_out>:

static unsigned char uart_sam_poll_out(struct device *dev, unsigned char c)
{
	Uart *const uart = DEV_CFG(dev)->regs;
   817f6:	6803      	ldr	r3, [r0, #0]
   817f8:	689b      	ldr	r3, [r3, #8]
   817fa:	681b      	ldr	r3, [r3, #0]

	/* Wait for transmitter to be ready */
	while (!(uart->UART_SR & UART_SR_TXRDY))
   817fc:	695a      	ldr	r2, [r3, #20]
   817fe:	0792      	lsls	r2, r2, #30
   81800:	d5fc      	bpl.n	817fc <uart_sam_poll_out+0x6>
		;

	/* send a character */
	uart->UART_THR = (u32_t)c;
   81802:	61d9      	str	r1, [r3, #28]
	return c;
}
   81804:	4608      	mov	r0, r1
   81806:	4770      	bx	lr

00081808 <uart_sam_err_check>:

static int uart_sam_err_check(struct device *dev)
{
	volatile Uart * const uart = DEV_CFG(dev)->regs;
   81808:	6803      	ldr	r3, [r0, #0]
   8180a:	689b      	ldr	r3, [r3, #8]
   8180c:	681b      	ldr	r3, [r3, #0]
	int errors = 0;

	if (uart->UART_SR & UART_SR_OVRE) {
   8180e:	6958      	ldr	r0, [r3, #20]
		errors |= UART_ERROR_OVERRUN;
	}

	if (uart->UART_SR & UART_SR_PARE) {
   81810:	695a      	ldr	r2, [r3, #20]
		errors |= UART_ERROR_PARITY;
	}

	if (uart->UART_SR & UART_SR_FRAME) {
   81812:	695b      	ldr	r3, [r3, #20]
	if (uart->UART_SR & UART_SR_OVRE) {
   81814:	f3c0 1040 	ubfx	r0, r0, #5, #1
	if (uart->UART_SR & UART_SR_PARE) {
   81818:	0612      	lsls	r2, r2, #24
		errors |= UART_ERROR_PARITY;
   8181a:	bf48      	it	mi
   8181c:	f040 0002 	orrmi.w	r0, r0, #2
	if (uart->UART_SR & UART_SR_FRAME) {
   81820:	065b      	lsls	r3, r3, #25
		errors |= UART_ERROR_FRAMING;
   81822:	bf48      	it	mi
   81824:	f040 0004 	orrmi.w	r0, r0, #4
	}

	return errors;
}
   81828:	4770      	bx	lr
	...

0008182c <uart_sam_init>:
	const struct uart_sam_dev_cfg *const cfg = DEV_CFG(dev);
   8182c:	6803      	ldr	r3, [r0, #0]
{
   8182e:	b570      	push	{r4, r5, r6, lr}
	const struct uart_sam_dev_cfg *const cfg = DEV_CFG(dev);
   81830:	689d      	ldr	r5, [r3, #8]
	struct uart_sam_dev_data *const dev_data = DEV_DATA(dev);
   81832:	6886      	ldr	r6, [r0, #8]
	soc_pmc_peripheral_enable(cfg->periph_id);
   81834:	6868      	ldr	r0, [r5, #4]
	Uart *const uart = cfg->regs;
   81836:	682c      	ldr	r4, [r5, #0]
	soc_pmc_peripheral_enable(cfg->periph_id);
   81838:	f7fe fde4 	bl	80404 <soc_pmc_peripheral_enable>
	soc_gpio_configure(&cfg->pin_rx);
   8183c:	f105 0008 	add.w	r0, r5, #8
   81840:	f7fe fe04 	bl	8044c <soc_gpio_configure>
	soc_gpio_configure(&cfg->pin_tx);
   81844:	f105 0018 	add.w	r0, r5, #24
   81848:	f7fe fe00 	bl	8044c <soc_gpio_configure>
	uart->UART_CR =   UART_CR_RSTRX | UART_CR_RSTTX
   8184c:	f44f 73d6 	mov.w	r3, #428	; 0x1ac
   81850:	6023      	str	r3, [r4, #0]
	uart->UART_IDR = 0xFFFFFFFF;
   81852:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   81856:	60e3      	str	r3, [r4, #12]
	uart->UART_MR =   UART_MR_PAR_NO
   81858:	f44f 6300 	mov.w	r3, #2048	; 0x800
	retval = baudrate_set(uart, dev_data->baud_rate,
   8185c:	6832      	ldr	r2, [r6, #0]
	uart->UART_MR =   UART_MR_PAR_NO
   8185e:	6063      	str	r3, [r4, #4]
static int baudrate_set(Uart *const uart, u32_t baudrate,
			u32_t mck_freq_hz)
{
	u32_t divisor;

	__ASSERT(baudrate,
   81860:	b94a      	cbnz	r2, 81876 <uart_sam_init+0x4a>
   81862:	23c3      	movs	r3, #195	; 0xc3
   81864:	4a11      	ldr	r2, [pc, #68]	; (818ac <uart_sam_init+0x80>)
   81866:	4912      	ldr	r1, [pc, #72]	; (818b0 <uart_sam_init+0x84>)
   81868:	4812      	ldr	r0, [pc, #72]	; (818b4 <uart_sam_init+0x88>)
   8186a:	f7ff f9bb 	bl	80be4 <printk>
   8186e:	4812      	ldr	r0, [pc, #72]	; (818b8 <uart_sam_init+0x8c>)
   81870:	f7ff f9b8 	bl	80be4 <printk>
   81874:	e7fe      	b.n	81874 <uart_sam_init+0x48>
		 "baud rate has to be bigger than 0");
	__ASSERT(mck_freq_hz/16 >= baudrate,
   81876:	4b11      	ldr	r3, [pc, #68]	; (818bc <uart_sam_init+0x90>)
   81878:	429a      	cmp	r2, r3
   8187a:	d909      	bls.n	81890 <uart_sam_init+0x64>
   8187c:	23c5      	movs	r3, #197	; 0xc5
   8187e:	4a0b      	ldr	r2, [pc, #44]	; (818ac <uart_sam_init+0x80>)
   81880:	490f      	ldr	r1, [pc, #60]	; (818c0 <uart_sam_init+0x94>)
   81882:	480c      	ldr	r0, [pc, #48]	; (818b4 <uart_sam_init+0x88>)
   81884:	f7ff f9ae 	bl	80be4 <printk>
   81888:	480e      	ldr	r0, [pc, #56]	; (818c4 <uart_sam_init+0x98>)
   8188a:	f7ff f9ab 	bl	80be4 <printk>
   8188e:	e7fe      	b.n	8188e <uart_sam_init+0x62>
		 "MCK frequency is too small to set required baud rate");

	divisor = mck_freq_hz / 16 / baudrate;
   81890:	fbb3 f3f2 	udiv	r3, r3, r2

	if (divisor > 0xFFFF) {
   81894:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
		return -EINVAL;
	};

	uart->UART_BRGR = UART_BRGR_CD(divisor);
   81898:	bf3f      	itttt	cc
   8189a:	6223      	strcc	r3, [r4, #32]
	uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
   8189c:	2350      	movcc	r3, #80	; 0x50
	return 0;
   8189e:	2000      	movcc	r0, #0
	uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
   818a0:	6023      	strcc	r3, [r4, #0]
		return -EINVAL;
   818a2:	bf28      	it	cs
   818a4:	f06f 0015 	mvncs.w	r0, #21
}
   818a8:	bd70      	pop	{r4, r5, r6, pc}
   818aa:	bf00      	nop
   818ac:	00083238 	.word	0x00083238
   818b0:	0008329b 	.word	0x0008329b
   818b4:	00082995 	.word	0x00082995
   818b8:	00083267 	.word	0x00083267
   818bc:	00501bd0 	.word	0x00501bd0
   818c0:	00083289 	.word	0x00083289
   818c4:	000832a4 	.word	0x000832a4

000818c8 <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
   818c8:	b538      	push	{r3, r4, r5, lr}
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1];
   818ca:	4b08      	ldr	r3, [pc, #32]	; (818ec <_sys_device_do_config_level+0x24>)
   818cc:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   818d0:	3001      	adds	r0, #1
   818d2:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
   818d6:	4620      	mov	r0, r4
   818d8:	42a8      	cmp	r0, r5
   818da:	f104 040c 	add.w	r4, r4, #12
   818de:	d300      	bcc.n	818e2 <_sys_device_do_config_level+0x1a>
		struct device_config *device = info->config;

		device->init(info);
		_k_object_init(info);
	}
}
   818e0:	bd38      	pop	{r3, r4, r5, pc}
		device->init(info);
   818e2:	f854 3c0c 	ldr.w	r3, [r4, #-12]
   818e6:	685b      	ldr	r3, [r3, #4]
   818e8:	4798      	blx	r3
   818ea:	e7f4      	b.n	818d6 <_sys_device_do_config_level+0xe>
   818ec:	000832dc 	.word	0x000832dc

000818f0 <device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
   818f0:	4b10      	ldr	r3, [pc, #64]	; (81934 <device_get_binding+0x44>)
{
   818f2:	b570      	push	{r4, r5, r6, lr}
   818f4:	4605      	mov	r5, r0
   818f6:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
   818f8:	4c0f      	ldr	r4, [pc, #60]	; (81938 <device_get_binding+0x48>)
   818fa:	429c      	cmp	r4, r3
   818fc:	d104      	bne.n	81908 <device_get_binding+0x18>
   818fe:	4c0e      	ldr	r4, [pc, #56]	; (81938 <device_get_binding+0x48>)
		if (info->driver_api != NULL && info->config->name == name) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
   81900:	42b4      	cmp	r4, r6
   81902:	d109      	bne.n	81918 <device_get_binding+0x28>
		if (!strcmp(name, info->config->name)) {
			return info;
		}
	}

	return NULL;
   81904:	2400      	movs	r4, #0
   81906:	e012      	b.n	8192e <device_get_binding+0x3e>
		if (info->driver_api != NULL && info->config->name == name) {
   81908:	6862      	ldr	r2, [r4, #4]
   8190a:	b11a      	cbz	r2, 81914 <device_get_binding+0x24>
   8190c:	6822      	ldr	r2, [r4, #0]
   8190e:	6812      	ldr	r2, [r2, #0]
   81910:	42aa      	cmp	r2, r5
   81912:	d00c      	beq.n	8192e <device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
   81914:	340c      	adds	r4, #12
   81916:	e7f0      	b.n	818fa <device_get_binding+0xa>
		if (!info->driver_api) {
   81918:	6863      	ldr	r3, [r4, #4]
   8191a:	b90b      	cbnz	r3, 81920 <device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
   8191c:	340c      	adds	r4, #12
   8191e:	e7ef      	b.n	81900 <device_get_binding+0x10>
		if (!strcmp(name, info->config->name)) {
   81920:	6823      	ldr	r3, [r4, #0]
   81922:	4628      	mov	r0, r5
   81924:	6819      	ldr	r1, [r3, #0]
   81926:	f7ff fd12 	bl	8134e <strcmp>
   8192a:	2800      	cmp	r0, #0
   8192c:	d1f6      	bne.n	8191c <device_get_binding+0x2c>
}
   8192e:	4620      	mov	r0, r4
   81930:	bd70      	pop	{r4, r5, r6, pc}
   81932:	bf00      	nop
   81934:	20071d1c 	.word	0x20071d1c
   81938:	20071c98 	.word	0x20071c98

0008193c <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while ((0))
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
   8193c:	b508      	push	{r3, lr}
   8193e:	f04f 0210 	mov.w	r2, #16
   81942:	f3ef 8311 	mrs	r3, BASEPRI
   81946:	f382 8811 	msr	BASEPRI, r2
	k_cpu_idle();
   8194a:	f7ff fc05 	bl	81158 <k_cpu_idle>
   8194e:	e7f6      	b.n	8193e <idle+0x2>

00081950 <_bss_zero>:
 *
 * @return N/A
 */
void _bss_zero(void)
{
	memset(&__bss_start, 0,
   81950:	4802      	ldr	r0, [pc, #8]	; (8195c <_bss_zero+0xc>)
   81952:	4a03      	ldr	r2, [pc, #12]	; (81960 <_bss_zero+0x10>)
   81954:	2100      	movs	r1, #0
   81956:	1a12      	subs	r2, r2, r0
   81958:	f7ff bd32 	b.w	813c0 <memset>
   8195c:	20070000 	.word	0x20070000
   81960:	20070388 	.word	0x20070388

00081964 <_data_copy>:
 *
 * @return N/A
 */
void _data_copy(void)
{
	memcpy(&__data_ram_start, &__data_rom_start,
   81964:	4802      	ldr	r0, [pc, #8]	; (81970 <_data_copy+0xc>)
   81966:	4a03      	ldr	r2, [pc, #12]	; (81974 <_data_copy+0x10>)
   81968:	4903      	ldr	r1, [pc, #12]	; (81978 <_data_copy+0x14>)
   8196a:	1a12      	subs	r2, r2, r0
   8196c:	f7ff bcfc 	b.w	81368 <memcpy>
   81970:	20071c88 	.word	0x20071c88
   81974:	20071dcc 	.word	0x20071dcc
   81978:	000834ec 	.word	0x000834ec

0008197c <main>:
	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
}

void __weak main(void)
{
   8197c:	4770      	bx	lr
	...

00081980 <bg_thread_main>:
{
   81980:	b508      	push	{r3, lr}
	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   81982:	2002      	movs	r0, #2
   81984:	f7ff ffa0 	bl	818c8 <_sys_device_do_config_level>
	PRINT_BOOT_BANNER();
   81988:	4807      	ldr	r0, [pc, #28]	; (819a8 <bg_thread_main+0x28>)
   8198a:	f7ff f92b 	bl	80be4 <printk>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
   8198e:	2003      	movs	r0, #3
   81990:	f7ff ff9a 	bl	818c8 <_sys_device_do_config_level>
	_init_static_threads();
   81994:	f000 ff26 	bl	827e4 <_init_static_threads>
	main();
   81998:	f7ff fff0 	bl	8197c <main>
	_main_thread->base.user_options &= ~K_ESSENTIAL;
   8199c:	4a03      	ldr	r2, [pc, #12]	; (819ac <bg_thread_main+0x2c>)
   8199e:	7a13      	ldrb	r3, [r2, #8]
   819a0:	f023 0301 	bic.w	r3, r3, #1
   819a4:	7213      	strb	r3, [r2, #8]
   819a6:	bd08      	pop	{r3, pc}
   819a8:	000832f8 	.word	0x000832f8
   819ac:	20070090 	.word	0x20070090

000819b0 <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
   819b0:	b580      	push	{r7, lr}
   819b2:	b086      	sub	sp, #24
   819b4:	af06      	add	r7, sp, #24
	 * spurious interrupts. This must be performed before other kernel
	 * subsystems install bonafide handlers, or before hardware device
	 * drivers are initialized.
	 */

	_IntLibInit();
   819b6:	f7ff f9b5 	bl	80d24 <_IntLibInit>
{
#ifdef CONFIG_MPU_REQUIRES_POWER_OF_TWO_ALIGNMENT
	u32_t msp = (u32_t)(K_THREAD_STACK_BUFFER(_interrupt_stack) +
			    CONFIG_ISR_STACK_SIZE - MPU_GUARD_ALIGN_AND_SIZE);
#else
	u32_t msp = (u32_t)(K_THREAD_STACK_BUFFER(_interrupt_stack) +
   819ba:	4b30      	ldr	r3, [pc, #192]	; (81a7c <_Cstart+0xcc>)
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   819bc:	f383 8808 	msr	MSP, r3
   819c0:	2400      	movs	r4, #0
   819c2:	22f0      	movs	r2, #240	; 0xf0
   819c4:	4b2e      	ldr	r3, [pc, #184]	; (81a80 <_Cstart+0xd0>)
	_ready_q.cache = _main_thread;
   819c6:	4d2f      	ldr	r5, [pc, #188]	; (81a84 <_Cstart+0xd4>)
   819c8:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
   819cc:	77dc      	strb	r4, [r3, #31]
   819ce:	761c      	strb	r4, [r3, #24]
   819d0:	765c      	strb	r4, [r3, #25]
   819d2:	769c      	strb	r4, [r3, #26]
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   819d4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   819d6:	4e2c      	ldr	r6, [pc, #176]	; (81a88 <_Cstart+0xd8>)
   819d8:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
   819dc:	625a      	str	r2, [r3, #36]	; 0x24
extern void _CpuIdleInit(void);
static ALWAYS_INLINE void kernel_arch_init(void)
{
	_InterruptStackSetup();
	_ExcSetup();
	_FaultInit();
   819de:	f7ff fb23 	bl	81028 <_FaultInit>
	_CpuIdleInit();
   819e2:	f7ff fbb3 	bl	8114c <_CpuIdleInit>

	/* perform any architecture-specific initialization */
	kernel_arch_init();

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   819e6:	4620      	mov	r0, r4
   819e8:	f7ff ff6e 	bl	818c8 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   819ec:	2001      	movs	r0, #1
   819ee:	f7ff ff6b 	bl	818c8 <_sys_device_do_config_level>
	_sched_init();
   819f2:	f000 fc63 	bl	822bc <_sched_init>
	_setup_new_thread(_main_thread, _main_stack,
   819f6:	2301      	movs	r3, #1
	_ready_q.cache = _main_thread;
   819f8:	61f5      	str	r5, [r6, #28]
	_setup_new_thread(_main_thread, _main_stack,
   819fa:	f44f 6280 	mov.w	r2, #1024	; 0x400
   819fe:	9304      	str	r3, [sp, #16]
   81a00:	9403      	str	r4, [sp, #12]
   81a02:	9402      	str	r4, [sp, #8]
   81a04:	9401      	str	r4, [sp, #4]
   81a06:	9400      	str	r4, [sp, #0]
   81a08:	4b20      	ldr	r3, [pc, #128]	; (81a8c <_Cstart+0xdc>)
   81a0a:	4921      	ldr	r1, [pc, #132]	; (81a90 <_Cstart+0xe0>)
   81a0c:	4628      	mov	r0, r5
   81a0e:	f000 feaf 	bl	82770 <_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
}

static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   81a12:	7a6b      	ldrb	r3, [r5, #9]
   81a14:	4634      	mov	r4, r6
   81a16:	f023 0204 	bic.w	r2, r3, #4
	return !(_is_thread_prevented_from_running(thread) ||
   81a1a:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   81a1e:	726a      	strb	r2, [r5, #9]
	return !(_is_thread_prevented_from_running(thread) ||
   81a20:	d102      	bne.n	81a28 <_Cstart+0x78>
   81a22:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   81a24:	3301      	adds	r3, #1
   81a26:	d024      	beq.n	81a72 <_Cstart+0xc2>
	_setup_new_thread(thr, stack,
   81a28:	2301      	movs	r3, #1
   81a2a:	9304      	str	r3, [sp, #16]
   81a2c:	230f      	movs	r3, #15
   81a2e:	9303      	str	r3, [sp, #12]
   81a30:	2300      	movs	r3, #0
   81a32:	4e18      	ldr	r6, [pc, #96]	; (81a94 <_Cstart+0xe4>)
   81a34:	9302      	str	r3, [sp, #8]
   81a36:	9301      	str	r3, [sp, #4]
   81a38:	9300      	str	r3, [sp, #0]
   81a3a:	f44f 7280 	mov.w	r2, #256	; 0x100
   81a3e:	4b16      	ldr	r3, [pc, #88]	; (81a98 <_Cstart+0xe8>)
   81a40:	4916      	ldr	r1, [pc, #88]	; (81a9c <_Cstart+0xec>)
   81a42:	4630      	mov	r0, r6
   81a44:	f000 fe94 	bl	82770 <_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   81a48:	7a73      	ldrb	r3, [r6, #9]
	_kernel.cpus[0].idle_thread = _idle_thread;
   81a4a:	60e6      	str	r6, [r4, #12]
   81a4c:	f023 0304 	bic.w	r3, r3, #4
   81a50:	7273      	strb	r3, [r6, #9]
	list->head = (sys_dnode_t *)list;
   81a52:	4b13      	ldr	r3, [pc, #76]	; (81aa0 <_Cstart+0xf0>)
	start_of_main_stack =
		K_THREAD_STACK_BUFFER(main_stack) + main_stack_size;
#endif
	start_of_main_stack = (void *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
   81a54:	60a5      	str	r5, [r4, #8]
   81a56:	6163      	str	r3, [r4, #20]
	list->tail = (sys_dnode_t *)list;
   81a58:	61a3      	str	r3, [r4, #24]
	start_of_main_stack = (void *)STACK_ROUND_DOWN(start_of_main_stack);
   81a5a:	4b12      	ldr	r3, [pc, #72]	; (81aa4 <_Cstart+0xf4>)
#else
#error "Built-in PSP limit checks not supported by HW"
#endif
#endif /* CONFIG_BUILTIN_STACK_GUARD */

	__asm__ __volatile__(
   81a5c:	4c12      	ldr	r4, [pc, #72]	; (81aa8 <_Cstart+0xf8>)
	start_of_main_stack = (void *)STACK_ROUND_DOWN(start_of_main_stack);
   81a5e:	f023 0307 	bic.w	r3, r3, #7
	__asm__ __volatile__(
   81a62:	4a0a      	ldr	r2, [pc, #40]	; (81a8c <_Cstart+0xdc>)
   81a64:	f383 8809 	msr	PSP, r3
   81a68:	2100      	movs	r1, #0
   81a6a:	f381 8811 	msr	BASEPRI, r1
   81a6e:	4610      	mov	r0, r2
   81a70:	4720      	bx	r4
}

static inline void _ready_thread(struct k_thread *thread)
{
	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
   81a72:	4628      	mov	r0, r5
   81a74:	f000 fa8e 	bl	81f94 <_add_thread_to_ready_q>
   81a78:	e7d6      	b.n	81a28 <_Cstart+0x78>
   81a7a:	bf00      	nop
   81a7c:	20071c88 	.word	0x20071c88
   81a80:	e000ed00 	.word	0xe000ed00
   81a84:	20070090 	.word	0x20070090
   81a88:	20070350 	.word	0x20070350
   81a8c:	00081981 	.word	0x00081981
   81a90:	20070f88 	.word	0x20070f88
   81a94:	20070028 	.word	0x20070028
   81a98:	0008193d 	.word	0x0008193d
   81a9c:	20071388 	.word	0x20071388
   81aa0:	20070364 	.word	0x20070364
   81aa4:	20071388 	.word	0x20071388
   81aa8:	00080521 	.word	0x00080521

00081aac <init_static_pools>:
	_waitq_init(&p->wait_q);
	_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
   81aac:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	struct k_mem_pool *p;

	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
   81aae:	4c07      	ldr	r4, [pc, #28]	; (81acc <init_static_pools+0x20>)
   81ab0:	4d07      	ldr	r5, [pc, #28]	; (81ad0 <init_static_pools+0x24>)
   81ab2:	42ac      	cmp	r4, r5
   81ab4:	d301      	bcc.n	81aba <init_static_pools+0xe>
		k_mem_pool_init(p);
	}

	return 0;
}
   81ab6:	2000      	movs	r0, #0
   81ab8:	bd38      	pop	{r3, r4, r5, pc}
   81aba:	f104 0314 	add.w	r3, r4, #20
	list->head = (sys_dnode_t *)list;
   81abe:	6163      	str	r3, [r4, #20]
	list->tail = (sys_dnode_t *)list;
   81ac0:	61a3      	str	r3, [r4, #24]
	_sys_mem_pool_base_init(&p->base);
   81ac2:	4620      	mov	r0, r4
   81ac4:	f7fe fd69 	bl	8059a <_sys_mem_pool_base_init>
	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
   81ac8:	341c      	adds	r4, #28
   81aca:	e7f2      	b.n	81ab2 <init_static_pools+0x6>
   81acc:	20071da0 	.word	0x20071da0
   81ad0:	20071dbc 	.word	0x20071dbc

00081ad4 <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, s32_t timeout)
{
   81ad4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   81ad8:	4607      	mov	r7, r0
   81ada:	b085      	sub	sp, #20
   81adc:	460c      	mov	r4, r1
   81ade:	4692      	mov	sl, r2
   81ae0:	461d      	mov	r5, r3
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   81ae2:	f3ef 8305 	mrs	r3, IPSR
		|| (vector && !(SCB->ICSR & SCB_ICSR_RETTOBASE_Msk))
   81ae6:	2b0d      	cmp	r3, #13
   81ae8:	d85d      	bhi.n	81ba6 <k_mem_pool_alloc+0xd2>
   81aea:	b11b      	cbz	r3, 81af4 <k_mem_pool_alloc+0x20>
   81aec:	4b30      	ldr	r3, [pc, #192]	; (81bb0 <k_mem_pool_alloc+0xdc>)
   81aee:	685b      	ldr	r3, [r3, #4]
   81af0:	051a      	lsls	r2, r3, #20
   81af2:	d558      	bpl.n	81ba6 <k_mem_pool_alloc+0xd2>
	int ret;
	s64_t end = 0;

	__ASSERT(!(_is_in_isr() && timeout != K_NO_WAIT), "");

	if (timeout > 0) {
   81af4:	2d00      	cmp	r5, #0
   81af6:	dd58      	ble.n	81baa <k_mem_pool_alloc+0xd6>
		end = _tick_get() + _ms_to_ticks(timeout);
   81af8:	f000 fc94 	bl	82424 <_tick_get>
	return (s32_t)ceiling_fraction(ms_ticks_per_sec, MSEC_PER_SEC);
#else
	/* simple division keeps precision */
	s32_t ms_per_tick = MSEC_PER_SEC / sys_clock_ticks_per_sec;

	return (s32_t)ceiling_fraction(ms, ms_per_tick);
   81afc:	220a      	movs	r2, #10
   81afe:	f105 0309 	add.w	r3, r5, #9
   81b02:	fb93 f3f2 	sdiv	r3, r3, r2
   81b06:	eb10 0803 	adds.w	r8, r0, r3
	return pool - &_k_mem_pool_list_start[0];
   81b0a:	4b2a      	ldr	r3, [pc, #168]	; (81bb4 <k_mem_pool_alloc+0xe0>)
   81b0c:	4e2a      	ldr	r6, [pc, #168]	; (81bb8 <k_mem_pool_alloc+0xe4>)
   81b0e:	1afb      	subs	r3, r7, r3
   81b10:	109b      	asrs	r3, r3, #2
   81b12:	435e      	muls	r6, r3
		if (ret == 0 || timeout == K_NO_WAIT ||
		    (ret && ret != -ENOMEM)) {
			return ret;
		}

		_pend_current_thread(irq_lock(), &p->wait_q, timeout);
   81b14:	f107 0b14 	add.w	fp, r7, #20
		block->id.pool = pool_id(p);
   81b18:	b2f6      	uxtb	r6, r6
			ret = _sys_mem_pool_block_alloc(&p->base, size,
   81b1a:	9400      	str	r4, [sp, #0]
   81b1c:	ab03      	add	r3, sp, #12
   81b1e:	aa02      	add	r2, sp, #8
   81b20:	4651      	mov	r1, sl
   81b22:	4638      	mov	r0, r7
   81b24:	f7fe fd85 	bl	80632 <_sys_mem_pool_block_alloc>
			if (ret != -EAGAIN) {
   81b28:	f110 0f0b 	cmn.w	r0, #11
   81b2c:	d10b      	bne.n	81b46 <k_mem_pool_alloc+0x72>
			ret = _sys_mem_pool_block_alloc(&p->base, size,
   81b2e:	9400      	str	r4, [sp, #0]
   81b30:	ab03      	add	r3, sp, #12
   81b32:	aa02      	add	r2, sp, #8
   81b34:	4651      	mov	r1, sl
   81b36:	4638      	mov	r0, r7
   81b38:	f7fe fd7b 	bl	80632 <_sys_mem_pool_block_alloc>
			ret = -ENOMEM;
   81b3c:	f110 0f0b 	cmn.w	r0, #11
   81b40:	bf08      	it	eq
   81b42:	f06f 000b 	mvneq.w	r0, #11
		block->id.level = level_num;
   81b46:	7963      	ldrb	r3, [r4, #5]
   81b48:	9a02      	ldr	r2, [sp, #8]
		block->id.pool = pool_id(p);
   81b4a:	7126      	strb	r6, [r4, #4]
		block->id.level = level_num;
   81b4c:	f362 0303 	bfi	r3, r2, #0, #4
   81b50:	7163      	strb	r3, [r4, #5]
		block->id.block = block_num;
   81b52:	6863      	ldr	r3, [r4, #4]
   81b54:	9a03      	ldr	r2, [sp, #12]
   81b56:	f362 331f 	bfi	r3, r2, #12, #20
   81b5a:	6063      	str	r3, [r4, #4]
		if (ret == 0 || timeout == K_NO_WAIT ||
   81b5c:	b1b0      	cbz	r0, 81b8c <k_mem_pool_alloc+0xb8>
   81b5e:	b1ad      	cbz	r5, 81b8c <k_mem_pool_alloc+0xb8>
		    (ret && ret != -ENOMEM)) {
   81b60:	f110 0f0c 	cmn.w	r0, #12
   81b64:	d112      	bne.n	81b8c <k_mem_pool_alloc+0xb8>
   81b66:	f04f 0310 	mov.w	r3, #16
   81b6a:	f3ef 8011 	mrs	r0, BASEPRI
   81b6e:	f383 8811 	msr	BASEPRI, r3
		_pend_current_thread(irq_lock(), &p->wait_q, timeout);
   81b72:	462a      	mov	r2, r5
   81b74:	4659      	mov	r1, fp
   81b76:	f000 fb35 	bl	821e4 <_pend_current_thread>

		if (timeout != K_FOREVER) {
   81b7a:	1c6b      	adds	r3, r5, #1
   81b7c:	d0cd      	beq.n	81b1a <k_mem_pool_alloc+0x46>
			timeout = end - _tick_get();
   81b7e:	f000 fc51 	bl	82424 <_tick_get>

			if (timeout < 0) {
   81b82:	ebb8 0500 	subs.w	r5, r8, r0
   81b86:	d5c8      	bpl.n	81b1a <k_mem_pool_alloc+0x46>
				break;
			}
		}
	}

	return -EAGAIN;
   81b88:	f06f 000a 	mvn.w	r0, #10
}
   81b8c:	b005      	add	sp, #20
   81b8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__ASSERT(!(_is_in_isr() && timeout != K_NO_WAIT), "");
   81b92:	2338      	movs	r3, #56	; 0x38
   81b94:	4a09      	ldr	r2, [pc, #36]	; (81bbc <k_mem_pool_alloc+0xe8>)
   81b96:	490a      	ldr	r1, [pc, #40]	; (81bc0 <k_mem_pool_alloc+0xec>)
   81b98:	480a      	ldr	r0, [pc, #40]	; (81bc4 <k_mem_pool_alloc+0xf0>)
   81b9a:	f7ff f823 	bl	80be4 <printk>
   81b9e:	480a      	ldr	r0, [pc, #40]	; (81bc8 <k_mem_pool_alloc+0xf4>)
   81ba0:	f7ff f820 	bl	80be4 <printk>
   81ba4:	e7fe      	b.n	81ba4 <k_mem_pool_alloc+0xd0>
   81ba6:	2d00      	cmp	r5, #0
   81ba8:	d1f3      	bne.n	81b92 <k_mem_pool_alloc+0xbe>
	s64_t end = 0;
   81baa:	f04f 0800 	mov.w	r8, #0
   81bae:	e7ac      	b.n	81b0a <k_mem_pool_alloc+0x36>
   81bb0:	e000ed00 	.word	0xe000ed00
   81bb4:	20071da0 	.word	0x20071da0
   81bb8:	b6db6db7 	.word	0xb6db6db7
   81bbc:	0008332f 	.word	0x0008332f
   81bc0:	00083355 	.word	0x00083355
   81bc4:	00082995 	.word	0x00082995
   81bc8:	000829b3 	.word	0x000829b3

00081bcc <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
   81bcc:	b570      	push	{r4, r5, r6, lr}
   81bce:	241c      	movs	r4, #28
   81bd0:	7803      	ldrb	r3, [r0, #0]
	int key, need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	_sys_mem_pool_block_free(&p->base, id->level, id->block);
   81bd2:	6802      	ldr	r2, [r0, #0]
   81bd4:	435c      	muls	r4, r3
   81bd6:	7841      	ldrb	r1, [r0, #1]
   81bd8:	4e11      	ldr	r6, [pc, #68]	; (81c20 <k_mem_pool_free_id+0x54>)
   81bda:	0b12      	lsrs	r2, r2, #12
   81bdc:	f001 010f 	and.w	r1, r1, #15
   81be0:	1930      	adds	r0, r6, r4
   81be2:	f7fe fdd8 	bl	80796 <_sys_mem_pool_block_free>
   81be6:	f04f 0310 	mov.w	r3, #16
   81bea:	f3ef 8511 	mrs	r5, BASEPRI
   81bee:	f383 8811 	msr	BASEPRI, r3
	/* Wake up anyone blocked on this pool and let them repeat
	 * their allocation attempts
	 */
	key = irq_lock();

	need_sched = _unpend_all(&p->wait_q);
   81bf2:	f104 0014 	add.w	r0, r4, #20
   81bf6:	4430      	add	r0, r6
   81bf8:	f000 fb50 	bl	8229c <_unpend_all>

	if (need_sched && !_is_in_isr()) {
   81bfc:	b140      	cbz	r0, 81c10 <k_mem_pool_free_id+0x44>
   81bfe:	f3ef 8305 	mrs	r3, IPSR
   81c02:	2b0d      	cmp	r3, #13
   81c04:	d804      	bhi.n	81c10 <k_mem_pool_free_id+0x44>
   81c06:	b133      	cbz	r3, 81c16 <k_mem_pool_free_id+0x4a>
   81c08:	4b06      	ldr	r3, [pc, #24]	; (81c24 <k_mem_pool_free_id+0x58>)
   81c0a:	685b      	ldr	r3, [r3, #4]
   81c0c:	051b      	lsls	r3, r3, #20
   81c0e:	d402      	bmi.n	81c16 <k_mem_pool_free_id+0x4a>
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   81c10:	f385 8811 	msr	BASEPRI, r5
		_reschedule(key);
	} else {
		irq_unlock(key);
	}
}
   81c14:	bd70      	pop	{r4, r5, r6, pc}
		_reschedule(key);
   81c16:	4628      	mov	r0, r5
}
   81c18:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_reschedule(key);
   81c1c:	f000 b91a 	b.w	81e54 <_reschedule>
   81c20:	20071da0 	.word	0x20071da0
   81c24:	e000ed00 	.word	0xe000ed00

00081c28 <k_mem_pool_malloc>:
{
	k_mem_pool_free_id(&block->id);
}

void *k_mem_pool_malloc(struct k_mem_pool *pool, size_t size)
{
   81c28:	b507      	push	{r0, r1, r2, lr}

	/*
	 * get a block large enough to hold an initial (hidden) block
	 * descriptor, as well as the space the caller requested
	 */
	if (__builtin_add_overflow(size, sizeof(struct k_mem_block_id),
   81c2a:	1d0a      	adds	r2, r1, #4
   81c2c:	d204      	bcs.n	81c38 <k_mem_pool_malloc+0x10>
				   &size)) {
		return NULL;
	}
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   81c2e:	2300      	movs	r3, #0
   81c30:	4669      	mov	r1, sp
   81c32:	f7ff ff4f 	bl	81ad4 <k_mem_pool_alloc>
   81c36:	b118      	cbz	r0, 81c40 <k_mem_pool_malloc+0x18>
		return NULL;
   81c38:	2000      	movs	r0, #0
	/* save the block descriptor info at the start of the actual block */
	memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));

	/* return address of the user area part of the block to the caller */
	return (char *)block.data + sizeof(struct k_mem_block_id);
}
   81c3a:	b003      	add	sp, #12
   81c3c:	f85d fb04 	ldr.w	pc, [sp], #4
	memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
   81c40:	2204      	movs	r2, #4
   81c42:	9800      	ldr	r0, [sp, #0]
   81c44:	eb0d 0102 	add.w	r1, sp, r2
   81c48:	f7ff fb8e 	bl	81368 <memcpy>
	return (char *)block.data + sizeof(struct k_mem_block_id);
   81c4c:	9800      	ldr	r0, [sp, #0]
   81c4e:	3004      	adds	r0, #4
   81c50:	e7f3      	b.n	81c3a <k_mem_pool_malloc+0x12>

00081c52 <k_free>:

void k_free(void *ptr)
{
	if (ptr != NULL) {
   81c52:	b110      	cbz	r0, 81c5a <k_free+0x8>
		/* point to hidden block descriptor at start of block */
		ptr = (char *)ptr - sizeof(struct k_mem_block_id);

		/* return block to the heap memory pool */
		k_mem_pool_free_id(ptr);
   81c54:	3804      	subs	r0, #4
   81c56:	f7ff bfb9 	b.w	81bcc <k_mem_pool_free_id>
   81c5a:	4770      	bx	lr

00081c5c <k_malloc>:
K_MEM_POOL_DEFINE(_heap_mem_pool, 64, CONFIG_HEAP_MEM_POOL_SIZE, 1, 4);
#define _HEAP_MEM_POOL (&_heap_mem_pool)

void *k_malloc(size_t size)
{
	return k_mem_pool_malloc(_HEAP_MEM_POOL, size);
   81c5c:	4601      	mov	r1, r0
   81c5e:	4801      	ldr	r0, [pc, #4]	; (81c64 <k_malloc+0x8>)
   81c60:	f7ff bfe2 	b.w	81c28 <k_mem_pool_malloc>
   81c64:	20071da0 	.word	0x20071da0

00081c68 <z_thread_malloc>:

void *z_thread_malloc(size_t size)
{
	void *ret;

	if (_current->resource_pool) {
   81c68:	4b03      	ldr	r3, [pc, #12]	; (81c78 <z_thread_malloc+0x10>)
{
   81c6a:	4601      	mov	r1, r0
	if (_current->resource_pool) {
   81c6c:	689b      	ldr	r3, [r3, #8]
   81c6e:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
   81c70:	b108      	cbz	r0, 81c76 <z_thread_malloc+0xe>
		ret = k_mem_pool_malloc(_current->resource_pool, size);
   81c72:	f7ff bfd9 	b.w	81c28 <k_mem_pool_malloc>
	} else {
		ret = NULL;
	}

	return ret;
}
   81c76:	4770      	bx	lr
   81c78:	20070350 	.word	0x20070350

00081c7c <_ready_thread>:
	return !(_is_thread_prevented_from_running(thread) ||
   81c7c:	7a42      	ldrb	r2, [r0, #9]
   81c7e:	06d2      	lsls	r2, r2, #27
   81c80:	d104      	bne.n	81c8c <_ready_thread+0x10>
   81c82:	6a43      	ldr	r3, [r0, #36]	; 0x24
   81c84:	3301      	adds	r3, #1
   81c86:	d101      	bne.n	81c8c <_ready_thread+0x10>
		_add_thread_to_ready_q(thread);
   81c88:	f000 b984 	b.w	81f94 <_add_thread_to_ready_q>
   81c8c:	4770      	bx	lr

00081c8e <queue_insert>:
			       struct k_queue *);
#endif

static int queue_insert(struct k_queue *queue, void *prev, void *data,
			bool alloc)
{
   81c8e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   81c92:	4606      	mov	r6, r0
   81c94:	460f      	mov	r7, r1
   81c96:	4614      	mov	r4, r2
   81c98:	4698      	mov	r8, r3
	__asm__ volatile(
   81c9a:	f04f 0310 	mov.w	r3, #16
   81c9e:	f3ef 8511 	mrs	r5, BASEPRI
   81ca2:	f383 8811 	msr	BASEPRI, r3
	unsigned int key = irq_lock();
#if !defined(CONFIG_POLL)
	struct k_thread *first_pending_thread;

	first_pending_thread = _unpend_first_thread(&queue->wait_q);
   81ca6:	3008      	adds	r0, #8
   81ca8:	f000 fa2e 	bl	82108 <_unpend_first_thread>

	if (first_pending_thread) {
   81cac:	4681      	mov	r9, r0
   81cae:	b160      	cbz	r0, 81cca <queue_insert+0x3c>
}

static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   81cb0:	2600      	movs	r6, #0
	_ready_thread(thread);
   81cb2:	f7ff ffe3 	bl	81c7c <_ready_thread>
   81cb6:	f8c9 6064 	str.w	r6, [r9, #100]	; 0x64
	thread->base.swap_data = data;
   81cba:	f8c9 4010 	str.w	r4, [r9, #16]

#if defined(CONFIG_POLL)
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* CONFIG_POLL */

	_reschedule(key);
   81cbe:	4628      	mov	r0, r5
   81cc0:	f000 f8c8 	bl	81e54 <_reschedule>
	return 0;
   81cc4:	2000      	movs	r0, #0
   81cc6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (alloc) {
   81cca:	f1b8 0f00 	cmp.w	r8, #0
   81cce:	d015      	beq.n	81cfc <queue_insert+0x6e>
		anode = z_thread_malloc(sizeof(*anode));
   81cd0:	2008      	movs	r0, #8
   81cd2:	f7ff ffc9 	bl	81c68 <z_thread_malloc>
		if (!anode) {
   81cd6:	2800      	cmp	r0, #0
   81cd8:	d02d      	beq.n	81d36 <queue_insert+0xa8>
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, u8_t flags)
{
	__ASSERT(!(flags & ~SYS_SFLIST_FLAGS_MASK), "flags too large");
	node->next_and_flags = flags;
   81cda:	2301      	movs	r3, #1
		anode->data = data;
   81cdc:	6044      	str	r4, [r0, #4]
   81cde:	4604      	mov	r4, r0
   81ce0:	6003      	str	r3, [r0, #0]
   81ce2:	6823      	ldr	r3, [r4, #0]
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode);
   81ce4:	b96f      	cbnz	r7, 81d02 <queue_insert+0x74>
	parent->next_and_flags = cur_flags | (unative_t)child;
   81ce6:	6832      	ldr	r2, [r6, #0]
   81ce8:	f003 0303 	and.w	r3, r3, #3
   81cec:	4313      	orrs	r3, r2
   81cee:	6023      	str	r3, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode);
   81cf0:	6873      	ldr	r3, [r6, #4]
	list->head = node;
   81cf2:	6034      	str	r4, [r6, #0]
Z_GENLIST_PREPEND(sflist, sfnode);
   81cf4:	2b00      	cmp	r3, #0
   81cf6:	d1e2      	bne.n	81cbe <queue_insert+0x30>
	list->tail = node;
   81cf8:	6074      	str	r4, [r6, #4]
   81cfa:	e7e0      	b.n	81cbe <queue_insert+0x30>
	node->next_and_flags = flags;
   81cfc:	f8c4 8000 	str.w	r8, [r4]
   81d00:	e7ef      	b.n	81ce2 <queue_insert+0x54>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   81d02:	683a      	ldr	r2, [r7, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   81d04:	f003 0303 	and.w	r3, r3, #3
Z_GENLIST_INSERT(sflist, sfnode);
   81d08:	f032 0203 	bics.w	r2, r2, #3
   81d0c:	d10b      	bne.n	81d26 <queue_insert+0x98>
   81d0e:	6872      	ldr	r2, [r6, #4]
	parent->next_and_flags = cur_flags | (unative_t)child;
   81d10:	6023      	str	r3, [r4, #0]
Z_GENLIST_APPEND(sflist, sfnode);
   81d12:	b912      	cbnz	r2, 81d1a <queue_insert+0x8c>
	list->tail = node;
   81d14:	6074      	str	r4, [r6, #4]
	list->head = node;
   81d16:	6034      	str	r4, [r6, #0]
   81d18:	e7d1      	b.n	81cbe <queue_insert+0x30>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   81d1a:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   81d1c:	f003 0303 	and.w	r3, r3, #3
   81d20:	4323      	orrs	r3, r4
   81d22:	6013      	str	r3, [r2, #0]
   81d24:	e7e8      	b.n	81cf8 <queue_insert+0x6a>
   81d26:	4313      	orrs	r3, r2
   81d28:	6023      	str	r3, [r4, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   81d2a:	683a      	ldr	r2, [r7, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   81d2c:	f002 0203 	and.w	r2, r2, #3
   81d30:	4314      	orrs	r4, r2
   81d32:	603c      	str	r4, [r7, #0]
   81d34:	e7c3      	b.n	81cbe <queue_insert+0x30>
			return -ENOMEM;
   81d36:	f06f 000b 	mvn.w	r0, #11
}
   81d3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00081d3e <z_queue_node_peek>:
{
   81d3e:	b510      	push	{r4, lr}
	if (node && sys_sfnode_flags_get(node)) {
   81d40:	4604      	mov	r4, r0
   81d42:	b130      	cbz	r0, 81d52 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   81d44:	6802      	ldr	r2, [r0, #0]
   81d46:	0793      	lsls	r3, r2, #30
   81d48:	d003      	beq.n	81d52 <z_queue_node_peek+0x14>
		ret = anode->data;
   81d4a:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   81d4c:	b109      	cbz	r1, 81d52 <z_queue_node_peek+0x14>
			k_free(anode);
   81d4e:	f7ff ff80 	bl	81c52 <k_free>
}
   81d52:	4620      	mov	r0, r4
   81d54:	bd10      	pop	{r4, pc}

00081d56 <k_queue_append>:
	queue_insert(queue, prev, data, false);
}

void k_queue_append(struct k_queue *queue, void *data)
{
	queue_insert(queue, sys_sflist_peek_tail(&queue->data_q), data, false);
   81d56:	460a      	mov	r2, r1
   81d58:	2300      	movs	r3, #0
   81d5a:	6841      	ldr	r1, [r0, #4]
   81d5c:	f7ff bf97 	b.w	81c8e <queue_insert>

00081d60 <_impl_k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *_impl_k_queue_get(struct k_queue *queue, s32_t timeout)
{
   81d60:	b538      	push	{r3, r4, r5, lr}
   81d62:	f04f 0310 	mov.w	r3, #16
   81d66:	f3ef 8511 	mrs	r5, BASEPRI
   81d6a:	f383 8811 	msr	BASEPRI, r3
   81d6e:	6804      	ldr	r4, [r0, #0]
	unsigned int key;
	void *data;

	key = irq_lock();

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   81d70:	b174      	cbz	r4, 81d90 <_impl_k_queue_get+0x30>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   81d72:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode);
   81d74:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   81d76:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode);
   81d7a:	4294      	cmp	r4, r2
	list->tail = node;
   81d7c:	bf08      	it	eq
   81d7e:	6043      	streq	r3, [r0, #4]
	list->head = node;
   81d80:	6003      	str	r3, [r0, #0]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   81d82:	2101      	movs	r1, #1
   81d84:	4620      	mov	r0, r4
   81d86:	f7ff ffda 	bl	81d3e <z_queue_node_peek>
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   81d8a:	f385 8811 	msr	BASEPRI, r5
		irq_unlock(key);
		return data;
   81d8e:	bd38      	pop	{r3, r4, r5, pc}
	}

	if (timeout == K_NO_WAIT) {
   81d90:	b919      	cbnz	r1, 81d9a <_impl_k_queue_get+0x3a>
   81d92:	f385 8811 	msr	BASEPRI, r5
		irq_unlock(key);
		return NULL;
   81d96:	4608      	mov	r0, r1
   81d98:	bd38      	pop	{r3, r4, r5, pc}
	irq_unlock(key);

	return k_queue_poll(queue, timeout);

#else
	int ret = _pend_current_thread(key, &queue->wait_q, timeout);
   81d9a:	460a      	mov	r2, r1
   81d9c:	f100 0108 	add.w	r1, r0, #8
   81da0:	4628      	mov	r0, r5
   81da2:	f000 fa1f 	bl	821e4 <_pend_current_thread>

	return ret ? NULL : _current->base.swap_data;
   81da6:	b918      	cbnz	r0, 81db0 <_impl_k_queue_get+0x50>
   81da8:	4b02      	ldr	r3, [pc, #8]	; (81db4 <_impl_k_queue_get+0x54>)
   81daa:	689b      	ldr	r3, [r3, #8]
   81dac:	6918      	ldr	r0, [r3, #16]
   81dae:	bd38      	pop	{r3, r4, r5, pc}
   81db0:	4620      	mov	r0, r4
#endif /* CONFIG_POLL */
}
   81db2:	bd38      	pop	{r3, r4, r5, pc}
   81db4:	20070350 	.word	0x20070350

00081db8 <_abort_timeout>:
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
   81db8:	6903      	ldr	r3, [r0, #16]
   81dba:	1c5a      	adds	r2, r3, #1
   81dbc:	d011      	beq.n	81de2 <_abort_timeout+0x2a>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
   81dbe:	4a0a      	ldr	r2, [pc, #40]	; (81de8 <_abort_timeout+0x30>)
   81dc0:	6992      	ldr	r2, [r2, #24]
   81dc2:	4290      	cmp	r0, r2
	return (node == list->tail) ? NULL : node->next;
   81dc4:	bf1f      	itttt	ne
   81dc6:	6801      	ldrne	r1, [r0, #0]
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
   81dc8:	690a      	ldrne	r2, [r1, #16]
   81dca:	189b      	addne	r3, r3, r2
   81dcc:	610b      	strne	r3, [r1, #16]
	node->prev->next = node->next;
   81dce:	e890 000c 	ldmia.w	r0, {r2, r3}
   81dd2:	601a      	str	r2, [r3, #0]
	node->next->prev = node->prev;
   81dd4:	6802      	ldr	r2, [r0, #0]
   81dd6:	6053      	str	r3, [r2, #4]
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
   81dd8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   81ddc:	6103      	str	r3, [r0, #16]

	return 0;
   81dde:	2000      	movs	r0, #0
   81de0:	4770      	bx	lr
		return _INACTIVE;
   81de2:	4618      	mov	r0, r3
}
   81de4:	4770      	bx	lr
   81de6:	bf00      	nop
   81de8:	20070350 	.word	0x20070350

00081dec <k_spin_lock.isra.11>:
	__asm__ volatile(
   81dec:	f04f 0310 	mov.w	r3, #16
   81df0:	f3ef 8011 	mrs	r0, BASEPRI
   81df4:	f383 8811 	msr	BASEPRI, r3
	while (!atomic_cas(&l->locked, 0, 1)) {
	}
#endif

	return k;
}
   81df8:	4770      	bx	lr
	...

00081dfc <update_cache>:
	return list->head == list;
   81dfc:	4b0d      	ldr	r3, [pc, #52]	; (81e34 <update_cache+0x38>)
   81dfe:	4619      	mov	r1, r3
   81e00:	f851 2f20 	ldr.w	r2, [r1, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   81e04:	428a      	cmp	r2, r1
   81e06:	d000      	beq.n	81e0a <update_cache+0xe>
	 * responsible for putting it back in _Swap and ISR return!),
	 * which makes this choice simple.
	 */
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);

	return th ? th : _current_cpu->idle_thread;
   81e08:	b902      	cbnz	r2, 81e0c <update_cache+0x10>
   81e0a:	68da      	ldr	r2, [r3, #12]
	if (preempt_ok) {
   81e0c:	b970      	cbnz	r0, 81e2c <update_cache+0x30>
	if (!_current || !_is_thread_ready(_current)) {
   81e0e:	6899      	ldr	r1, [r3, #8]
   81e10:	b161      	cbz	r1, 81e2c <update_cache+0x30>
	return !(_is_thread_prevented_from_running(thread) ||
   81e12:	7a48      	ldrb	r0, [r1, #9]
   81e14:	06c0      	lsls	r0, r0, #27
   81e16:	d109      	bne.n	81e2c <update_cache+0x30>
   81e18:	6a48      	ldr	r0, [r1, #36]	; 0x24
   81e1a:	3001      	adds	r0, #1
   81e1c:	d106      	bne.n	81e2c <update_cache+0x30>
	if (_is_preempt(_current) || is_metairq(th)) {
   81e1e:	8948      	ldrh	r0, [r1, #10]
   81e20:	287f      	cmp	r0, #127	; 0x7f
   81e22:	d903      	bls.n	81e2c <update_cache+0x30>
	return thread == _idle_thread;
   81e24:	4804      	ldr	r0, [pc, #16]	; (81e38 <update_cache+0x3c>)
	if (_is_idle(_current)) {
   81e26:	6800      	ldr	r0, [r0, #0]
   81e28:	4281      	cmp	r1, r0
   81e2a:	d101      	bne.n	81e30 <update_cache+0x34>
{
#ifndef CONFIG_SMP
	struct k_thread *th = next_up();

	if (should_preempt(th, preempt_ok)) {
		_kernel.ready_q.cache = th;
   81e2c:	61da      	str	r2, [r3, #28]
   81e2e:	4770      	bx	lr
	} else {
		_kernel.ready_q.cache = _current;
   81e30:	61d9      	str	r1, [r3, #28]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
   81e32:	4770      	bx	lr
   81e34:	20070350 	.word	0x20070350
   81e38:	000832f4 	.word	0x000832f4

00081e3c <_find_first_thread_to_unpend>:
#endif
}

struct k_thread *_find_first_thread_to_unpend(_wait_q_t *wait_q,
					      struct k_thread *from)
{
   81e3c:	b508      	push	{r3, lr}
   81e3e:	4602      	mov	r2, r0
	ARG_UNUSED(from);

	struct k_thread *ret = NULL;

	LOCKED(&sched_lock) {
   81e40:	f7ff ffd4 	bl	81dec <k_spin_lock.isra.11>
	return list->head == list;
   81e44:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   81e46:	429a      	cmp	r2, r3
   81e48:	bf08      	it	eq
   81e4a:	2300      	moveq	r3, #0
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   81e4c:	f380 8811 	msr	BASEPRI, r0
		ret = _priq_wait_best(&wait_q->waitq);
	}

	return ret;
}
   81e50:	4618      	mov	r0, r3
   81e52:	bd08      	pop	{r3, pc}

00081e54 <_reschedule>:
   81e54:	f3ef 8305 	mrs	r3, IPSR
   81e58:	2b0d      	cmp	r3, #13
   81e5a:	d809      	bhi.n	81e70 <_reschedule+0x1c>
   81e5c:	b11b      	cbz	r3, 81e66 <_reschedule+0x12>
   81e5e:	4b09      	ldr	r3, [pc, #36]	; (81e84 <_reschedule+0x30>)
   81e60:	685b      	ldr	r3, [r3, #4]
   81e62:	051b      	lsls	r3, r3, #20
   81e64:	d504      	bpl.n	81e70 <_reschedule+0x1c>
	}

#ifdef CONFIG_SMP
	return _Swap(key);
#else
	if (_get_next_ready_thread() != _current) {
   81e66:	4b08      	ldr	r3, [pc, #32]	; (81e88 <_reschedule+0x34>)
   81e68:	689a      	ldr	r2, [r3, #8]
   81e6a:	69db      	ldr	r3, [r3, #28]
   81e6c:	429a      	cmp	r2, r3
   81e6e:	d103      	bne.n	81e78 <_reschedule+0x24>
   81e70:	f380 8811 	msr	BASEPRI, r0
#endif

 noswap:
	irq_unlock(key);
	return 0;
}
   81e74:	2000      	movs	r0, #0
   81e76:	4770      	bx	lr
		_set_time(remaining);
	}

#endif
	/* Restart time slice count at new thread switch */
	_time_slice_elapsed = 0;
   81e78:	2200      	movs	r2, #0
   81e7a:	4b04      	ldr	r3, [pc, #16]	; (81e8c <_reschedule+0x38>)
   81e7c:	601a      	str	r2, [r3, #0]
   81e7e:	f7fe bf5d 	b.w	80d3c <__swap>
   81e82:	bf00      	nop
   81e84:	e000ed00 	.word	0xe000ed00
   81e88:	20070350 	.word	0x20070350
   81e8c:	2007037c 	.word	0x2007037c

00081e90 <k_sched_unlock>:
{
   81e90:	b510      	push	{r4, lr}
	__ASSERT(_current->base.sched_locked != 0, "");
   81e92:	4a1c      	ldr	r2, [pc, #112]	; (81f04 <k_sched_unlock+0x74>)
   81e94:	6893      	ldr	r3, [r2, #8]
   81e96:	7ad9      	ldrb	r1, [r3, #11]
   81e98:	b951      	cbnz	r1, 81eb0 <k_sched_unlock+0x20>
   81e9a:	f240 13a1 	movw	r3, #417	; 0x1a1
   81e9e:	4a1a      	ldr	r2, [pc, #104]	; (81f08 <k_sched_unlock+0x78>)
   81ea0:	491a      	ldr	r1, [pc, #104]	; (81f0c <k_sched_unlock+0x7c>)
   81ea2:	481b      	ldr	r0, [pc, #108]	; (81f10 <k_sched_unlock+0x80>)
   81ea4:	f7fe fe9e 	bl	80be4 <printk>
   81ea8:	481a      	ldr	r0, [pc, #104]	; (81f14 <k_sched_unlock+0x84>)
   81eaa:	f7fe fe9b 	bl	80be4 <printk>
   81eae:	e7fe      	b.n	81eae <k_sched_unlock+0x1e>
   81eb0:	f3ef 8305 	mrs	r3, IPSR
   81eb4:	2b0d      	cmp	r3, #13
   81eb6:	d81a      	bhi.n	81eee <k_sched_unlock+0x5e>
   81eb8:	b11b      	cbz	r3, 81ec2 <k_sched_unlock+0x32>
   81eba:	4b17      	ldr	r3, [pc, #92]	; (81f18 <k_sched_unlock+0x88>)
   81ebc:	685b      	ldr	r3, [r3, #4]
   81ebe:	051b      	lsls	r3, r3, #20
   81ec0:	d515      	bpl.n	81eee <k_sched_unlock+0x5e>
	LOCKED(&sched_lock) {
   81ec2:	f7ff ff93 	bl	81dec <k_spin_lock.isra.11>
		++_current->base.sched_locked;
   81ec6:	6892      	ldr	r2, [r2, #8]
	LOCKED(&sched_lock) {
   81ec8:	4604      	mov	r4, r0
		++_current->base.sched_locked;
   81eca:	7ad3      	ldrb	r3, [r2, #11]
		update_cache(1);
   81ecc:	2001      	movs	r0, #1
		++_current->base.sched_locked;
   81ece:	3301      	adds	r3, #1
   81ed0:	72d3      	strb	r3, [r2, #11]
		update_cache(1);
   81ed2:	f7ff ff93 	bl	81dfc <update_cache>
   81ed6:	f384 8811 	msr	BASEPRI, r4
	__asm__ volatile(
   81eda:	f04f 0310 	mov.w	r3, #16
   81ede:	f3ef 8011 	mrs	r0, BASEPRI
   81ee2:	f383 8811 	msr	BASEPRI, r3
}
   81ee6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_reschedule(irq_lock());
   81eea:	f7ff bfb3 	b.w	81e54 <_reschedule>
	__ASSERT(!_is_in_isr(), "");
   81eee:	f44f 73d1 	mov.w	r3, #418	; 0x1a2
   81ef2:	4a05      	ldr	r2, [pc, #20]	; (81f08 <k_sched_unlock+0x78>)
   81ef4:	4909      	ldr	r1, [pc, #36]	; (81f1c <k_sched_unlock+0x8c>)
   81ef6:	4806      	ldr	r0, [pc, #24]	; (81f10 <k_sched_unlock+0x80>)
   81ef8:	f7fe fe74 	bl	80be4 <printk>
   81efc:	4805      	ldr	r0, [pc, #20]	; (81f14 <k_sched_unlock+0x84>)
   81efe:	f7fe fe71 	bl	80be4 <printk>
   81f02:	e7fe      	b.n	81f02 <k_sched_unlock+0x72>
   81f04:	20070350 	.word	0x20070350
   81f08:	00083457 	.word	0x00083457
   81f0c:	0008347b 	.word	0x0008347b
   81f10:	00082995 	.word	0x00082995
   81f14:	000829b3 	.word	0x000829b3
   81f18:	e000ed00 	.word	0xe000ed00
   81f1c:	0008344b 	.word	0x0008344b

00081f20 <_priq_dumb_add>:
	return thread == _idle_thread;
   81f20:	4b17      	ldr	r3, [pc, #92]	; (81f80 <_priq_dumb_add+0x60>)
{
   81f22:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(!_is_idle(thread));
   81f24:	681b      	ldr	r3, [r3, #0]
   81f26:	4299      	cmp	r1, r3
   81f28:	d10a      	bne.n	81f40 <_priq_dumb_add+0x20>
   81f2a:	f44f 73ed 	mov.w	r3, #474	; 0x1da
   81f2e:	4a15      	ldr	r2, [pc, #84]	; (81f84 <_priq_dumb_add+0x64>)
   81f30:	4915      	ldr	r1, [pc, #84]	; (81f88 <_priq_dumb_add+0x68>)
   81f32:	4816      	ldr	r0, [pc, #88]	; (81f8c <_priq_dumb_add+0x6c>)
   81f34:	f7fe fe56 	bl	80be4 <printk>
   81f38:	4815      	ldr	r0, [pc, #84]	; (81f90 <_priq_dumb_add+0x70>)
   81f3a:	f7fe fe53 	bl	80be4 <printk>
   81f3e:	e7fe      	b.n	81f3e <_priq_dumb_add+0x1e>
	return list->head == list;
   81f40:	6803      	ldr	r3, [r0, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   81f42:	4298      	cmp	r0, r3
   81f44:	bf08      	it	eq
   81f46:	2300      	moveq	r3, #0
   81f48:	b193      	cbz	r3, 81f70 <_priq_dumb_add+0x50>
	if (t1->base.prio < t2->base.prio) {
   81f4a:	f991 400a 	ldrsb.w	r4, [r1, #10]
   81f4e:	f993 200a 	ldrsb.w	r2, [r3, #10]
   81f52:	4294      	cmp	r4, r2
   81f54:	da06      	bge.n	81f64 <_priq_dumb_add+0x44>
		node->prev = insert_point->prev;
   81f56:	685a      	ldr	r2, [r3, #4]
		node->next = insert_point;
   81f58:	600b      	str	r3, [r1, #0]
		node->prev = insert_point->prev;
   81f5a:	604a      	str	r2, [r1, #4]
		insert_point->prev->next = node;
   81f5c:	685a      	ldr	r2, [r3, #4]
   81f5e:	6011      	str	r1, [r2, #0]
		insert_point->prev = node;
   81f60:	6059      	str	r1, [r3, #4]
   81f62:	bd10      	pop	{r4, pc}
	return (node == list->tail) ? NULL : node->next;
   81f64:	6842      	ldr	r2, [r0, #4]
   81f66:	4293      	cmp	r3, r2
   81f68:	d002      	beq.n	81f70 <_priq_dumb_add+0x50>
   81f6a:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   81f6c:	2b00      	cmp	r3, #0
   81f6e:	d1eb      	bne.n	81f48 <_priq_dumb_add+0x28>
	node->next = list;
   81f70:	6008      	str	r0, [r1, #0]
	node->prev = list->tail;
   81f72:	6843      	ldr	r3, [r0, #4]
   81f74:	604b      	str	r3, [r1, #4]
	list->tail->next = node;
   81f76:	6843      	ldr	r3, [r0, #4]
   81f78:	6019      	str	r1, [r3, #0]
	list->tail = node;
   81f7a:	6041      	str	r1, [r0, #4]
   81f7c:	bd10      	pop	{r4, pc}
   81f7e:	bf00      	nop
   81f80:	000832f4 	.word	0x000832f4
   81f84:	00083457 	.word	0x00083457
   81f88:	000833e4 	.word	0x000833e4
   81f8c:	00082995 	.word	0x00082995
   81f90:	000829b3 	.word	0x000829b3

00081f94 <_add_thread_to_ready_q>:
{
   81f94:	b538      	push	{r3, r4, r5, lr}
   81f96:	4604      	mov	r4, r0
	LOCKED(&sched_lock) {
   81f98:	f7ff ff28 	bl	81dec <k_spin_lock.isra.11>
		_priq_run_add(&_kernel.ready_q.runq, thread);
   81f9c:	4621      	mov	r1, r4
	LOCKED(&sched_lock) {
   81f9e:	4605      	mov	r5, r0
		_priq_run_add(&_kernel.ready_q.runq, thread);
   81fa0:	4806      	ldr	r0, [pc, #24]	; (81fbc <_add_thread_to_ready_q+0x28>)
   81fa2:	f7ff ffbd 	bl	81f20 <_priq_dumb_add>
	thread->base.thread_state |= states;
   81fa6:	7a63      	ldrb	r3, [r4, #9]
		update_cache(0);
   81fa8:	2000      	movs	r0, #0
   81faa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   81fae:	7263      	strb	r3, [r4, #9]
   81fb0:	f7ff ff24 	bl	81dfc <update_cache>
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   81fb4:	f385 8811 	msr	BASEPRI, r5
   81fb8:	bd38      	pop	{r3, r4, r5, pc}
   81fba:	bf00      	nop
   81fbc:	20070370 	.word	0x20070370

00081fc0 <_ready_thread>:
	return !(_is_thread_prevented_from_running(thread) ||
   81fc0:	7a42      	ldrb	r2, [r0, #9]
   81fc2:	06d2      	lsls	r2, r2, #27
   81fc4:	d104      	bne.n	81fd0 <_ready_thread+0x10>
   81fc6:	6a43      	ldr	r3, [r0, #36]	; 0x24
   81fc8:	3301      	adds	r3, #1
   81fca:	d101      	bne.n	81fd0 <_ready_thread+0x10>
		_add_thread_to_ready_q(thread);
   81fcc:	f7ff bfe2 	b.w	81f94 <_add_thread_to_ready_q>
   81fd0:	4770      	bx	lr
	...

00081fd4 <_priq_dumb_remove>:
{
   81fd4:	b508      	push	{r3, lr}
	return thread == _idle_thread;
   81fd6:	4b0a      	ldr	r3, [pc, #40]	; (82000 <_priq_dumb_remove+0x2c>)
	__ASSERT_NO_MSG(!_is_idle(thread));
   81fd8:	681b      	ldr	r3, [r3, #0]
   81fda:	4299      	cmp	r1, r3
   81fdc:	d10a      	bne.n	81ff4 <_priq_dumb_remove+0x20>
   81fde:	f240 13e9 	movw	r3, #489	; 0x1e9
   81fe2:	4a08      	ldr	r2, [pc, #32]	; (82004 <_priq_dumb_remove+0x30>)
   81fe4:	4908      	ldr	r1, [pc, #32]	; (82008 <_priq_dumb_remove+0x34>)
   81fe6:	4809      	ldr	r0, [pc, #36]	; (8200c <_priq_dumb_remove+0x38>)
   81fe8:	f7fe fdfc 	bl	80be4 <printk>
   81fec:	4808      	ldr	r0, [pc, #32]	; (82010 <_priq_dumb_remove+0x3c>)
   81fee:	f7fe fdf9 	bl	80be4 <printk>
   81ff2:	e7fe      	b.n	81ff2 <_priq_dumb_remove+0x1e>
	node->prev->next = node->next;
   81ff4:	e891 000c 	ldmia.w	r1, {r2, r3}
   81ff8:	601a      	str	r2, [r3, #0]
	node->next->prev = node->prev;
   81ffa:	680a      	ldr	r2, [r1, #0]
   81ffc:	6053      	str	r3, [r2, #4]
   81ffe:	bd08      	pop	{r3, pc}
   82000:	000832f4 	.word	0x000832f4
   82004:	00083457 	.word	0x00083457
   82008:	000833e4 	.word	0x000833e4
   8200c:	00082995 	.word	0x00082995
   82010:	000829b3 	.word	0x000829b3

00082014 <_unpend_thread_no_timeout>:
{
   82014:	b538      	push	{r3, r4, r5, lr}
   82016:	4604      	mov	r4, r0
	LOCKED(&sched_lock) {
   82018:	f7ff fee8 	bl	81dec <k_spin_lock.isra.11>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   8201c:	4621      	mov	r1, r4
	LOCKED(&sched_lock) {
   8201e:	4605      	mov	r5, r0
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   82020:	2000      	movs	r0, #0
   82022:	f7ff ffd7 	bl	81fd4 <_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   82026:	7a63      	ldrb	r3, [r4, #9]
   82028:	f023 0302 	bic.w	r3, r3, #2
   8202c:	7263      	strb	r3, [r4, #9]
   8202e:	f385 8811 	msr	BASEPRI, r5
   82032:	bd38      	pop	{r3, r4, r5, pc}

00082034 <_add_timeout>:

static inline void _add_timeout(struct k_thread *thread,
				struct _timeout *timeout,
				_wait_q_t *wait_q,
				s32_t timeout_in_ticks)
{
   82034:	b570      	push	{r4, r5, r6, lr}
	__ASSERT(timeout_in_ticks >= 0, "");
   82036:	1e1e      	subs	r6, r3, #0
{
   82038:	4604      	mov	r4, r0
	__ASSERT(timeout_in_ticks >= 0, "");
   8203a:	da09      	bge.n	82050 <_add_timeout+0x1c>
   8203c:	23c9      	movs	r3, #201	; 0xc9
   8203e:	4a28      	ldr	r2, [pc, #160]	; (820e0 <_add_timeout+0xac>)
   82040:	4928      	ldr	r1, [pc, #160]	; (820e4 <_add_timeout+0xb0>)
   82042:	4829      	ldr	r0, [pc, #164]	; (820e8 <_add_timeout+0xb4>)
   82044:	f7fe fdce 	bl	80be4 <printk>
   82048:	4828      	ldr	r0, [pc, #160]	; (820ec <_add_timeout+0xb8>)
   8204a:	f7fe fdcb 	bl	80be4 <printk>
   8204e:	e7fe      	b.n	8204e <_add_timeout+0x1a>

	timeout->delta_ticks_from_prev = timeout_in_ticks;
   82050:	610e      	str	r6, [r1, #16]
	timeout->thread = thread;
   82052:	6088      	str	r0, [r1, #8]
	timeout->wait_q = (sys_dlist_t *)wait_q;
   82054:	60ca      	str	r2, [r1, #12]
	/* If timer is submitted to expire ASAP with
	 * timeout_in_ticks (duration) as zero value,
	 * then handle timeout immedately without going
	 * through timeout queue.
	 */
	if (!timeout_in_ticks) {
   82056:	d120      	bne.n	8209a <_add_timeout+0x66>
	__asm__ volatile(
   82058:	f04f 0310 	mov.w	r3, #16
   8205c:	f3ef 8511 	mrs	r5, BASEPRI
   82060:	f383 8811 	msr	BASEPRI, r3
	timeout->delta_ticks_from_prev = _INACTIVE;
   82064:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   82068:	610b      	str	r3, [r1, #16]
	if (thread) {
   8206a:	b170      	cbz	r0, 8208a <_add_timeout+0x56>
	if (timeout_obj->wait_q) {
   8206c:	68cb      	ldr	r3, [r1, #12]
   8206e:	b113      	cbz	r3, 82076 <_add_timeout+0x42>
		_unpend_thread_no_timeout(thread);
   82070:	f7ff ffd0 	bl	82014 <_unpend_thread_no_timeout>
		thread->base.timeout.wait_q = NULL;
   82074:	6226      	str	r6, [r4, #32]
	thread->base.thread_state &= ~_THREAD_PRESTART;
   82076:	7a63      	ldrb	r3, [r4, #9]
		_ready_thread(thread);
   82078:	4620      	mov	r0, r4
   8207a:	f023 0304 	bic.w	r3, r3, #4
   8207e:	7263      	strb	r3, [r4, #9]
   82080:	f7ff ff9e 	bl	81fc0 <_ready_thread>
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   82084:	f385 8811 	msr	BASEPRI, r5
   82088:	bd70      	pop	{r4, r5, r6, pc}
   8208a:	f385 8811 	msr	BASEPRI, r5
		if (timeout->func) {
   8208e:	694b      	ldr	r3, [r1, #20]
   82090:	b32b      	cbz	r3, 820de <_add_timeout+0xaa>
#ifdef CONFIG_TICKLESS_KERNEL
	if (!program_time || (adjusted_timeout < program_time)) {
		_set_time(adjusted_timeout);
	}
#endif
}
   82092:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			timeout->func(timeout);
   82096:	4608      	mov	r0, r1
   82098:	4718      	bx	r3
	return list->head == list;
   8209a:	4a15      	ldr	r2, [pc, #84]	; (820f0 <_add_timeout+0xbc>)
   8209c:	4610      	mov	r0, r2
   8209e:	f850 3f14 	ldr.w	r3, [r0, #20]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   820a2:	4283      	cmp	r3, r0
   820a4:	d10c      	bne.n	820c0 <_add_timeout+0x8c>
	node->next = list;
   820a6:	6008      	str	r0, [r1, #0]
	node->prev = list->tail;
   820a8:	6993      	ldr	r3, [r2, #24]
   820aa:	604b      	str	r3, [r1, #4]
	list->tail->next = node;
   820ac:	6993      	ldr	r3, [r2, #24]
   820ae:	6019      	str	r1, [r3, #0]
	list->tail = node;
   820b0:	6191      	str	r1, [r2, #24]
   820b2:	bd70      	pop	{r4, r5, r6, pc}
		*delta -= in_q->delta_ticks_from_prev;
   820b4:	1b64      	subs	r4, r4, r5
   820b6:	610c      	str	r4, [r1, #16]
	return (node == list->tail) ? NULL : node->next;
   820b8:	6994      	ldr	r4, [r2, #24]
   820ba:	42a3      	cmp	r3, r4
   820bc:	d0f3      	beq.n	820a6 <_add_timeout+0x72>
   820be:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
   820c0:	2b00      	cmp	r3, #0
   820c2:	d0f0      	beq.n	820a6 <_add_timeout+0x72>
		if (*delta <= in_q->delta_ticks_from_prev) {
   820c4:	690c      	ldr	r4, [r1, #16]
   820c6:	691d      	ldr	r5, [r3, #16]
   820c8:	42ac      	cmp	r4, r5
   820ca:	dcf3      	bgt.n	820b4 <_add_timeout+0x80>
		node->prev = insert_point->prev;
   820cc:	685a      	ldr	r2, [r3, #4]
			in_q->delta_ticks_from_prev -= *delta;
   820ce:	1b2c      	subs	r4, r5, r4
   820d0:	611c      	str	r4, [r3, #16]
   820d2:	604a      	str	r2, [r1, #4]
		node->next = insert_point;
   820d4:	600b      	str	r3, [r1, #0]
		insert_point->prev->next = node;
   820d6:	685a      	ldr	r2, [r3, #4]
   820d8:	6011      	str	r1, [r2, #0]
		insert_point->prev = node;
   820da:	6059      	str	r1, [r3, #4]
   820dc:	bd70      	pop	{r4, r5, r6, pc}
   820de:	bd70      	pop	{r4, r5, r6, pc}
   820e0:	00083373 	.word	0x00083373
   820e4:	000833a3 	.word	0x000833a3
   820e8:	00082995 	.word	0x00082995
   820ec:	000829b3 	.word	0x000829b3
   820f0:	20070350 	.word	0x20070350

000820f4 <_unpend_thread>:
{
   820f4:	b510      	push	{r4, lr}
   820f6:	4604      	mov	r4, r0
	_unpend_thread_no_timeout(thread);
   820f8:	f7ff ff8c 	bl	82014 <_unpend_thread_no_timeout>
	return _abort_timeout(&thread->base.timeout);
   820fc:	f104 0014 	add.w	r0, r4, #20
}
   82100:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   82104:	f7ff be58 	b.w	81db8 <_abort_timeout>

00082108 <_unpend_first_thread>:
{
   82108:	b510      	push	{r4, lr}
#endif
}

static inline struct k_thread *_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = _find_first_thread_to_unpend(wait_q, NULL);
   8210a:	2100      	movs	r1, #0
   8210c:	f7ff fe96 	bl	81e3c <_find_first_thread_to_unpend>

	if (thread) {
   82110:	4604      	mov	r4, r0
   82112:	b128      	cbz	r0, 82120 <_unpend_first_thread+0x18>
		_unpend_thread_no_timeout(thread);
   82114:	f7ff ff7e 	bl	82014 <_unpend_thread_no_timeout>
   82118:	f104 0014 	add.w	r0, r4, #20
   8211c:	f7ff fe4c 	bl	81db8 <_abort_timeout>
}
   82120:	4620      	mov	r0, r4
   82122:	bd10      	pop	{r4, pc}

00082124 <_move_thread_to_end_of_prio_q>:
{
   82124:	b570      	push	{r4, r5, r6, lr}
   82126:	4604      	mov	r4, r0
	LOCKED(&sched_lock) {
   82128:	f7ff fe60 	bl	81dec <k_spin_lock.isra.11>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
   8212c:	4d09      	ldr	r5, [pc, #36]	; (82154 <_move_thread_to_end_of_prio_q+0x30>)
   8212e:	4621      	mov	r1, r4
	LOCKED(&sched_lock) {
   82130:	4606      	mov	r6, r0
		_priq_run_remove(&_kernel.ready_q.runq, thread);
   82132:	4628      	mov	r0, r5
   82134:	f7ff ff4e 	bl	81fd4 <_priq_dumb_remove>
		_priq_run_add(&_kernel.ready_q.runq, thread);
   82138:	4621      	mov	r1, r4
   8213a:	4628      	mov	r0, r5
   8213c:	f7ff fef0 	bl	81f20 <_priq_dumb_add>
	thread->base.thread_state |= states;
   82140:	7a63      	ldrb	r3, [r4, #9]
		update_cache(0);
   82142:	2000      	movs	r0, #0
   82144:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   82148:	7263      	strb	r3, [r4, #9]
   8214a:	f7ff fe57 	bl	81dfc <update_cache>
   8214e:	f386 8811 	msr	BASEPRI, r6
   82152:	bd70      	pop	{r4, r5, r6, pc}
   82154:	20070370 	.word	0x20070370

00082158 <_remove_thread_from_ready_q>:
{
   82158:	b538      	push	{r3, r4, r5, lr}
   8215a:	4604      	mov	r4, r0
	LOCKED(&sched_lock) {
   8215c:	f7ff fe46 	bl	81dec <k_spin_lock.isra.11>
		if (_is_thread_queued(thread)) {
   82160:	7a63      	ldrb	r3, [r4, #9]
	LOCKED(&sched_lock) {
   82162:	4605      	mov	r5, r0
		if (_is_thread_queued(thread)) {
   82164:	065a      	lsls	r2, r3, #25
   82166:	d50e      	bpl.n	82186 <_remove_thread_from_ready_q+0x2e>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   82168:	4808      	ldr	r0, [pc, #32]	; (8218c <_remove_thread_from_ready_q+0x34>)
   8216a:	4621      	mov	r1, r4
   8216c:	f7ff ff32 	bl	81fd4 <_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   82170:	7a63      	ldrb	r3, [r4, #9]
   82172:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   82176:	7263      	strb	r3, [r4, #9]
			update_cache(thread == _current);
   82178:	4b05      	ldr	r3, [pc, #20]	; (82190 <_remove_thread_from_ready_q+0x38>)
   8217a:	6898      	ldr	r0, [r3, #8]
   8217c:	1b03      	subs	r3, r0, r4
   8217e:	4258      	negs	r0, r3
   82180:	4158      	adcs	r0, r3
   82182:	f7ff fe3b 	bl	81dfc <update_cache>
   82186:	f385 8811 	msr	BASEPRI, r5
   8218a:	bd38      	pop	{r3, r4, r5, pc}
   8218c:	20070370 	.word	0x20070370
   82190:	20070350 	.word	0x20070350

00082194 <pend>:
{
   82194:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   82196:	4605      	mov	r5, r0
   82198:	4614      	mov	r4, r2
   8219a:	460e      	mov	r6, r1
	_remove_thread_from_ready_q(thread);
   8219c:	f7ff ffdc 	bl	82158 <_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
   821a0:	7a6b      	ldrb	r3, [r5, #9]
   821a2:	f043 0302 	orr.w	r3, r3, #2
   821a6:	726b      	strb	r3, [r5, #9]
	if (timeout != K_FOREVER) {
   821a8:	1c63      	adds	r3, r4, #1
   821aa:	d012      	beq.n	821d2 <pend+0x3e>
	__asm__ volatile(
   821ac:	f04f 0310 	mov.w	r3, #16
   821b0:	f3ef 8711 	mrs	r7, BASEPRI
   821b4:	f383 8811 	msr	BASEPRI, r3
   821b8:	230a      	movs	r3, #10
   821ba:	3409      	adds	r4, #9
   821bc:	fb94 f3f3 	sdiv	r3, r4, r3

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       s32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
   821c0:	4632      	mov	r2, r6
   821c2:	3301      	adds	r3, #1
   821c4:	f105 0114 	add.w	r1, r5, #20
   821c8:	4628      	mov	r0, r5
   821ca:	f7ff ff33 	bl	82034 <_add_timeout>
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   821ce:	f387 8811 	msr	BASEPRI, r7
	if (wait_q) {
   821d2:	b12e      	cbz	r6, 821e0 <pend+0x4c>
		_priq_wait_add(&wait_q->waitq, thread);
   821d4:	4629      	mov	r1, r5
   821d6:	4630      	mov	r0, r6
}
   821d8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		_priq_wait_add(&wait_q->waitq, thread);
   821dc:	f7ff bea0 	b.w	81f20 <_priq_dumb_add>
   821e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

000821e4 <_pend_current_thread>:
{
   821e4:	b510      	push	{r4, lr}
	pend(_current, wait_q, timeout);
   821e6:	4b06      	ldr	r3, [pc, #24]	; (82200 <_pend_current_thread+0x1c>)
{
   821e8:	4604      	mov	r4, r0
	pend(_current, wait_q, timeout);
   821ea:	6898      	ldr	r0, [r3, #8]
   821ec:	f7ff ffd2 	bl	82194 <pend>
	_time_slice_elapsed = 0;
   821f0:	2200      	movs	r2, #0
   821f2:	4b04      	ldr	r3, [pc, #16]	; (82204 <_pend_current_thread+0x20>)
   821f4:	4620      	mov	r0, r4
}
   821f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_time_slice_elapsed = 0;
   821fa:	601a      	str	r2, [r3, #0]
   821fc:	f7fe bd9e 	b.w	80d3c <__swap>
   82200:	20070350 	.word	0x20070350
   82204:	2007037c 	.word	0x2007037c

00082208 <_is_thread_time_slicing>:
{
   82208:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(thread == _current);
   8220a:	4a1a      	ldr	r2, [pc, #104]	; (82274 <_is_thread_time_slicing+0x6c>)
   8220c:	6891      	ldr	r1, [r2, #8]
   8220e:	4281      	cmp	r1, r0
   82210:	d00a      	beq.n	82228 <_is_thread_time_slicing+0x20>
   82212:	f240 2367 	movw	r3, #615	; 0x267
   82216:	4a18      	ldr	r2, [pc, #96]	; (82278 <_is_thread_time_slicing+0x70>)
   82218:	4918      	ldr	r1, [pc, #96]	; (8227c <_is_thread_time_slicing+0x74>)
   8221a:	4819      	ldr	r0, [pc, #100]	; (82280 <_is_thread_time_slicing+0x78>)
   8221c:	f7fe fce2 	bl	80be4 <printk>
   82220:	4818      	ldr	r0, [pc, #96]	; (82284 <_is_thread_time_slicing+0x7c>)
   82222:	f7fe fcdf 	bl	80be4 <printk>
   82226:	e7fe      	b.n	82226 <_is_thread_time_slicing+0x1e>
	if (_time_slice_duration <= 0 || !_is_preempt(thread) ||
   82228:	4b17      	ldr	r3, [pc, #92]	; (82288 <_is_thread_time_slicing+0x80>)
   8222a:	681b      	ldr	r3, [r3, #0]
   8222c:	2b00      	cmp	r3, #0
   8222e:	dd1e      	ble.n	8226e <_is_thread_time_slicing+0x66>
   82230:	894b      	ldrh	r3, [r1, #10]
   82232:	2b7f      	cmp	r3, #127	; 0x7f
   82234:	d81b      	bhi.n	8226e <_is_thread_time_slicing+0x66>
	    _is_prio_higher(thread->base.prio, _time_slice_prio_ceiling)) {
   82236:	4b15      	ldr	r3, [pc, #84]	; (8228c <_is_thread_time_slicing+0x84>)
   82238:	f991 000a 	ldrsb.w	r0, [r1, #10]
	if (_time_slice_duration <= 0 || !_is_preempt(thread) ||
   8223c:	681b      	ldr	r3, [r3, #0]
   8223e:	4298      	cmp	r0, r3
   82240:	db15      	blt.n	8226e <_is_thread_time_slicing+0x66>
	LOCKED(&sched_lock) {
   82242:	f7ff fdd3 	bl	81dec <k_spin_lock.isra.11>
	return list->head == list;
   82246:	f852 3f20 	ldr.w	r3, [r2, #32]!
   8224a:	4604      	mov	r4, r0
	return sys_dlist_is_empty(list) ? NULL : list->head;
   8224c:	4293      	cmp	r3, r2
   8224e:	d00a      	beq.n	82266 <_is_thread_time_slicing+0x5e>
		if (next) {
   82250:	b15b      	cbz	r3, 8226a <_is_thread_time_slicing+0x62>
			ret = thread->base.prio == next->base.prio;
   82252:	f991 000a 	ldrsb.w	r0, [r1, #10]
   82256:	f993 300a 	ldrsb.w	r3, [r3, #10]
   8225a:	1ac3      	subs	r3, r0, r3
   8225c:	4258      	negs	r0, r3
   8225e:	4158      	adcs	r0, r3
   82260:	f384 8811 	msr	BASEPRI, r4
	return ret;
   82264:	bd10      	pop	{r4, pc}
   82266:	2000      	movs	r0, #0
   82268:	e7fa      	b.n	82260 <_is_thread_time_slicing+0x58>
   8226a:	4618      	mov	r0, r3
   8226c:	e7f8      	b.n	82260 <_is_thread_time_slicing+0x58>
		return 0;
   8226e:	2000      	movs	r0, #0
}
   82270:	bd10      	pop	{r4, pc}
   82272:	bf00      	nop
   82274:	20070350 	.word	0x20070350
   82278:	00083457 	.word	0x00083457
   8227c:	000833ca 	.word	0x000833ca
   82280:	00082995 	.word	0x00082995
   82284:	000829b3 	.word	0x000829b3
   82288:	200700f8 	.word	0x200700f8
   8228c:	200700fc 	.word	0x200700fc

00082290 <_update_time_slice_before_swap>:
	_time_slice_elapsed = 0;
   82290:	2200      	movs	r2, #0
   82292:	4b01      	ldr	r3, [pc, #4]	; (82298 <_update_time_slice_before_swap+0x8>)
   82294:	601a      	str	r2, [r3, #0]
   82296:	4770      	bx	lr
   82298:	2007037c 	.word	0x2007037c

0008229c <_unpend_all>:
}
#endif /* CONFIG_TIMESLICING */

int _unpend_all(_wait_q_t *waitq)
{
   8229c:	b538      	push	{r3, r4, r5, lr}
   8229e:	4605      	mov	r5, r0
	int need_sched = 0;
   822a0:	2000      	movs	r0, #0
	return list->head == list;
   822a2:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   822a4:	42a5      	cmp	r5, r4
   822a6:	d000      	beq.n	822aa <_unpend_all+0xe>
	struct k_thread *th;

	while ((th = _waitq_head(waitq))) {
   822a8:	b904      	cbnz	r4, 822ac <_unpend_all+0x10>
		_ready_thread(th);
		need_sched = 1;
	}

	return need_sched;
}
   822aa:	bd38      	pop	{r3, r4, r5, pc}
		_unpend_thread(th);
   822ac:	4620      	mov	r0, r4
   822ae:	f7ff ff21 	bl	820f4 <_unpend_thread>
		_ready_thread(th);
   822b2:	4620      	mov	r0, r4
   822b4:	f7ff fe84 	bl	81fc0 <_ready_thread>
		need_sched = 1;
   822b8:	2001      	movs	r0, #1
   822ba:	e7f2      	b.n	822a2 <_unpend_all+0x6>

000822bc <_sched_init>:
	list->head = (sys_dnode_t *)list;
   822bc:	4b02      	ldr	r3, [pc, #8]	; (822c8 <_sched_init+0xc>)
   822be:	f103 0220 	add.w	r2, r3, #32
   822c2:	621a      	str	r2, [r3, #32]
	list->tail = (sys_dnode_t *)list;
   822c4:	625a      	str	r2, [r3, #36]	; 0x24
   822c6:	4770      	bx	lr
   822c8:	20070350 	.word	0x20070350

000822cc <_impl_k_yield>:
}
#endif
#endif

void _impl_k_yield(void)
{
   822cc:	b538      	push	{r3, r4, r5, lr}
   822ce:	f3ef 8305 	mrs	r3, IPSR
   822d2:	2b0d      	cmp	r3, #13
   822d4:	d82d      	bhi.n	82332 <_impl_k_yield+0x66>
   822d6:	b11b      	cbz	r3, 822e0 <_impl_k_yield+0x14>
   822d8:	4b1c      	ldr	r3, [pc, #112]	; (8234c <_impl_k_yield+0x80>)
   822da:	685b      	ldr	r3, [r3, #4]
   822dc:	051b      	lsls	r3, r3, #20
   822de:	d528      	bpl.n	82332 <_impl_k_yield+0x66>
	__ASSERT(!_is_in_isr(), "");

	if (!_is_idle(_current)) {
   822e0:	4c1b      	ldr	r4, [pc, #108]	; (82350 <_impl_k_yield+0x84>)
   822e2:	4b1c      	ldr	r3, [pc, #112]	; (82354 <_impl_k_yield+0x88>)
   822e4:	68a2      	ldr	r2, [r4, #8]
   822e6:	681b      	ldr	r3, [r3, #0]
   822e8:	429a      	cmp	r2, r3
   822ea:	d011      	beq.n	82310 <_impl_k_yield+0x44>
		LOCKED(&sched_lock) {
   822ec:	f7ff fd7e 	bl	81dec <k_spin_lock.isra.11>
			_priq_run_remove(&_kernel.ready_q.runq, _current);
   822f0:	68a1      	ldr	r1, [r4, #8]
		LOCKED(&sched_lock) {
   822f2:	4605      	mov	r5, r0
			_priq_run_remove(&_kernel.ready_q.runq, _current);
   822f4:	f104 0020 	add.w	r0, r4, #32
   822f8:	f7ff fe6c 	bl	81fd4 <_priq_dumb_remove>
			_priq_run_add(&_kernel.ready_q.runq, _current);
   822fc:	68a1      	ldr	r1, [r4, #8]
   822fe:	f104 0020 	add.w	r0, r4, #32
   82302:	f7ff fe0d 	bl	81f20 <_priq_dumb_add>
			update_cache(1);
   82306:	2001      	movs	r0, #1
   82308:	f7ff fd78 	bl	81dfc <update_cache>
   8230c:	f385 8811 	msr	BASEPRI, r5
	}

#ifdef CONFIG_SMP
	_Swap(irq_lock());
#else
	if (_get_next_ready_thread() != _current) {
   82310:	68a2      	ldr	r2, [r4, #8]
   82312:	69e3      	ldr	r3, [r4, #28]
   82314:	429a      	cmp	r2, r3
   82316:	d017      	beq.n	82348 <_impl_k_yield+0x7c>
	__asm__ volatile(
   82318:	f04f 0310 	mov.w	r3, #16
   8231c:	f3ef 8011 	mrs	r0, BASEPRI
   82320:	f383 8811 	msr	BASEPRI, r3
	_time_slice_elapsed = 0;
   82324:	2200      	movs	r2, #0
   82326:	4b0c      	ldr	r3, [pc, #48]	; (82358 <_impl_k_yield+0x8c>)
   82328:	601a      	str	r2, [r3, #0]
		_Swap(irq_lock());
	}
#endif
}
   8232a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   8232e:	f7fe bd05 	b.w	80d3c <__swap>
	__ASSERT(!_is_in_isr(), "");
   82332:	f44f 7340 	mov.w	r3, #768	; 0x300
   82336:	4a09      	ldr	r2, [pc, #36]	; (8235c <_impl_k_yield+0x90>)
   82338:	4909      	ldr	r1, [pc, #36]	; (82360 <_impl_k_yield+0x94>)
   8233a:	480a      	ldr	r0, [pc, #40]	; (82364 <_impl_k_yield+0x98>)
   8233c:	f7fe fc52 	bl	80be4 <printk>
   82340:	4809      	ldr	r0, [pc, #36]	; (82368 <_impl_k_yield+0x9c>)
   82342:	f7fe fc4f 	bl	80be4 <printk>
   82346:	e7fe      	b.n	82346 <_impl_k_yield+0x7a>
   82348:	bd38      	pop	{r3, r4, r5, pc}
   8234a:	bf00      	nop
   8234c:	e000ed00 	.word	0xe000ed00
   82350:	20070350 	.word	0x20070350
   82354:	000832f4 	.word	0x000832f4
   82358:	2007037c 	.word	0x2007037c
   8235c:	00083457 	.word	0x00083457
   82360:	0008344b 	.word	0x0008344b
   82364:	00082995 	.word	0x00082995
   82368:	000829b3 	.word	0x000829b3

0008236c <_impl_k_sleep>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER0_SIMPLE_VOID(k_yield);
#endif

void _impl_k_sleep(s32_t duration)
{
   8236c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   8236e:	f3ef 8305 	mrs	r3, IPSR
   82372:	2b0d      	cmp	r3, #13
   82374:	d834      	bhi.n	823e0 <_impl_k_sleep+0x74>
   82376:	b11b      	cbz	r3, 82380 <_impl_k_sleep+0x14>
   82378:	4b1f      	ldr	r3, [pc, #124]	; (823f8 <_impl_k_sleep+0x8c>)
   8237a:	685b      	ldr	r3, [r3, #4]
   8237c:	051a      	lsls	r2, r3, #20
   8237e:	d52f      	bpl.n	823e0 <_impl_k_sleep+0x74>
	 */
	volatile s32_t ticks;
	unsigned int key;

	__ASSERT(!_is_in_isr(), "");
	__ASSERT(duration != K_FOREVER, "");
   82380:	1c43      	adds	r3, r0, #1
   82382:	d10a      	bne.n	8239a <_impl_k_sleep+0x2e>
   82384:	f240 3321 	movw	r3, #801	; 0x321
   82388:	4a1c      	ldr	r2, [pc, #112]	; (823fc <_impl_k_sleep+0x90>)
   8238a:	491d      	ldr	r1, [pc, #116]	; (82400 <_impl_k_sleep+0x94>)
   8238c:	481d      	ldr	r0, [pc, #116]	; (82404 <_impl_k_sleep+0x98>)
   8238e:	f7fe fc29 	bl	80be4 <printk>
   82392:	481d      	ldr	r0, [pc, #116]	; (82408 <_impl_k_sleep+0x9c>)
   82394:	f7fe fc26 	bl	80be4 <printk>
   82398:	e7fe      	b.n	82398 <_impl_k_sleep+0x2c>

	K_DEBUG("thread %p for %d ns\n", _current, duration);

	/* wait of 0 ms is treated as a 'yield' */
	if (duration == 0) {
   8239a:	b918      	cbnz	r0, 823a4 <_impl_k_sleep+0x38>
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield);
   8239c:	f7ff ff96 	bl	822cc <_impl_k_yield>
	_remove_thread_from_ready_q(_current);
	_add_thread_timeout(_current, NULL, ticks);

	_Swap(key);
#endif
}
   823a0:	b003      	add	sp, #12
   823a2:	bd30      	pop	{r4, r5, pc}
   823a4:	230a      	movs	r3, #10
   823a6:	3009      	adds	r0, #9
   823a8:	fb90 f0f3 	sdiv	r0, r0, r3
	ticks = _TICK_ALIGN + _ms_to_ticks(duration);
   823ac:	3001      	adds	r0, #1
   823ae:	9001      	str	r0, [sp, #4]
   823b0:	f04f 0310 	mov.w	r3, #16
   823b4:	f3ef 8511 	mrs	r5, BASEPRI
   823b8:	f383 8811 	msr	BASEPRI, r3
	_remove_thread_from_ready_q(_current);
   823bc:	4c13      	ldr	r4, [pc, #76]	; (8240c <_impl_k_sleep+0xa0>)
   823be:	68a0      	ldr	r0, [r4, #8]
   823c0:	f7ff feca 	bl	82158 <_remove_thread_from_ready_q>
	_add_thread_timeout(_current, NULL, ticks);
   823c4:	68a0      	ldr	r0, [r4, #8]
   823c6:	9b01      	ldr	r3, [sp, #4]
   823c8:	f100 0114 	add.w	r1, r0, #20
   823cc:	2200      	movs	r2, #0
   823ce:	f7ff fe31 	bl	82034 <_add_timeout>
	_time_slice_elapsed = 0;
   823d2:	2200      	movs	r2, #0
   823d4:	4b0e      	ldr	r3, [pc, #56]	; (82410 <_impl_k_sleep+0xa4>)
   823d6:	4628      	mov	r0, r5
   823d8:	601a      	str	r2, [r3, #0]
   823da:	f7fe fcaf 	bl	80d3c <__swap>
   823de:	e7df      	b.n	823a0 <_impl_k_sleep+0x34>
	__ASSERT(!_is_in_isr(), "");
   823e0:	f44f 7348 	mov.w	r3, #800	; 0x320
   823e4:	4a05      	ldr	r2, [pc, #20]	; (823fc <_impl_k_sleep+0x90>)
   823e6:	490b      	ldr	r1, [pc, #44]	; (82414 <_impl_k_sleep+0xa8>)
   823e8:	4806      	ldr	r0, [pc, #24]	; (82404 <_impl_k_sleep+0x98>)
   823ea:	f7fe fbfb 	bl	80be4 <printk>
   823ee:	4806      	ldr	r0, [pc, #24]	; (82408 <_impl_k_sleep+0x9c>)
   823f0:	f7fe fbf8 	bl	80be4 <printk>
   823f4:	e7fe      	b.n	823f4 <_impl_k_sleep+0x88>
   823f6:	bf00      	nop
   823f8:	e000ed00 	.word	0xe000ed00
   823fc:	00083457 	.word	0x00083457
   82400:	000833b9 	.word	0x000833b9
   82404:	00082995 	.word	0x00082995
   82408:	000829b3 	.word	0x000829b3
   8240c:	20070350 	.word	0x20070350
   82410:	2007037c 	.word	0x2007037c
   82414:	0008344b 	.word	0x0008344b

00082418 <_impl_k_current_get>:
#endif

k_tid_t _impl_k_current_get(void)
{
	return _current;
}
   82418:	4b01      	ldr	r3, [pc, #4]	; (82420 <_impl_k_current_get+0x8>)
   8241a:	6898      	ldr	r0, [r3, #8]
   8241c:	4770      	bx	lr
   8241e:	bf00      	nop
   82420:	20070350 	.word	0x20070350

00082424 <_tick_get>:
   82424:	f04f 0210 	mov.w	r2, #16
   82428:	f3ef 8311 	mrs	r3, BASEPRI
   8242c:	f382 8811 	msr	BASEPRI, r2
	unsigned int imask = irq_lock();

#ifdef CONFIG_TICKLESS_KERNEL
	tmp_sys_clock_tick_count = _get_elapsed_clock_time();
#else
	tmp_sys_clock_tick_count = _sys_clock_tick_count;
   82430:	4a02      	ldr	r2, [pc, #8]	; (8243c <_tick_get+0x18>)
   82432:	e9d2 0100 	ldrd	r0, r1, [r2]
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   82436:	f383 8811 	msr	BASEPRI, r3
#endif
	irq_unlock(imask);
	return tmp_sys_clock_tick_count;
}
   8243a:	4770      	bx	lr
   8243c:	20070380 	.word	0x20070380

00082440 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(s32_t ticks)
{
   82440:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   82444:	4607      	mov	r7, r0
   82446:	b085      	sub	sp, #20
	__asm__ volatile(
   82448:	f04f 0310 	mov.w	r3, #16
   8244c:	f3ef 8011 	mrs	r0, BASEPRI
   82450:	f383 8811 	msr	BASEPRI, r3

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
   82454:	4961      	ldr	r1, [pc, #388]	; (825dc <_nano_sys_clock_tick_announce+0x19c>)
   82456:	e9d1 4500 	ldrd	r4, r5, [r1]
   8245a:	19e2      	adds	r2, r4, r7
   8245c:	eb45 73e7 	adc.w	r3, r5, r7, asr #31
   82460:	e9c1 2300 	strd	r2, r3, [r1]
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   82464:	f380 8811 	msr	BASEPRI, r0
	list->head = (sys_dnode_t *)list;
   82468:	ae02      	add	r6, sp, #8
   8246a:	9602      	str	r6, [sp, #8]
	list->tail = (sys_dnode_t *)list;
   8246c:	9603      	str	r6, [sp, #12]
	__asm__ volatile(
   8246e:	f04f 0310 	mov.w	r3, #16
   82472:	f3ef 8011 	mrs	r0, BASEPRI
   82476:	f383 8811 	msr	BASEPRI, r3
	return list->head == list;
   8247a:	4c59      	ldr	r4, [pc, #356]	; (825e0 <_nano_sys_clock_tick_announce+0x1a0>)
   8247c:	4602      	mov	r2, r0
   8247e:	4621      	mov	r1, r4
   82480:	f851 3f14 	ldr.w	r3, [r1, #20]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   82484:	428b      	cmp	r3, r1
   82486:	d000      	beq.n	8248a <_nano_sys_clock_tick_announce+0x4a>
	if (!next) {
   82488:	b9fb      	cbnz	r3, 824ca <_nano_sys_clock_tick_announce+0x8a>
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   8248a:	f380 8811 	msr	BASEPRI, r0
	if (!_is_thread_time_slicing(_current)) {
   8248e:	68a0      	ldr	r0, [r4, #8]
   82490:	f7ff feba 	bl	82208 <_is_thread_time_slicing>
   82494:	b1b0      	cbz	r0, 824c4 <_nano_sys_clock_tick_announce+0x84>
	_time_slice_elapsed += __ticks_to_ms(ticks);
   82496:	230a      	movs	r3, #10
   82498:	4a52      	ldr	r2, [pc, #328]	; (825e4 <_nano_sys_clock_tick_announce+0x1a4>)
   8249a:	6811      	ldr	r1, [r2, #0]
   8249c:	fb07 1703 	mla	r7, r7, r3, r1
	if (_time_slice_elapsed >= _time_slice_duration) {
   824a0:	4b51      	ldr	r3, [pc, #324]	; (825e8 <_nano_sys_clock_tick_announce+0x1a8>)
	_time_slice_elapsed += __ticks_to_ms(ticks);
   824a2:	6017      	str	r7, [r2, #0]
	if (_time_slice_elapsed >= _time_slice_duration) {
   824a4:	681b      	ldr	r3, [r3, #0]
   824a6:	429f      	cmp	r7, r3
   824a8:	db0c      	blt.n	824c4 <_nano_sys_clock_tick_announce+0x84>
		_time_slice_elapsed = 0;
   824aa:	2300      	movs	r3, #0
   824ac:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   824ae:	f04f 0310 	mov.w	r3, #16
   824b2:	f3ef 8511 	mrs	r5, BASEPRI
   824b6:	f383 8811 	msr	BASEPRI, r3
		_move_thread_to_end_of_prio_q(_current);
   824ba:	68a0      	ldr	r0, [r4, #8]
   824bc:	f7ff fe32 	bl	82124 <_move_thread_to_end_of_prio_q>
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   824c0:	f385 8811 	msr	BASEPRI, r5
	if ((!remaining && next_to) || (next_to < remaining)) {
		/* Clears current program if next_to = 0 and remaining > 0 */
		_set_time(next_to);
	}
#endif
}
   824c4:	b005      	add	sp, #20
   824c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	_handling_timeouts = 1;
   824ca:	2101      	movs	r1, #1
   824cc:	4d47      	ldr	r5, [pc, #284]	; (825ec <_nano_sys_clock_tick_announce+0x1ac>)
			timeout->delta_ticks_from_prev = 0;
   824ce:	f04f 0e00 	mov.w	lr, #0
	_handling_timeouts = 1;
   824d2:	6029      	str	r1, [r5, #0]
			timeout->delta_ticks_from_prev = _EXPIRED;
   824d4:	f06f 0c01 	mvn.w	ip, #1
	_handling_timeouts = 1;
   824d8:	4639      	mov	r1, r7
   824da:	9501      	str	r5, [sp, #4]
		s32_t tmp = timeout->delta_ticks_from_prev;
   824dc:	6918      	ldr	r0, [r3, #16]
		if (timeout->delta_ticks_from_prev < ticks) {
   824de:	4288      	cmp	r0, r1
			timeout->delta_ticks_from_prev -= ticks;
   824e0:	bfaa      	itet	ge
   824e2:	eba0 0801 	subge.w	r8, r0, r1
			timeout->delta_ticks_from_prev = 0;
   824e6:	f8c3 e010 	strlt.w	lr, [r3, #16]
			timeout->delta_ticks_from_prev -= ticks;
   824ea:	f8c3 8010 	strge.w	r8, [r3, #16]
		ticks -= tmp;
   824ee:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
   824f0:	69a0      	ldr	r0, [r4, #24]
		if (timeout->delta_ticks_from_prev == 0) {
   824f2:	691d      	ldr	r5, [r3, #16]
   824f4:	4298      	cmp	r0, r3
   824f6:	bf14      	ite	ne
   824f8:	6818      	ldrne	r0, [r3, #0]
   824fa:	2000      	moveq	r0, #0
   824fc:	b9d5      	cbnz	r5, 82534 <_nano_sys_clock_tick_announce+0xf4>
	node->prev->next = node->next;
   824fe:	e893 0220 	ldmia.w	r3, {r5, r9}
   82502:	f8c9 5000 	str.w	r5, [r9]
	node->next->prev = node->prev;
   82506:	681d      	ldr	r5, [r3, #0]
   82508:	f8c5 9004 	str.w	r9, [r5, #4]
	node->next = list->head;
   8250c:	9d02      	ldr	r5, [sp, #8]
	node->prev = list;
   8250e:	e883 0060 	stmia.w	r3, {r5, r6}
	list->head->prev = node;
   82512:	9d02      	ldr	r5, [sp, #8]
	list->head = node;
   82514:	9302      	str	r3, [sp, #8]
	list->head->prev = node;
   82516:	606b      	str	r3, [r5, #4]
			timeout->delta_ticks_from_prev = _EXPIRED;
   82518:	f8c3 c010 	str.w	ip, [r3, #16]
   8251c:	f382 8811 	msr	BASEPRI, r2
	__asm__ volatile(
   82520:	f04f 0310 	mov.w	r3, #16
   82524:	f3ef 8211 	mrs	r2, BASEPRI
   82528:	f383 8811 	msr	BASEPRI, r3
	while (next) {
   8252c:	4603      	mov	r3, r0
   8252e:	2800      	cmp	r0, #0
   82530:	d1d4      	bne.n	824dc <_nano_sys_clock_tick_announce+0x9c>
   82532:	e001      	b.n	82538 <_nano_sys_clock_tick_announce+0xf8>
		} else if (ticks <= 0) {
   82534:	2900      	cmp	r1, #0
   82536:	dcf1      	bgt.n	8251c <_nano_sys_clock_tick_announce+0xdc>
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   82538:	f382 8811 	msr	BASEPRI, r2
	return list->head == list;
   8253c:	9802      	ldr	r0, [sp, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   8253e:	42b0      	cmp	r0, r6
   82540:	d103      	bne.n	8254a <_nano_sys_clock_tick_announce+0x10a>
	_handling_timeouts = 0;
   82542:	2300      	movs	r3, #0
   82544:	9a01      	ldr	r2, [sp, #4]
   82546:	6013      	str	r3, [r2, #0]
   82548:	e7a1      	b.n	8248e <_nano_sys_clock_tick_announce+0x4e>
	SYS_DLIST_FOR_EACH_CONTAINER_SAFE(expired, timeout, next, node) {
   8254a:	2800      	cmp	r0, #0
   8254c:	d0f9      	beq.n	82542 <_nano_sys_clock_tick_announce+0x102>
	return (node == list->tail) ? NULL : node->next;
   8254e:	9b03      	ldr	r3, [sp, #12]
   82550:	4298      	cmp	r0, r3
   82552:	d102      	bne.n	8255a <_nano_sys_clock_tick_announce+0x11a>
   82554:	f04f 0b00 	mov.w	fp, #0
   82558:	e001      	b.n	8255e <_nano_sys_clock_tick_announce+0x11e>
   8255a:	f8d0 b000 	ldr.w	fp, [r0]
	timeout->delta_ticks_from_prev = _INACTIVE;
   8255e:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
		thread->base.timeout.wait_q = NULL;
   82562:	f04f 0a00 	mov.w	sl, #0
	node->prev->next = node->next;
   82566:	e890 000c 	ldmia.w	r0, {r2, r3}
   8256a:	601a      	str	r2, [r3, #0]
	node->next->prev = node->prev;
   8256c:	6802      	ldr	r2, [r0, #0]
   8256e:	6053      	str	r3, [r2, #4]
	struct k_thread *thread = timeout->thread;
   82570:	6886      	ldr	r6, [r0, #8]
	__asm__ volatile(
   82572:	f04f 0310 	mov.w	r3, #16
   82576:	f3ef 8811 	mrs	r8, BASEPRI
   8257a:	f383 8811 	msr	BASEPRI, r3
	timeout->delta_ticks_from_prev = _INACTIVE;
   8257e:	f8c0 9010 	str.w	r9, [r0, #16]
	if (thread) {
   82582:	b1d6      	cbz	r6, 825ba <_nano_sys_clock_tick_announce+0x17a>
	if (timeout_obj->wait_q) {
   82584:	68c3      	ldr	r3, [r0, #12]
   82586:	b123      	cbz	r3, 82592 <_nano_sys_clock_tick_announce+0x152>
		_unpend_thread_no_timeout(thread);
   82588:	4630      	mov	r0, r6
   8258a:	f7ff fd43 	bl	82014 <_unpend_thread_no_timeout>
		thread->base.timeout.wait_q = NULL;
   8258e:	f8c6 a020 	str.w	sl, [r6, #32]
	thread->base.thread_state &= ~_THREAD_PRESTART;
   82592:	7a73      	ldrb	r3, [r6, #9]
   82594:	f023 0204 	bic.w	r2, r3, #4
	return !(_is_thread_prevented_from_running(thread) ||
   82598:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   8259c:	7272      	strb	r2, [r6, #9]
	return !(_is_thread_prevented_from_running(thread) ||
   8259e:	d102      	bne.n	825a6 <_nano_sys_clock_tick_announce+0x166>
   825a0:	6a73      	ldr	r3, [r6, #36]	; 0x24
   825a2:	3301      	adds	r3, #1
   825a4:	d015      	beq.n	825d2 <_nano_sys_clock_tick_announce+0x192>
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   825a6:	f388 8811 	msr	BASEPRI, r8
	SYS_DLIST_FOR_EACH_CONTAINER_SAFE(expired, timeout, next, node) {
   825aa:	f1bb 0f00 	cmp.w	fp, #0
   825ae:	d0c8      	beq.n	82542 <_nano_sys_clock_tick_announce+0x102>
	return (node == list->tail) ? NULL : node->next;
   825b0:	9b03      	ldr	r3, [sp, #12]
   825b2:	455b      	cmp	r3, fp
   825b4:	d108      	bne.n	825c8 <_nano_sys_clock_tick_announce+0x188>
   825b6:	2300      	movs	r3, #0
   825b8:	e008      	b.n	825cc <_nano_sys_clock_tick_announce+0x18c>
   825ba:	f388 8811 	msr	BASEPRI, r8
		if (timeout->func) {
   825be:	6943      	ldr	r3, [r0, #20]
   825c0:	2b00      	cmp	r3, #0
   825c2:	d0f2      	beq.n	825aa <_nano_sys_clock_tick_announce+0x16a>
			timeout->func(timeout);
   825c4:	4798      	blx	r3
   825c6:	e7f0      	b.n	825aa <_nano_sys_clock_tick_announce+0x16a>
   825c8:	f8db 3000 	ldr.w	r3, [fp]
	SYS_DLIST_FOR_EACH_CONTAINER_SAFE(expired, timeout, next, node) {
   825cc:	4658      	mov	r0, fp
   825ce:	469b      	mov	fp, r3
   825d0:	e7c9      	b.n	82566 <_nano_sys_clock_tick_announce+0x126>
		_add_thread_to_ready_q(thread);
   825d2:	4630      	mov	r0, r6
   825d4:	f7ff fcde 	bl	81f94 <_add_thread_to_ready_q>
   825d8:	e7e5      	b.n	825a6 <_nano_sys_clock_tick_announce+0x166>
   825da:	bf00      	nop
   825dc:	20070380 	.word	0x20070380
   825e0:	20070350 	.word	0x20070350
   825e4:	2007037c 	.word	0x2007037c
   825e8:	200700f8 	.word	0x200700f8
   825ec:	20070378 	.word	0x20070378

000825f0 <_abort_timeout>:
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
   825f0:	6903      	ldr	r3, [r0, #16]
   825f2:	1c5a      	adds	r2, r3, #1
   825f4:	d011      	beq.n	8261a <_abort_timeout+0x2a>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
   825f6:	4a0a      	ldr	r2, [pc, #40]	; (82620 <_abort_timeout+0x30>)
   825f8:	6992      	ldr	r2, [r2, #24]
   825fa:	4290      	cmp	r0, r2
   825fc:	bf1f      	itttt	ne
   825fe:	6801      	ldrne	r1, [r0, #0]
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
   82600:	690a      	ldrne	r2, [r1, #16]
   82602:	189b      	addne	r3, r3, r2
   82604:	610b      	strne	r3, [r1, #16]
	node->prev->next = node->next;
   82606:	e890 000c 	ldmia.w	r0, {r2, r3}
   8260a:	601a      	str	r2, [r3, #0]
	node->next->prev = node->prev;
   8260c:	6802      	ldr	r2, [r0, #0]
   8260e:	6053      	str	r3, [r2, #4]
	timeout->delta_ticks_from_prev = _INACTIVE;
   82610:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   82614:	6103      	str	r3, [r0, #16]
	return 0;
   82616:	2000      	movs	r0, #0
   82618:	4770      	bx	lr
		return _INACTIVE;
   8261a:	4618      	mov	r0, r3
}
   8261c:	4770      	bx	lr
   8261e:	bf00      	nop
   82620:	20070350 	.word	0x20070350

00082624 <_ready_thread>:
	return !(_is_thread_prevented_from_running(thread) ||
   82624:	7a42      	ldrb	r2, [r0, #9]
   82626:	06d2      	lsls	r2, r2, #27
   82628:	d104      	bne.n	82634 <_ready_thread+0x10>
   8262a:	6a43      	ldr	r3, [r0, #36]	; 0x24
   8262c:	3301      	adds	r3, #1
   8262e:	d101      	bne.n	82634 <_ready_thread+0x10>
		_add_thread_to_ready_q(thread);
   82630:	f7ff bcb0 	b.w	81f94 <_add_thread_to_ready_q>
   82634:	4770      	bx	lr
	...

00082638 <schedule_new_thread.part.11>:
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_thread_start, K_OBJ_THREAD, struct k_thread *);
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, s32_t delay)
   82638:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8263a:	f101 0509 	add.w	r5, r1, #9
   8263e:	210a      	movs	r1, #10
   82640:	fb95 f5f1 	sdiv	r5, r5, r1
   82644:	4604      	mov	r4, r0
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
		k_thread_start(thread);
	} else {
		s32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
   82646:	3501      	adds	r5, #1
	__asm__ volatile(
   82648:	f04f 0310 	mov.w	r3, #16
   8264c:	f3ef 8611 	mrs	r6, BASEPRI
   82650:	f383 8811 	msr	BASEPRI, r3
	__ASSERT(timeout_in_ticks >= 0, "");
   82654:	2d00      	cmp	r5, #0
   82656:	da09      	bge.n	8266c <schedule_new_thread.part.11+0x34>
   82658:	23c9      	movs	r3, #201	; 0xc9
   8265a:	4a28      	ldr	r2, [pc, #160]	; (826fc <schedule_new_thread.part.11+0xc4>)
   8265c:	4928      	ldr	r1, [pc, #160]	; (82700 <schedule_new_thread.part.11+0xc8>)
   8265e:	4829      	ldr	r0, [pc, #164]	; (82704 <schedule_new_thread.part.11+0xcc>)
   82660:	f7fe fac0 	bl	80be4 <printk>
   82664:	4828      	ldr	r0, [pc, #160]	; (82708 <schedule_new_thread.part.11+0xd0>)
   82666:	f7fe fabd 	bl	80be4 <printk>
   8266a:	e7fe      	b.n	8266a <schedule_new_thread.part.11+0x32>
	timeout->wait_q = (sys_dlist_t *)wait_q;
   8266c:	f04f 0300 	mov.w	r3, #0
	timeout->delta_ticks_from_prev = timeout_in_ticks;
   82670:	6245      	str	r5, [r0, #36]	; 0x24
	timeout->thread = thread;
   82672:	61e0      	str	r0, [r4, #28]
	timeout->wait_q = (sys_dlist_t *)wait_q;
   82674:	6203      	str	r3, [r0, #32]
	if (!timeout_in_ticks) {
   82676:	d119      	bne.n	826ac <schedule_new_thread.part.11+0x74>
   82678:	f04f 0310 	mov.w	r3, #16
   8267c:	f3ef 8711 	mrs	r7, BASEPRI
   82680:	f383 8811 	msr	BASEPRI, r3
	timeout->delta_ticks_from_prev = _INACTIVE;
   82684:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   82688:	6243      	str	r3, [r0, #36]	; 0x24
	if (timeout_obj->wait_q) {
   8268a:	6a03      	ldr	r3, [r0, #32]
   8268c:	b113      	cbz	r3, 82694 <schedule_new_thread.part.11+0x5c>
		_unpend_thread_no_timeout(thread);
   8268e:	f7ff fcc1 	bl	82014 <_unpend_thread_no_timeout>
		thread->base.timeout.wait_q = NULL;
   82692:	6225      	str	r5, [r4, #32]
	thread->base.thread_state &= ~_THREAD_PRESTART;
   82694:	7a63      	ldrb	r3, [r4, #9]
		_ready_thread(thread);
   82696:	4620      	mov	r0, r4
   82698:	f023 0304 	bic.w	r3, r3, #4
   8269c:	7263      	strb	r3, [r4, #9]
   8269e:	f7ff ffc1 	bl	82624 <_ready_thread>
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   826a2:	f387 8811 	msr	BASEPRI, r7
   826a6:	f386 8811 	msr	BASEPRI, r6
   826aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return list->head == list;
   826ac:	4a17      	ldr	r2, [pc, #92]	; (8270c <schedule_new_thread.part.11+0xd4>)
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
   826ae:	f100 0714 	add.w	r7, r0, #20
   826b2:	4611      	mov	r1, r2
   826b4:	f851 3f14 	ldr.w	r3, [r1, #20]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   826b8:	428b      	cmp	r3, r1
   826ba:	d106      	bne.n	826ca <schedule_new_thread.part.11+0x92>
	node->next = list;
   826bc:	6161      	str	r1, [r4, #20]
	node->prev = list->tail;
   826be:	6993      	ldr	r3, [r2, #24]
   826c0:	61a3      	str	r3, [r4, #24]
	list->tail->next = node;
   826c2:	6993      	ldr	r3, [r2, #24]
   826c4:	601f      	str	r7, [r3, #0]
	list->tail = node;
   826c6:	6197      	str	r7, [r2, #24]
   826c8:	e7ed      	b.n	826a6 <schedule_new_thread.part.11+0x6e>
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
   826ca:	2b00      	cmp	r3, #0
   826cc:	d0f6      	beq.n	826bc <schedule_new_thread.part.11+0x84>
   826ce:	f8d2 e018 	ldr.w	lr, [r2, #24]
		if (*delta <= in_q->delta_ticks_from_prev) {
   826d2:	6a60      	ldr	r0, [r4, #36]	; 0x24
   826d4:	691d      	ldr	r5, [r3, #16]
   826d6:	42a8      	cmp	r0, r5
   826d8:	dc08      	bgt.n	826ec <schedule_new_thread.part.11+0xb4>
		node->prev = insert_point->prev;
   826da:	685a      	ldr	r2, [r3, #4]
			in_q->delta_ticks_from_prev -= *delta;
   826dc:	1a28      	subs	r0, r5, r0
   826de:	6118      	str	r0, [r3, #16]
   826e0:	61a2      	str	r2, [r4, #24]
		node->next = insert_point;
   826e2:	6163      	str	r3, [r4, #20]
		insert_point->prev->next = node;
   826e4:	685a      	ldr	r2, [r3, #4]
   826e6:	6017      	str	r7, [r2, #0]
		insert_point->prev = node;
   826e8:	605f      	str	r7, [r3, #4]
   826ea:	e7dc      	b.n	826a6 <schedule_new_thread.part.11+0x6e>
		*delta -= in_q->delta_ticks_from_prev;
   826ec:	1b40      	subs	r0, r0, r5
	return (node == list->tail) ? NULL : node->next;
   826ee:	4573      	cmp	r3, lr
   826f0:	6260      	str	r0, [r4, #36]	; 0x24
   826f2:	d0e3      	beq.n	826bc <schedule_new_thread.part.11+0x84>
   826f4:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
   826f6:	2b00      	cmp	r3, #0
   826f8:	d1eb      	bne.n	826d2 <schedule_new_thread.part.11+0x9a>
   826fa:	e7df      	b.n	826bc <schedule_new_thread.part.11+0x84>
   826fc:	00083373 	.word	0x00083373
   82700:	000833a3 	.word	0x000833a3
   82704:	00082995 	.word	0x00082995
   82708:	000829b3 	.word	0x000829b3
   8270c:	20070350 	.word	0x20070350

00082710 <k_is_in_isr>:
   82710:	f3ef 8005 	mrs	r0, IPSR
   82714:	280d      	cmp	r0, #13
   82716:	d807      	bhi.n	82728 <k_is_in_isr+0x18>
   82718:	b138      	cbz	r0, 8272a <k_is_in_isr+0x1a>
   8271a:	4b04      	ldr	r3, [pc, #16]	; (8272c <k_is_in_isr+0x1c>)
   8271c:	6858      	ldr	r0, [r3, #4]
   8271e:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
   82722:	f3c0 20c0 	ubfx	r0, r0, #11, #1
   82726:	4770      	bx	lr
   82728:	2001      	movs	r0, #1
}
   8272a:	4770      	bx	lr
   8272c:	e000ed00 	.word	0xe000ed00

00082730 <_is_thread_essential>:
	return _current->base.user_options & K_ESSENTIAL;
   82730:	4b02      	ldr	r3, [pc, #8]	; (8273c <_is_thread_essential+0xc>)
   82732:	689b      	ldr	r3, [r3, #8]
   82734:	7a18      	ldrb	r0, [r3, #8]
}
   82736:	f000 0001 	and.w	r0, r0, #1
   8273a:	4770      	bx	lr
   8273c:	20070350 	.word	0x20070350

00082740 <_impl_k_thread_start>:
{
   82740:	b510      	push	{r4, lr}
	__asm__ volatile(
   82742:	f04f 0310 	mov.w	r3, #16
   82746:	f3ef 8411 	mrs	r4, BASEPRI
   8274a:	f383 8811 	msr	BASEPRI, r3
   8274e:	7a43      	ldrb	r3, [r0, #9]
	if (_has_thread_started(thread)) {
   82750:	0759      	lsls	r1, r3, #29
   82752:	d402      	bmi.n	8275a <_impl_k_thread_start+0x1a>
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   82754:	f384 8811 	msr	BASEPRI, r4
   82758:	bd10      	pop	{r4, pc}
   8275a:	f023 0304 	bic.w	r3, r3, #4
   8275e:	7243      	strb	r3, [r0, #9]
	_ready_thread(thread);
   82760:	f7ff ff60 	bl	82624 <_ready_thread>
	_reschedule(key);
   82764:	4620      	mov	r0, r4
}
   82766:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_reschedule(key);
   8276a:	f7ff bb73 	b.w	81e54 <_reschedule>
	...

00082770 <_setup_new_thread>:
void _setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options)
{
   82770:	b530      	push	{r4, r5, lr}
   82772:	b087      	sub	sp, #28
	stack_size = adjust_stack_size(stack_size);

	_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   82774:	9d0e      	ldr	r5, [sp, #56]	; 0x38
{
   82776:	4604      	mov	r4, r0
	_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   82778:	9504      	str	r5, [sp, #16]
   8277a:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   8277c:	9503      	str	r5, [sp, #12]
   8277e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   82780:	9502      	str	r5, [sp, #8]
   82782:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   82784:	9501      	str	r5, [sp, #4]
   82786:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   82788:	9500      	str	r5, [sp, #0]
   8278a:	f7fe fc95 	bl	810b8 <_new_thread>
	/* Any given thread has access to itself */
	k_object_access_grant(new_thread, new_thread);
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
   8278e:	4b04      	ldr	r3, [pc, #16]	; (827a0 <_setup_new_thread+0x30>)
   82790:	689b      	ldr	r3, [r3, #8]
   82792:	b913      	cbnz	r3, 8279a <_setup_new_thread+0x2a>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
   82794:	65e3      	str	r3, [r4, #92]	; 0x5c
}
   82796:	b007      	add	sp, #28
   82798:	bd30      	pop	{r4, r5, pc}
	new_thread->resource_pool = _current->resource_pool;
   8279a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
   8279c:	e7fa      	b.n	82794 <_setup_new_thread+0x24>
   8279e:	bf00      	nop
   827a0:	20070350 	.word	0x20070350

000827a4 <_k_thread_single_abort>:
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_thread_resume, K_OBJ_THREAD, k_tid_t);
#endif

void _k_thread_single_abort(struct k_thread *thread)
{
	if (thread->fn_abort != NULL) {
   827a4:	6d43      	ldr	r3, [r0, #84]	; 0x54
{
   827a6:	b510      	push	{r4, lr}
   827a8:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   827aa:	b103      	cbz	r3, 827ae <_k_thread_single_abort+0xa>
		thread->fn_abort();
   827ac:	4798      	blx	r3
   827ae:	7a63      	ldrb	r3, [r4, #9]
	return !(_is_thread_prevented_from_running(thread) ||
   827b0:	06da      	lsls	r2, r3, #27
   827b2:	d106      	bne.n	827c2 <_k_thread_single_abort+0x1e>
   827b4:	6a62      	ldr	r2, [r4, #36]	; 0x24
   827b6:	3201      	adds	r2, #1
   827b8:	d103      	bne.n	827c2 <_k_thread_single_abort+0x1e>
	}

	if (_is_thread_ready(thread)) {
		_remove_thread_from_ready_q(thread);
   827ba:	4620      	mov	r0, r4
   827bc:	f7ff fccc 	bl	82158 <_remove_thread_from_ready_q>
   827c0:	e00b      	b.n	827da <_k_thread_single_abort+0x36>
	} else {
		if (_is_thread_pending(thread)) {
   827c2:	079b      	lsls	r3, r3, #30
   827c4:	d502      	bpl.n	827cc <_k_thread_single_abort+0x28>
			_unpend_thread_no_timeout(thread);
   827c6:	4620      	mov	r0, r4
   827c8:	f7ff fc24 	bl	82014 <_unpend_thread_no_timeout>
		}
		if (_is_thread_timeout_active(thread)) {
   827cc:	6a63      	ldr	r3, [r4, #36]	; 0x24
   827ce:	3301      	adds	r3, #1
   827d0:	d003      	beq.n	827da <_k_thread_single_abort+0x36>
	return _abort_timeout(&thread->base.timeout);
   827d2:	f104 0014 	add.w	r0, r4, #20
   827d6:	f7ff ff0b 	bl	825f0 <_abort_timeout>
			_abort_thread_timeout(thread);
		}
	}

	thread->base.thread_state |= _THREAD_DEAD;
   827da:	7a63      	ldrb	r3, [r4, #9]
   827dc:	f043 0308 	orr.w	r3, r3, #8
   827e0:	7263      	strb	r3, [r4, #9]
	_k_object_uninit(thread);

	/* Revoke permissions on thread's ID so that it may be recycled */
	_thread_perms_all_clear(thread);
#endif
}
   827e2:	bd10      	pop	{r4, pc}

000827e4 <_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void _init_static_threads(void)
{
   827e4:	b5f0      	push	{r4, r5, r6, r7, lr}
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
   827e6:	4f30      	ldr	r7, [pc, #192]	; (828a8 <_init_static_threads+0xc4>)
   827e8:	4d30      	ldr	r5, [pc, #192]	; (828ac <_init_static_threads+0xc8>)
   827ea:	463e      	mov	r6, r7
{
   827ec:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   827ee:	42bd      	cmp	r5, r7
   827f0:	f105 042c 	add.w	r4, r5, #44	; 0x2c
   827f4:	d317      	bcc.n	82826 <_init_static_threads+0x42>
   827f6:	f3ef 8305 	mrs	r3, IPSR
   827fa:	2b0d      	cmp	r3, #13
   827fc:	d84a      	bhi.n	82894 <_init_static_threads+0xb0>
   827fe:	b11b      	cbz	r3, 82808 <_init_static_threads+0x24>
   82800:	4b2b      	ldr	r3, [pc, #172]	; (828b0 <_init_static_threads+0xcc>)
   82802:	685b      	ldr	r3, [r3, #4]
   82804:	051a      	lsls	r2, r3, #20
   82806:	d545      	bpl.n	82894 <_init_static_threads+0xb0>
	__ASSERT(_current->base.sched_locked != 1, "");
   82808:	4b2a      	ldr	r3, [pc, #168]	; (828b4 <_init_static_threads+0xd0>)
   8280a:	689a      	ldr	r2, [r3, #8]
   8280c:	7ad3      	ldrb	r3, [r2, #11]
   8280e:	2b01      	cmp	r3, #1
   82810:	d122      	bne.n	82858 <_init_static_threads+0x74>
   82812:	23f6      	movs	r3, #246	; 0xf6
   82814:	4a28      	ldr	r2, [pc, #160]	; (828b8 <_init_static_threads+0xd4>)
   82816:	4929      	ldr	r1, [pc, #164]	; (828bc <_init_static_threads+0xd8>)
   82818:	4829      	ldr	r0, [pc, #164]	; (828c0 <_init_static_threads+0xdc>)
   8281a:	f7fe f9e3 	bl	80be4 <printk>
   8281e:	4829      	ldr	r0, [pc, #164]	; (828c4 <_init_static_threads+0xe0>)
   82820:	f7fe f9e0 	bl	80be4 <printk>
   82824:	e7fe      	b.n	82824 <_init_static_threads+0x40>
		_setup_new_thread(
   82826:	f854 3c0c 	ldr.w	r3, [r4, #-12]
   8282a:	f1a4 002c 	sub.w	r0, r4, #44	; 0x2c
   8282e:	9304      	str	r3, [sp, #16]
   82830:	f854 3c10 	ldr.w	r3, [r4, #-16]
   82834:	9303      	str	r3, [sp, #12]
   82836:	f854 3c14 	ldr.w	r3, [r4, #-20]
   8283a:	9302      	str	r3, [sp, #8]
   8283c:	f854 3c18 	ldr.w	r3, [r4, #-24]
   82840:	9301      	str	r3, [sp, #4]
   82842:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   82846:	9300      	str	r3, [sp, #0]
   82848:	c80f      	ldmia	r0, {r0, r1, r2, r3}
   8284a:	f7ff ff91 	bl	82770 <_setup_new_thread>
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->init_thread->init_data = thread_data;
   8284e:	f854 3c2c 	ldr.w	r3, [r4, #-44]
   82852:	651d      	str	r5, [r3, #80]	; 0x50
   82854:	4625      	mov	r5, r4
   82856:	e7ca      	b.n	827ee <_init_static_threads+0xa>
	--_current->base.sched_locked;
   82858:	3b01      	subs	r3, #1
   8285a:	72d3      	strb	r3, [r2, #11]
	__asm__ volatile(
   8285c:	f04f 0310 	mov.w	r3, #16
   82860:	f3ef 8511 	mrs	r5, BASEPRI
   82864:	f383 8811 	msr	BASEPRI, r3
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
   82868:	4c10      	ldr	r4, [pc, #64]	; (828ac <_init_static_threads+0xc8>)
   8286a:	42b4      	cmp	r4, r6
   8286c:	d306      	bcc.n	8287c <_init_static_threads+0x98>
	__asm__ volatile("msr BASEPRI, %0" :  : "r"(key) : "memory");
   8286e:	f385 8811 	msr	BASEPRI, r5
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
}
   82872:	b007      	add	sp, #28
   82874:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
   82878:	f7ff bb0a 	b.w	81e90 <k_sched_unlock>
		if (thread_data->init_delay != K_FOREVER) {
   8287c:	6a61      	ldr	r1, [r4, #36]	; 0x24
   8287e:	1c4b      	adds	r3, r1, #1
   82880:	d003      	beq.n	8288a <_init_static_threads+0xa6>
			schedule_new_thread(thread_data->init_thread,
   82882:	6820      	ldr	r0, [r4, #0]
	if (delay == 0) {
   82884:	b919      	cbnz	r1, 8288e <_init_static_threads+0xaa>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_START, k_thread_start, k_tid_t, thread);
   82886:	f7ff ff5b 	bl	82740 <_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   8288a:	342c      	adds	r4, #44	; 0x2c
   8288c:	e7ed      	b.n	8286a <_init_static_threads+0x86>
   8288e:	f7ff fed3 	bl	82638 <schedule_new_thread.part.11>
   82892:	e7fa      	b.n	8288a <_init_static_threads+0xa6>
	__ASSERT(!_is_in_isr(), "");
   82894:	23f5      	movs	r3, #245	; 0xf5
   82896:	4a08      	ldr	r2, [pc, #32]	; (828b8 <_init_static_threads+0xd4>)
   82898:	490b      	ldr	r1, [pc, #44]	; (828c8 <_init_static_threads+0xe4>)
   8289a:	4809      	ldr	r0, [pc, #36]	; (828c0 <_init_static_threads+0xdc>)
   8289c:	f7fe f9a2 	bl	80be4 <printk>
   828a0:	4808      	ldr	r0, [pc, #32]	; (828c4 <_init_static_threads+0xe0>)
   828a2:	f7fe f99f 	bl	80be4 <printk>
   828a6:	e7fe      	b.n	828a6 <_init_static_threads+0xc2>
   828a8:	20071da0 	.word	0x20071da0
   828ac:	20071d1c 	.word	0x20071d1c
   828b0:	e000ed00 	.word	0xe000ed00
   828b4:	20070350 	.word	0x20070350
   828b8:	000833f6 	.word	0x000833f6
   828bc:	00083423 	.word	0x00083423
   828c0:	00082995 	.word	0x00082995
   828c4:	000829b3 	.word	0x000829b3
   828c8:	0008344b 	.word	0x0008344b

000828cc <_init_thread_base>:
void _init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
   828cc:	7203      	strb	r3, [r0, #8]
	thread_base->thread_state = (u8_t)initial_state;
   828ce:	7242      	strb	r2, [r0, #9]

	thread_base->prio = priority;

	thread_base->sched_locked = 0;
   828d0:	2300      	movs	r3, #0
	t->delta_ticks_from_prev = _INACTIVE;
   828d2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	thread_base->prio = priority;
   828d6:	7281      	strb	r1, [r0, #10]
	thread_base->sched_locked = 0;
   828d8:	72c3      	strb	r3, [r0, #11]
   828da:	6242      	str	r2, [r0, #36]	; 0x24
	t->wait_q = NULL;
   828dc:	6203      	str	r3, [r0, #32]
	t->thread = NULL;
   828de:	61c3      	str	r3, [r0, #28]
	t->func = func;
   828e0:	6283      	str	r3, [r0, #40]	; 0x28
   828e2:	4770      	bx	lr

000828e4 <_OffsetAbsSyms>:

#ifdef CONFIG_FLOAT
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread) -
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
   828e4:	4770      	bx	lr
